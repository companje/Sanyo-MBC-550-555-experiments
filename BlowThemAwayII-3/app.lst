     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 E9C700              <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 80          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34                              <1> cursor:
    35 00000003 00                  <1> .col: db 0
    36 00000004 00                  <1> .row: db 0
    37                              <1> 
    38                              <1> key:
    39 00000005 00                  <1>   .code db 0
    40 00000006 00                  <1>   .ctrl db 0
    41                              <1> 
    42                              <1> %macro set_cursor 2
    43                              <1>   ; mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    44                              <1>   mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    45                              <1> %endmacro
    46                              <1> 
    47                              <1> %macro print 1
    48                              <1>   push ax
    49                              <1>   push bx
    50                              <1>   push cx
    51                              <1>   push dx
    52                              <1>   jmp %%endstr 
    53                              <1>   %%str: db %1,0
    54                              <1>   %%endstr: 
    55                              <1>   mov bx,%%str
    56                              <1>   call write_string
    57                              <1>   pop dx
    58                              <1>   pop cx
    59                              <1>   pop bx
    60                              <1>   pop ax
    61                              <1> %endmacro
    62                              <1> 
    63                              <1> %macro println 1
    64                              <1>   print %1
    65                              <1>   call new_line
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro print_ax 0
    69                              <1>   call write_signed_number_word
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro print_ax_unsigned 0
    73                              <1>   call write_number_word
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro print_ax_hex 0
    77                              <1>   call write_ax_hex
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro print_ax_bin 0
    81                              <1>   call write_binary_word
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %macro print_char 1
    85                              <1>   push ax
    86                              <1>   mov al,%1
    87                              <1>   call write_char
    88                              <1>   pop ax
    89                              <1> %endmacro
    90                              <1> 
    91                              <1> %macro print_2chars 1
    92                              <1>   push ax
    93                              <1>   mov ax,%1
    94                              <1>   call write_2chars
    95                              <1>   pop ax
    96                              <1> %endmacro
    97                              <1> 
    98                              <1> ; ------------
    99                              <1> ; println
   100                              <1> 
   101                              <1> %macro println_ax 0
   102                              <1>   print_ax
   103                              <1>   call write_5spaces_newline
   104                              <1> %endmacro
   105                              <1> 
   106                              <1> %macro println_ax_unsigned 0
   107                              <1>   print_ax_unsigned
   108                              <1>   call write_5spaces_newline
   109                              <1> %endmacro
   110                              <1> 
   111                              <1> %macro println_ax_hex 0
   112                              <1>   print_ax_hex
   113                              <1>   call write_5spaces_newline
   114                              <1> %endmacro
   115                              <1> 
   116                              <1> %macro println_ax_bin 0
   117                              <1>   print_ax_bin
   118                              <1>   call write_5spaces_newline
   119                              <1> %endmacro
   120                              <1> 
   121                              <1> write_5spaces_newline:
   122 00000007 50                  <1>   push ax
   123 00000008 B82020              <1>   mov ax,"  "
   124 0000000B E80B00              <1>   call write_2chars
   125 0000000E E80800              <1>   call write_2chars
   126 00000011 E8B701              <1>   call write_char
   127 00000014 E81503              <1>   call new_line
   128 00000017 58                  <1>   pop ax
   129 00000018 C3                  <1>   ret
   130                              <1> 
   131                              <1> write_2chars:
   132 00000019 E8AF01              <1>   call write_char
   133 0000001C 86C4                <1>   xchg ah,al
   134 0000001E E8AA01              <1>   call write_char
   135 00000021 C3                  <1>   ret
   136                              <1> 
   137                              <1> %macro register_interrupt 1
   138                              <1>   mov ax,%1
   139                              <1>   stosw
   140                              <1>   mov ax,cs
   141                              <1>   stosw
   142                              <1> %endmacro
   143                              <1> 
   144                              <1> ; int0: hlt
   145                              <1> ; int1: hlt
   146                              <1> ; int2: hlt
   147                              <1> ; int3: hlt
   148                              <1> ; int4: hlt
   149                              <1> 
   150                              <1> int0:; int0: Division by zero
   151 00000022 FC                  <1>   cld
   152 00000023 B800F4              <1>   mov ax,BLUE
   153 00000026 8EC0                <1>   mov es,ax
   154 00000028 31FF                <1>   xor di,di
   155 0000002A B9201C              <1>   mov cx,7200
   156 0000002D B8FFFF              <1>   mov ax,-1
   157 00000030 F3AB                <1>   rep stosw
   158                              <1>   set_cursor 1,1
    43                              <2> 
    44 00000032 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   159                              <1>   print "Division by zero"
    48 00000035 50                  <2>  push ax
    49 00000036 53                  <2>  push bx
    50 00000037 51                  <2>  push cx
    51 00000038 52                  <2>  push dx
    52 00000039 EB11                <2>  jmp %%endstr
    53 0000003B 4469766973696F6E20- <2>  %%str: db %1,0
    53 00000044 6279207A65726F00    <2>
    54                              <2>  %%endstr:
    55 0000004C BB[3B00]            <2>  mov bx,%%str
    56 0000004F E8B401              <2>  call write_string
    57 00000052 5A                  <2>  pop dx
    58 00000053 59                  <2>  pop cx
    59 00000054 5B                  <2>  pop bx
    60 00000055 58                  <2>  pop ax
   160                              <1>   set_cursor 3,1
    43                              <2> 
    44 00000056 BF8004              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   161 00000059 58                  <1>   pop ax
   162                              <1>   print "IP="
    48 0000005A 50                  <2>  push ax
    49 0000005B 53                  <2>  push bx
    50 0000005C 51                  <2>  push cx
    51 0000005D 52                  <2>  push dx
    52 0000005E EB04                <2>  jmp %%endstr
    53 00000060 49503D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000064 BB[6000]            <2>  mov bx,%%str
    56 00000067 E89C01              <2>  call write_string
    57 0000006A 5A                  <2>  pop dx
    58 0000006B 59                  <2>  pop cx
    59 0000006C 5B                  <2>  pop bx
    60 0000006D 58                  <2>  pop ax
   163                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 0000006E E8D802              <3>  call write_ax_hex
   113 00000071 E893FF              <2>  call write_5spaces_newline
   164 00000074 E8B502              <1>   call new_line
   165                              <1>   print "CS="
    48 00000077 50                  <2>  push ax
    49 00000078 53                  <2>  push bx
    50 00000079 51                  <2>  push cx
    51 0000007A 52                  <2>  push dx
    52 0000007B EB04                <2>  jmp %%endstr
    53 0000007D 43533D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000081 BB[7D00]            <2>  mov bx,%%str
    56 00000084 E87F01              <2>  call write_string
    57 00000087 5A                  <2>  pop dx
    58 00000088 59                  <2>  pop cx
    59 00000089 5B                  <2>  pop bx
    60 0000008A 58                  <2>  pop ax
   166 0000008B 58                  <1>   pop ax
   167                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 0000008C E8BA02              <3>  call write_ax_hex
   113 0000008F E875FF              <2>  call write_5spaces_newline
   168 00000092 E89702              <1>   call new_line
   169                              <1>   print "FLAGS="
    48 00000095 50                  <2>  push ax
    49 00000096 53                  <2>  push bx
    50 00000097 51                  <2>  push cx
    51 00000098 52                  <2>  push dx
    52 00000099 EB07                <2>  jmp %%endstr
    53 0000009B 464C4147533D00      <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000000A2 BB[9B00]            <2>  mov bx,%%str
    56 000000A5 E85E01              <2>  call write_string
    57 000000A8 5A                  <2>  pop dx
    58 000000A9 59                  <2>  pop cx
    59 000000AA 5B                  <2>  pop bx
    60 000000AB 58                  <2>  pop ax
   170 000000AC 58                  <1>   pop ax
   171 000000AD E87E01              <1>   call write_binary_word
   172 000000B0 F4                  <1>   hlt
   173                              <1> 
   174                              <1> int1:; int1: Single step debugging
   175 000000B1 B001                <1>   mov al,1
   176 000000B3 EB0C                <1>   jmp int_msg
   177                              <1> int2:; int2: Non maskable interrupt
   178 000000B5 B002                <1>   mov al,2
   179 000000B7 EB08                <1>   jmp int_msg
   180                              <1> int3:; int3: For one-byte interrupt
   181 000000B9 B003                <1>   mov al,3
   182 000000BB EB04                <1>   jmp int_msg
   183                              <1>   ; push ax
   184                              <1>   ; push bx
   185                              <1>   ; push cx
   186                              <1>   ; push dx
   187                              <1>   ; push si
   188                              <1>   ; push di
   189                              <1>   ; push bp
   190                              <1>   ; push ds
   191                              <1>   ; push es
   192                              <1> 
   193                              <1>   ; ; mov di,10*4
   194                              <1>   ; ; set_cursor 5,5
   195                              <1>   ; xor di,di
   196                              <1>   ; print "int3:"
   197                              <1>   ; ; mov ax,cx
   198                              <1>   ; ; call write_number_word
   199                              <1> 
   200                              <1>   ; pop es
   201                              <1>   ; pop ds
   202                              <1>   ; pop bp
   203                              <1>   ; pop di
   204                              <1>   ; pop si
   205                              <1>   ; pop dx
   206                              <1>   ; pop cx
   207                              <1>   ; pop bx
   208                              <1>   ; pop ax
   209                              <1>   ; iret
   210                              <1> 
   211                              <1> int4:; int4: Signed overflow
   212 000000BD B004                <1>   mov al,4
   213 000000BF EB00                <1>   jmp int_msg
   214                              <1> int_msg:
   215 000000C1 BFF401              <1>   mov di,500
   216                              <1>   ; xor di,di
   217                              <1>   ; mov ax,di
   218                              <1>   ; mov cx,8*72  
   219                              <1>   ; rep stosw
   220                              <1>   ; xor di,di
   221                              <1>   ; push ax
   222                              <1>   ; print "int: "
   223                              <1>   ; pop ax
   224 000000C4 0430                <1>   add al,'0'
   225 000000C6 E80201              <1>   call write_char
   226                              <1>   ; print "      "
   227                              <1>   
   228 000000C9 F4                  <1>   hlt
   229                              <1> 
   230                              <1> boot:
   231 000000CA FA                  <1>   cli
   232 000000CB FC                  <1>   cld
   233 000000CC E8E900              <1>   call clear_green    
   234                              <1> 
   235                              <1>   ; init video      
   236 000000CF B005                <1>   mov al, 5
   237 000000D1 E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
   238                              <1>  
   239                              <1>   ; register interrupts
   240 000000D3 31FF                <1>   xor di,di ; offset 0
   241 000000D5 8EC7                <1>   mov es,di ; segment 0
   242                              <1>   register_interrupt int0
   138 000000D7 B8[2200]            <2>  mov ax,%1
   139 000000DA AB                  <2>  stosw
   140 000000DB 8CC8                <2>  mov ax,cs
   141 000000DD AB                  <2>  stosw
   243                              <1>   register_interrupt int1
   138 000000DE B8[B100]            <2>  mov ax,%1
   139 000000E1 AB                  <2>  stosw
   140 000000E2 8CC8                <2>  mov ax,cs
   141 000000E4 AB                  <2>  stosw
   244                              <1>   register_interrupt int2
   138 000000E5 B8[B500]            <2>  mov ax,%1
   139 000000E8 AB                  <2>  stosw
   140 000000E9 8CC8                <2>  mov ax,cs
   141 000000EB AB                  <2>  stosw
   245                              <1>   register_interrupt int3
   138 000000EC B8[B900]            <2>  mov ax,%1
   139 000000EF AB                  <2>  stosw
   140 000000F0 8CC8                <2>  mov ax,cs
   141 000000F2 AB                  <2>  stosw
   246                              <1>   register_interrupt int4
   138 000000F3 B8[BD00]            <2>  mov ax,%1
   139 000000F6 AB                  <2>  stosw
   140 000000F7 8CC8                <2>  mov ax,cs
   141 000000F9 AB                  <2>  stosw
   247                              <1> 
   248                              <1> 
   249                              <1>   ; init other hardware
   250 000000FA B000                <1>   mov al,0
   251 000000FC E63A                <1>   out 0x3a,al           ; keyboard \force state/
   252 000000FE E63A                <1>   out 0x3a,al           ; keyboard \force state/
   253 00000100 B0FF                <1>   mov al,0xFF
   254 00000102 E63A                <1>   out 0x3a,al           ; keyboard \reset/
   255 00000104 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   256 00000106 B037                <1>   mov al,0x37
   257 00000108 E63A                <1>   out 0x3a,al           ; keyboard \set command
   258                              <1> 
   259 0000010A B8001C              <1>   mov ax,GREEN      
   260 0000010D 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   261 0000010F B83800              <1>   mov ax,DST                
   262 00000112 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   263 00000114 BF0000              <1>   mov di,0                  ;
   264 00000117 B200                <1>   mov dl,0                  ; track=0
   265 00000119 B601                <1>   mov dh,1                  ; sector=1
   266 0000011B B95000              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   267 0000011E EB0B                <1>   jmp move_head
   268                              <1> 
   269                              <1> ; ───────────────────────────────────────────────────────────────────────────
   270                              <1> 
   271                              <1> next_sector:
   272 00000120 FEC6                <1>   inc dh                    ; sector++
   273 00000122 80FE0A              <1>   cmp dh,10
   274 00000125 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   275 00000127 B601                <1>   mov dh,1
   276 00000129 FEC2                <1>   inc dl                    ; else track++ ; sector=1
   277                              <1> 
   278                              <1> move_head:
   279 0000012B 88D0                <1>   mov al,dl
   280 0000012D E60E                <1>   out 0Eh,al               ; set track number
   281 0000012F B018                <1>   mov al,18h     
   282 00000131 E608                <1>   out 8,al                 ; seek track, load head
   283 00000133 B000                <1>   mov al,0
   284 00000135 E61C                <1>   out 1Ch,al               ; set desired drive/side
   285 00000137 D40A                <1>   aam
   286                              <1> 
   287                              <1> head_moving:
   288 00000139 E408                <1>   in al,8
   289 0000013B A801                <1>   test al,1
   290 0000013D 75FA                <1>   jnz head_moving
   291                              <1> 
   292                              <1> read_sector:
   293 0000013F 88F0                <1>   mov al,dh
   294 00000141 E60C                <1>   out 0Ch,al                ; sector number
   295 00000143 B702                <1>   mov bh,2                  ; 00000010b
   296 00000145 B396                <1>   mov bl,96h                ; 10010110b
   297 00000147 B400                <1>   mov ah,0
   298 00000149 B080                <1>   mov al,80h
   299 0000014B E608                <1>   out 8,al                  ; read sector
   300 0000014D D40A<rep 4h>        <1>   times 4 aam               ; wait
   301                              <1> 
   302                              <1> check_status_1:
   303 00000155 E408                <1>   in al,8                   ; read status
   304 00000157 D0F8                <1>   sar al,1                  ; status/=2
   305 00000159 731F                <1>   jnb check_status_3
   306 0000015B 75F8                <1>   jnz check_status_1
   307                              <1> 
   308                              <1> wait_for_data:
   309 0000015D E408                <1>   in al,8                   ; read status
   310 0000015F 20D8                <1>   and al,bl                 ; 96h
   311 00000161 74FA                <1>   jz wait_for_data
   312                              <1> 
   313                              <1> store_byte_1:
   314 00000163 E40E                <1>   in al,0Eh
   315 00000165 AA                  <1>   stosb
   316                              <1> 
   317                              <1> check_status_2:
   318 00000166 E408                <1>   in al,8                   ; read status
   319 00000168 48                  <1>   dec ax                    ; status--
   320 00000169 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   321 0000016B 38F8                <1>   cmp al, bh                ; bh=2
   322 0000016D 750B                <1>   jnz check_status_3        ; if (status==1) 
   323                              <1> 
   324                              <1> store_byte_2:
   325 0000016F E40E                <1>   in al,0Eh  
   326 00000171 AA                  <1>   stosb
   327                              <1> 
   328                              <1> check_status_4:
   329 00000172 E408                <1>   in al,8                   ; read status
   330 00000174 38F8                <1>   cmp al, bh                ; bh=2
   331 00000176 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   332 00000178 EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   333                              <1> 
   334                              <1> ; ───────────────────────────────────────────────────────────────────────────
   335                              <1> 
   336                              <1> check_status_3:
   337 0000017A E408                <1>   in al, 8                  ; read status
   338 0000017C A81C                <1>   test al, 1Ch              ; 00011100
   339 0000017E 7402                <1>   jz while_sectors
   340 00000180 EBBD                <1>   jmp read_sector
   341                              <1> 
   342                              <1> ; ───────────────────────────────────────────────────────────────────────────
   343                              <1> 
   344                              <1> while_sectors:
   345 00000182 E81200              <1>   call progress_bar
   346 00000185 E299                <1>   loop next_sector
   347                              <1> 
   348                              <1> done_reading:
   349 00000187 0E                  <1>   push cs
   350 00000188 17                  <1>   pop ss
   351 00000189 BC0000              <1>   mov sp,0
   352 0000018C E82900              <1>   call clear_green
   353 0000018F 0E                  <1>   push cs
   354 00000190 1F                  <1>   pop ds
   355                              <1>   set_cursor 1,1 ; nodig?
    43                              <2> 
    44 00000191 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   356 00000194 E90B09              <1>   jmp setup
   357                              <1> 
   358                              <1> ; ───────────────────────────────────────────────────────────────────────────
   359                              <1> 
   360                              <1> progress_bar:
   361                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   362 00000197 52                  <1>   push dx
   363 00000198 53                  <1>   push bx
   364 00000199 31D2                <1>   xor dx,dx
   365 0000019B B81E00              <1>   mov ax,BAR_WIDTH
   366 0000019E BB5000              <1>   mov bx,NUM_SECTORS    
   367 000001A1 F7E1                <1>   mul cx
   368 000001A3 F7F3                <1>   div bx
   369 000001A5 5B                  <1>   pop bx
   370 000001A6 5A                  <1>   pop dx
   371 000001A7 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   372 000001A9 D1E6                <1>   shl si,1                  ; *=2
   373 000001AB D1E6                <1>   shl si,1                  ; *=2  
   374 000001AD BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   375 000001B0 29F5                <1>   sub bp,si
   376 000001B2 3EC64600FF          <1>   mov byte [ds:bp],-1
   377 000001B7 C3                  <1>   ret
   378                              <1> 
   379                              <1> ; clear_red:
   380                              <1> ;   mov ax,RED
   381                              <1> ;   call clear_channel
   382                              <1> ;   ret
   383                              <1> 
   384                              <1> clear_green:
   385 000001B8 B8001C              <1>   mov ax,GREEN
   386 000001BB E80100              <1>   call clear_channel
   387 000001BE C3                  <1>   ret
   388                              <1> 
   389                              <1> ; clear_blue:
   390                              <1> ;   mov ax,BLUE
   391                              <1> ;   call clear_channel
   392                              <1> ;   ret
   393                              <1> 
   394                              <1> ; clear_screen:
   395                              <1> ;   call clear_red
   396                              <1> ;   call clear_green
   397                              <1> ;   call clear_blue
   398                              <1> ;   ret
   399                              <1> 
   400                              <1> clear_channel:
   401 000001BF 8EC0                <1>   mov es,ax
   402 000001C1 B9201C              <1>   mov cx,COLS*ROWS*2
   403 000001C4 31FF                <1>   xor di,di
   404 000001C6 31C0                <1>   xor ax,ax
   405 000001C8 F3AB                <1>   rep stosw         ; clear screen
   406 000001CA C3                  <1>   ret
   407                              <1> 
   408                              <1> ; ───────────────────────────────────────────────────────────────────────────
   409                              <1> 
   410                              <1> ; write_char:   ; ds=FONT, es=GREEN, al=charcode
   411                              <1> ;   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   412                              <1> ;   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   413                              <1> ;   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   414                              <1> 
   415                              <1> ;   push ds
   416                              <1> ;   push es
   417                              <1> ;   push ax
   418                              <1> ;   push bx
   419                              <1> ;   push cx
   420                              <1> 
   421                              <1> ;   push ax
   422                              <1> ;   mov ax,GREEN
   423                              <1> ;   mov es,ax
   424                              <1> ;   mov ax,FONT
   425                              <1> ;   mov ds,ax
   426                              <1> ;   pop ax
   427                              <1> 
   428                              <1> ;   ; mov ax,65*8
   429                              <1> ;   ; mov al,'x'
   430                              <1> ;   mov ah,8
   431                              <1> ;   mul ah        ; ax=al*ah
   432                              <1> 
   433                              <1> ;   mov si,ax
   434                              <1> ;   movsw
   435                              <1> ;   movsw
   436                              <1> ;   add di,0x11c
   437                              <1> ;   movsw
   438                              <1> ;   movsw
   439                              <1> ;   mov bx,288
   440                              <1> ;   sub di,bx
   441                              <1>   
   442                              <1> ;   ; pop ax
   443                              <1> ;   ; pop es
   444                              <1> ;   ; pop ds
   445                              <1> ;   ; ret
   446                              <1> 
   447                              <1> 
   448                              <1> ;   ; row snap
   449                              <1> ;   xor dx,dx
   450                              <1> ;   mov ax,di
   451                              <1> ;   div bx
   452                              <1> ;   cmp dx,0
   453                              <1> ;   jne .return
   454                              <1> ;   add di,bx
   455                              <1> 
   456                              <1> 
   457                              <1> ;   ; wrap to top
   458                              <1> ;   cmp di,14400   ; dit later oplossen met cursor positie
   459                              <1> ;   jb .return
   460                              <1> ;   ; xor di,di      ; move to left top. change later to scroll
   461                              <1> 
   462                              <1> ;   ; TODO: call scroll_down
   463                              <1> ;   ; std
   464                              <1> ;   ; push di
   465                              <1> ;   ; push cx
   466                              <1> ;   ; mov cx,4*72*24
   467                              <1> ;   ; mov ax,0
   468                              <1> ;   ; rep stosw
   469                              <1> ;   ; pop cx
   470                              <1> ;   ; pop di
   471                              <1> ;   ; cld
   472                              <1> 
   473                              <1> ;   ; DONE: clear last line
   474                              <1> ;   sub di,bx
   475                              <1> ;   sub di,bx
   476                              <1> ;   push di
   477                              <1> ;   push cx
   478                              <1> ;   mov cx,COLS*ROWS*2
   479                              <1> ;   xor ax,ax
   480                              <1> ;   rep stosw         ; clear screen
   481                              <1> ;   pop cx
   482                              <1> ;   pop di
   483                              <1> 
   484                              <1> ; .return
   485                              <1> ;   push bx
   486                              <1> ;   push cx
   487                              <1> ;   pop ax
   488                              <1> ;   pop es
   489                              <1> ;   pop ds
   490                              <1> ;   ret
   491                              <1> 
   492                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   493                              <1> 
   494                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   495 000001CB 52                  <1>   push dx
   496 000001CC 1E                  <1>   push ds
   497 000001CD 06                  <1>   push es
   498 000001CE 50                  <1>   push ax
   499 000001CF 53                  <1>   push bx
   500 000001D0 31D2                <1>   xor dx,dx
   501 000001D2 50                  <1>   push ax  ; voor character pop
   502 000001D3 B8001C              <1>   mov ax,GREEN
   503 000001D6 8EC0                <1>   mov es,ax
   504 000001D8 B800FF              <1>   mov ax,FONT
   505 000001DB 8ED8                <1>   mov ds,ax
   506 000001DD 58                  <1>   pop ax
   507 000001DE B408                <1>   mov ah,8
   508 000001E0 F6E4                <1>   mul ah        ; al*=ah
   509 000001E2 89C6                <1>   mov si,ax  
   510                              <1> 
   511 000001E4 A5                  <1>   movsw
   512 000001E5 A5                  <1>   movsw
   513 000001E6 81C71C01            <1>   add di,0x11c
   514 000001EA A5                  <1>   movsw
   515 000001EB A5                  <1>   movsw
   516 000001EC 81EF2001            <1>   sub di,0x120
   517                              <1> 
   518                              <1> 
   519                              <1>   ; cmp di,14400   ; dit later oplossen met cursor positie
   520                              <1>   ; jb .return
   521                              <1>   ; xor di,di      ; move to left top. change later to scroll
   522                              <1> 
   523                              <1>   ; row snap
   524 000001F0 BB2001              <1>   mov bx,288   ; /////////// dit gaf problemen waarsch omdat bx niet gepushed werd
   525 000001F3 31D2                <1>   xor dx,dx
   526 000001F5 89F8                <1>   mov ax,di
   527 000001F7 F7F3                <1>   div bx       ; ///dit ook als BX 0 is
   528 000001F9 83FA00              <1>   cmp dx,0
   529 000001FC 7502                <1>   jne .return
   530 000001FE 01DF                <1>   add di,bx
   531                              <1> 
   532                              <1> .return
   533 00000200 5B                  <1>   pop bx
   534 00000201 58                  <1>   pop ax
   535 00000202 07                  <1>   pop es
   536 00000203 1F                  <1>   pop ds
   537 00000204 5A                  <1>   pop dx
   538 00000205 C3                  <1>   ret
   539                              <1> 
   540                              <1> write_string:
   541 00000206 2E8A07              <1>   mov al,[cs:bx]
   542 00000209 43                  <1>   inc bx
   543 0000020A 08C0                <1>   or al,al
   544 0000020C 7405                <1>   jz .return
   545 0000020E E8BAFF              <1>   call write_char
   546 00000211 EBF3                <1>   jmp short write_string
   547                              <1> .return
   548 00000213 C3                  <1>   ret
   549                              <1> 
   550                              <1> ; ───────────────────────────────────────────────────────────────────────────
   551                              <1> 
   552                              <1> write_binary_byte:    ; input AL
   553 00000214 53                  <1>   push bx
   554 00000215 51                  <1>   push cx
   555 00000216 50                  <1>   push ax
   556 00000217 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   557 00000219 B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   558                              <1> .lp:
   559 0000021C D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   560 0000021E B80000              <1>   mov ax, 0           ; AH leegmaken
   561 00000221 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   562 00000223 51                  <1>   push cx             ; CX opslaan
   563 00000224 E8A4FF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   564 00000227 59                  <1>   pop cx              ; CX herstellen
   565 00000228 E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   566 0000022A 58                  <1>   pop ax
   567 0000022B 59                  <1>   pop cx
   568 0000022C 5B                  <1>   pop bx
   569 0000022D C3                  <1>   ret
   570                              <1> 
   571                              <1> ; ───────────────────────────────────────────────────────────────────────────
   572                              <1> 
   573                              <1> write_binary_word:    ; input AX
   574 0000022E 51                  <1>   push cx
   575 0000022F 50                  <1>   push ax
   576 00000230 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   577 00000231 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   578 00000233 B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   579                              <1> .lp:
   580 00000236 D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   581 00000238 B80000              <1>   mov ax, 0          ; AH leegmaken
   582 0000023B 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   583 0000023D 51                  <1>   push cx            ; CX opslaan
   584 0000023E E88AFF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   585 00000241 59                  <1>   pop cx             ; CX herstellen
   586 00000242 E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   587 00000244 5A                  <1>   pop dx             ; DX herstellen
   588 00000245 58                  <1>   pop ax
   589 00000246 59                  <1>   pop cx
   590 00000247 C3                  <1>   ret
   591                              <1> 
   592                              <1> 
   593                              <1> ; ───────────────────────────────────────────────────────────────────────────
   594                              <1> 
   595                              <1> write_number_word:
   596 00000248 50                  <1>     push ax
   597 00000249 52                  <1>     push dx
   598 0000024A 31D2                <1>     xor dx,dx
   599 0000024C 52                  <1>     push dx ;high byte is zero
   600 0000024D 31D2                <1> .clp xor dx,dx
   601 0000024F 2EF736[6B02]        <1>     cs div word [.base]
   602 00000254 92                  <1>     xchg ax,dx
   603 00000255 05300E              <1>     add ax,0xe30
   604 00000258 50                  <1>     push ax
   605 00000259 92                  <1>     xchg ax,dx
   606 0000025A 09C0                <1>     or ax,ax
   607 0000025C 75EF                <1>     jnz .clp
   608 0000025E 58                  <1> .dlp pop ax
   609 0000025F 08E4                <1>     or ah,ah
   610 00000261 7405                <1>     jz .done
   611 00000263 E865FF              <1>     call write_char
   612 00000266 EBF6                <1>     jmp short .dlp
   613 00000268 5A                  <1> .done pop dx
   614 00000269 58                  <1>     pop ax
   615 0000026A C3                  <1>     ret
   616 0000026B 0A00                <1> .base dw 10
   617                              <1> 
   618                              <1> ; ───────────────────────────────────────────────────────────────────────────
   619                              <1> 
   620                              <1> write_number_dword:
   621                              <1>     ;https://stackoverflow.com/questions/45904075/displaying-numbers-with-dos/45904076#45904076
   622 0000026D 50                  <1>     push ax          ;me
   623 0000026E 53                  <1>     push bx          ;me
   624 0000026F 51                  <1>     push cx          ;me
   625 00000270 52                  <1>     push dx          ;me
   626                              <1> 
   627 00000271 BB0A00              <1>     mov     bx,10          ;CONST
   628 00000274 53                  <1>     push    bx             ;Sentinel
   629 00000275 89C1                <1> .a: mov     cx,ax          ;Temporarily store LowDividend in CX
   630 00000277 89D0                <1>     mov     ax,dx          ;First divide the HighDividend
   631 00000279 31D2                <1>     xor     dx,dx          ;Setup for division DX:AX / BX
   632 0000027B F7F3                <1>     div     bx             ; -> AX is HighQuotient, Remainder is re-used
   633 0000027D 91                  <1>     xchg    ax,cx          ;Temporarily move it to CX restoring LowDividend
   634 0000027E F7F3                <1>     div     bx             ; -> AX is LowQuotient, Remainder DX=[0,9]
   635 00000280 52                  <1>     push    dx             ;(1) Save remainder for now
   636 00000281 89CA                <1>     mov     dx,cx          ;Build true 32-bit quotient in DX:AX
   637 00000283 09C1                <1>     or      cx,ax          ;Is the true 32-bit quotient zero?
   638 00000285 75EE                <1>     jnz     .a             ;No, use as next dividend
   639 00000287 5A                  <1>     pop     dx             ;(1a) First pop (Is digit for sure)
   640 00000288 80C230              <1> .b: add     dl,"0"         ;Turn into character [0,9] -> ["0","9"]
   641                              <1>     
   642 0000028B 86D0                <1>     xchg    al,dl        ;me
   643 0000028D E83BFF              <1>     call    write_char   ;me
   644 00000290 86D0                <1>     xchg    al,dl        ;me
   645                              <1>     
   646 00000292 5A                  <1>     pop     dx             ;(1b) All remaining pops
   647 00000293 39DA                <1>     cmp     dx,bx          ;Was it the sentinel?
   648 00000295 72F1                <1>     jb      .b             ;Not yet
   649                              <1> 
   650 00000297 5A                  <1>     pop dx         ;me
   651 00000298 59                  <1>     pop cx         ;me
   652 00000299 5B                  <1>     pop bx         ;me
   653 0000029A 58                  <1>     pop ax         ;me
   654 0000029B C3                  <1>     ret
   655                              <1> 
   656                              <1> 
   657                              <1> ; ───────────────────────────────────────────────────────────────────────────
   658                              <1> 
   659                              <1> write_signed_number_word:  
   660 0000029C 50                  <1>     push ax
   661 0000029D 09C0                <1>     or ax,ax
   662 0000029F 790A                <1>     jns .write_return        ; if >0 write and return
   663 000002A1 50                  <1>     push ax
   664 000002A2 B82D00              <1>     mov ax,'-'
   665 000002A5 E823FF              <1>     call write_char
   666 000002A8 58                  <1>     pop ax
   667 000002A9 F7D8                <1>     neg ax                   ; destroys ax when negative
   668                              <1> .write_return:
   669 000002AB E89AFF              <1>     call write_number_word
   670 000002AE 58                  <1>     pop ax
   671 000002AF C3                  <1>     ret
   672                              <1> 
   673                              <1> ; ───────────────────────────────────────────────────────────────────────────
   674                              <1> 
   675                              <1> check_keys:
   676 000002B0 E43A                <1>   in al,0x3a        ; get keyboard status
   677 000002B2 88C4                <1>   mov ah,al
   678 000002B4 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   679 000002B6 2EA2[0600]          <1>   mov [cs:key.ctrl],al
   680 000002BA F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   681 000002BD 7410                <1>   jz .return
   682 000002BF E438                <1>   in al,0x38        ; get data byte from keyboard  
   683 000002C1 2EA2[0500]          <1>   mov [cs:key.code],al
   684 000002C5 B037                <1>   mov al,0x37
   685 000002C7 E63A                <1>   out 0x3a,al       ; drop key?  
   686 000002C9 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   687 000002CB 2EA1[0500]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   688 000002CF C3                  <1> .return ret
   689                              <1> 
   690                              <1> 
   691                              <1> 
   692                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   693                              <1> ;   ret
   694                              <1> 
   695                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   696                              <1> 
   697                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   698                              <1> ; much faster and simpler on the grid than off the grid
   699                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   700                              <1> 
   701                              <1> 
   702                              <1> ; wide font by stretching the font horizontally using bitshift
   703                              <1> 
   704                              <1> 
   705                              <1> ; fill_white:
   706                              <1> ;   mov ax,0xffff
   707                              <1> ;   call fill_red
   708                              <1> ;   call fill_green
   709                              <1> ;   call fill_blue
   710                              <1> ;   ret
   711                              <1> 
   712                              <1> ; fill_pink:
   713                              <1> ;   mov ax,0xffff
   714                              <1> ;   call fill_red
   715                              <1> ;   mov ah,0b01010101
   716                              <1> ;   mov al,0b10101010
   717                              <1> ;   call fill_green
   718                              <1> ;   call fill_blue
   719                              <1> ;   ret
   720                              <1> 
   721                              <1> ; fill_pink2:
   722                              <1> ;   mov ax,0xffff
   723                              <1> ;   call fill_red
   724                              <1> ;   mov ah,0b11001100
   725                              <1> ;   mov al,0b00110011
   726                              <1> ;   call fill_green
   727                              <1> ;   call fill_blue
   728                              <1> ;   ret
   729                              <1> 
   730                              <1> ; fill_pink3:
   731                              <1> ;   mov ax,0xffff
   732                              <1> ;   call fill_red
   733                              <1> ;   mov ah,0b00010001
   734                              <1> ;   mov al,0b01000100
   735                              <1> ;   call fill_green
   736                              <1> ;   call fill_blue
   737                              <1> ;   ret
   738                              <1> 
   739                              <1> ; fill_pink4:
   740                              <1> ;   mov ax,0xffff
   741                              <1> ;   call fill_red
   742                              <1> ;   mov ah,0b11110111
   743                              <1> ;   mov al,0b01111111
   744                              <1> ;   call fill_green
   745                              <1> ;   call fill_blue
   746                              <1> ;   ret
   747                              <1> 
   748                              <1> ; fill_red:
   749                              <1> ;   mov bx,RED
   750                              <1> ;   call fill_channel
   751                              <1> ;   ret
   752                              <1> ; fill_green:
   753                              <1> ;   mov bx,GREEN
   754                              <1> ;   call fill_channel
   755                              <1> ;   ret
   756                              <1> ; fill_blue:
   757                              <1> ;   mov bx,BLUE
   758                              <1> ;   call fill_channel
   759                              <1> ;   ret
   760                              <1> 
   761                              <1> ; fill_channel: ;ax=pattern
   762                              <1> ;   mov es,bx
   763                              <1> ;   mov cx,COLS*ROWS*2
   764                              <1> ;   xor di,di
   765                              <1> ;   rep stosw
   766                              <1> ;   ret
   767                              <1> 
   768                              <1> ; ───────────────────────────────────────────────────────────────────────────
   769                              <1> 
   770                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   771                              <1> ;   push bx
   772                              <1> ;   push di
   773                              <1> ;   mov es,ax
   774                              <1> ;   xor cx,cx
   775                              <1> ;   mov cl,bh        ; rows (bl)
   776                              <1> ; .rows_loop:
   777                              <1> ;   push cx
   778                              <1> ;   xor cx,cx
   779                              <1> ;   mov cl,bl        ; cols (bh)
   780                              <1> ; .cols_loop:
   781                              <1> ;   mov ax,0
   782                              <1> ;   stosw
   783                              <1> ;   stosw
   784                              <1> ;   loop .cols_loop
   785                              <1> ;   add di,COLS*4    ; one row down
   786                              <1> ;   mov ah,0
   787                              <1> ;   mov al,bl
   788                              <1> ;   times 2 shl ax,1
   789                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   790                              <1> ;   pop cx
   791                              <1> ;   loop .rows_loop
   792                              <1> ;   pop di
   793                              <1> ;   pop bx
   794                              <1> ;   ret
   795                              <1> 
   796                              <1> ; ───────────────────────────────────────────────────────────────────────────
   797                              <1> 
   798                              <1> ; fill_rect_black: 
   799                              <1> ;   mov ax,RED
   800                              <1> ;   call clear_area
   801                              <1> ;   mov ax,GREEN
   802                              <1> ;   call clear_area
   803                              <1> ;   mov ax,BLUE
   804                              <1> ;   call clear_area
   805                              <1> ;   ret
   806                              <1> 
   807                              <1> ; ───────────────────────────────────────────────────────────────────────────
   808                              <1> 
   809                              <1> draw_spr:
   810 000002D0 53                  <1>   push bx
   811 000002D1 8B1C                <1>   mov bx,[si]
   812 000002D3 46                  <1>   inc si
   813 000002D4 46                  <1>   inc si
   814 000002D5 E80200              <1>   call draw_pic
   815 000002D8 5B                  <1>   pop bx
   816 000002D9 C3                  <1>   ret
   817                              <1> 
   818                              <1> draw_pic:
   819 000002DA 50                  <1>   push ax
   820 000002DB B800F0              <1>   mov ax, RED
   821 000002DE E80E00              <1>   call draw_channel
   822 000002E1 B8001C              <1>   mov ax, GREEN
   823 000002E4 E80800              <1>   call draw_channel
   824 000002E7 B800F4              <1>   mov ax, BLUE
   825 000002EA E80200              <1>   call draw_channel
   826 000002ED 58                  <1>   pop ax
   827 000002EE C3                  <1>   ret
   828                              <1> 
   829                              <1> ; ───────────────────────────────────────────────────────────────────────────
   830                              <1> 
   831                              <1> draw_channel:
   832 000002EF 57                  <1>   push di
   833 000002F0 8EC0                <1>   mov es,ax
   834 000002F2 31C9                <1>   xor cx,cx
   835 000002F4 88F9                <1>   mov cl,bh        ; rows (bl)
   836                              <1> .rows_loop:
   837 000002F6 51                  <1>   push cx
   838 000002F7 31C9                <1>   xor cx,cx
   839 000002F9 88D9                <1>   mov cl,bl        ; cols (bh)
   840                              <1> .cols_loop:
   841 000002FB A5                  <1>   movsw
   842 000002FC A5                  <1>   movsw
   843 000002FD E2FC                <1>   loop .cols_loop
   844 000002FF 81C72001            <1>   add di,COLS*4    ; one row down
   845 00000303 B400                <1>   mov ah,0
   846 00000305 88D8                <1>   mov al,bl
   847 00000307 D1E0<rep 2h>        <1>   times 2 shl ax,1
   848 0000030B 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   849 0000030D 59                  <1>   pop cx
   850 0000030E E2E6                <1>   loop .rows_loop
   851 00000310 5F                  <1>   pop di
   852 00000311 C3                  <1>   ret
   853                              <1> 
   854                              <1> ; ───────────────────────────────────────────────────────────────────────────
   855                              <1> 
   856                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   857 00000312 B89000              <1>   mov ax,144      ; 2*72 cols
   858 00000315 F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   859 00000317 D1E0                <1>   shl ax,1        ; verdubbel AX
   860 00000319 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   861 0000031B D0E3                <1>   shl bl,1        ; bl*=2
   862 0000031D D0E3                <1>   shl bl,1        ; bl*=2
   863 0000031F B700                <1>   mov bh,0
   864 00000321 01DF                <1>   add di,bx       ; di+=bl
   865 00000323 83FF00              <1>   cmp di,0
   866 00000326 7C01                <1>   jl .clamp_top
   867 00000328 C3                  <1>   ret
   868                              <1> .clamp_top
   869 00000329 31FF                <1>   xor di,di
   870 0000032B C3                  <1>   ret
   871                              <1> 
   872                              <1> 
   873                              <1> ; ───────────────────────────────────────────────────────────────────────────
   874                              <1> 
   875                              <1> new_line:         ; find the value of DI at start of the next line
   876 0000032C 50                  <1>   push ax
   877 0000032D 53                  <1>   push bx
   878 0000032E 52                  <1>   push dx
   879 0000032F BB2001              <1>   mov bx,288
   880 00000332 31D2                <1>   xor dx,dx
   881 00000334 89F8                <1>   mov ax,di
   882 00000336 F7F3                <1>   div bx
   883 00000338 31D2                <1>   xor dx,dx       ; cwd?
   884 0000033A BB2001              <1>   mov bx,288      ; can reuse x from above?
   885 0000033D 40                  <1>   inc ax
   886 0000033E F7E3                <1>   mul bx
   887 00000340 052001              <1>   add ax,288      ; use bx?
   888 00000343 89C7                <1>   mov di,ax
   889 00000345 5A                  <1>   pop dx
   890 00000346 5B                  <1>   pop bx
   891 00000347 58                  <1>   pop ax
   892 00000348 C3                  <1>   ret
   893                              <1> 
   894                              <1> ; ───────────────────────────────────────────────────────────────────────────
   895                              <1> 
   896                              <1> write_ax_hex:
   897 00000349 50                  <1>   push ax
   898 0000034A 52                  <1>   push dx
   899 0000034B 31D2                <1>   xor dx,dx
   900 0000034D 52                  <1>   push dx ;high byte is zero
   901 0000034E 31D2                <1> .clp xor dx,dx
   902 00000350 2EF736[7203]        <1>   cs div word [.base]
   903 00000355 92                  <1>   xchg ax,dx
   904 00000356 3C0A                <1>   cmp al,10
   905 00000358 7202                <1>   jb .l1     ; 0-9
   906 0000035A 0407                <1>   add al,7   ; A-F
   907 0000035C 05300E              <1> .l1 add ax,0xe30
   908 0000035F 50                  <1>   push ax
   909 00000360 92                  <1>   xchg ax,dx
   910 00000361 09C0                <1>   or ax,ax
   911 00000363 75E9                <1>   jnz .clp
   912 00000365 58                  <1> .dlp pop ax
   913 00000366 08E4                <1>   or ah,ah
   914 00000368 7405                <1>   jz .done
   915 0000036A E85EFE              <1>   call write_char
   916 0000036D EBF6                <1>   jmp short .dlp
   917 0000036F 5A                  <1> .done pop dx
   918 00000370 58                  <1>   pop ax
   919 00000371 C3                  <1>   ret
   920 00000372 1000                <1> .base dw 16
   921                              <1> 
   922                              <1> ; calc_di_from_cursor:  ; input cursor, output di
   923                              <1> ;   mov ax,[cursor] 
   924                              <1> ;   sub ax,0x0101   ; cursor is 1 based
   925                              <1> ;   xchg ax,bx      ; bx=ax
   926                              <1> ;   mov ax,144      ; 2*72 cols
   927                              <1> ;   mul bh          ; bh*=144 resultaat in AX
   928                              <1> ;   shl ax,1        ; verdubbel AX
   929                              <1> ;   shl ax,1        ; verdubbel AX
   930                              <1> ;   mov di,ax       ; di=ax (=bh*288)
   931                              <1> ;   shl bl,1        ; bl*=2
   932                              <1> ;   shl bl,1        ; bl*=2
   933                              <1> ;   mov bh,0
   934                              <1> ;   add di,bx       ; di+=bl
   935                              <1> ;   ret
   936                              <1> 
   937                              <1> 
   938                              <1> 
   939                              <1> 
   940                              <1> ; als je cursor gebruikt is dit missch niet nodig.
   941                              <1> ; row_snap:  ; this code detects if DI is in between rows. When DI goes to the next half row it converts it to a whole row.
   942                              <1> ;   push ax
   943                              <1> ;   push bx
   944                              <1> ;   push dx
   945                              <1> ;   mov bx,288
   946                              <1> ;   mov ax,di
   947                              <1> ;   cwd ; xor dx,dx
   948                              <1> ;   div bx
   949                              <1> ;   jnp .done  ; if ax%288==0 
   950                              <1> ;   add di,bx
   951                              <1> ;   .done
   952                              <1> ;   ; add di,dx
   953                              <1> ;   pop dx
   954                              <1> ;   pop bx
   955                              <1> ;   pop ax
   956                              <1> ;   ret
   957                              <1> 
   958                              <1> 
   959                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   960                              <1> 
   961                              <1> ; calc_di_from_cursor_index:  ; index is cursor index from 0 tot 72*25
   962                              <1> ;   push ax
   963                              <1> ;   push bx
   964                              <1> ;   push dx
   965                              <1> ;   xor dx,dx
   966                              <1> ;   mov ax,[cursor.index]
   967                              <1> ;   mov bx,72
   968                              <1> ;   div bx       ; ax=rows
   969                              <1> ;   push dx      ; dx=cols
   970                              <1> ;   xor dx,dx    ; clear dx for multiplication
   971                              <1> ;   mov bx,576
   972                              <1> ;   mul bx       ; ax contains DI position for row
   973                              <1> ;   mov di,ax
   974                              <1> ;   pop ax       ; ax now contains cols
   975                              <1> ;   shl ax,1     ; *=2
   976                              <1> ;   shl ax,1     ; *=2
   977                              <1> ;   add di,ax
   978                              <1> ;   pop dx
   979                              <1> ;   pop bx
   980                              <1> ;   pop ax
   981                              <1> ;   ret
   982                              <1> 
   983                              <1> ; ───────────────────────────────────────────────────────────────────────────
   984                              <1> 
   985                              <1> 
   986                              <1> ; set_cursor:
   987                              <1> ; cursor_next_char
   988                              <1> 
   989                              <1> 
   990                              <1> 
   991                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   992                              <1> 
     2                                  %include "debug.asm"
     1                              <1> 
     2                              <1> draw_debug_info:
     3                              <1>   
     4                              <1>   set_cursor 1,1
    43                              <2> 
    44 00000374 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
     5                              <1> 
     6                              <1>   print "key: "
    48 00000377 50                  <2>  push ax
    49 00000378 53                  <2>  push bx
    50 00000379 51                  <2>  push cx
    51 0000037A 52                  <2>  push dx
    52 0000037B EB06                <2>  jmp %%endstr
    53 0000037D 6B65793A2000        <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000383 BB[7D03]            <2>  mov bx,%%str
    56 00000386 E87DFE              <2>  call write_string
    57 00000389 5A                  <2>  pop dx
    58 0000038A 59                  <2>  pop cx
    59 0000038B 5B                  <2>  pop bx
    60 0000038C 58                  <2>  pop ax
     7 0000038D A1[0500]            <1>   mov ax,[key]
     8                              <1>   println_ax_bin
   117                              <2>  print_ax_bin
    81 00000390 E89BFE              <3>  call write_binary_word
   118 00000393 E871FC              <2>  call write_5spaces_newline
     9                              <1> 
    10                              <1>   print "frame: "
    48 00000396 50                  <2>  push ax
    49 00000397 53                  <2>  push bx
    50 00000398 51                  <2>  push cx
    51 00000399 52                  <2>  push dx
    52 0000039A EB08                <2>  jmp %%endstr
    53 0000039C 6672616D653A2000    <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003A4 BB[9C03]            <2>  mov bx,%%str
    56 000003A7 E85CFE              <2>  call write_string
    57 000003AA 5A                  <2>  pop dx
    58 000003AB 59                  <2>  pop cx
    59 000003AC 5B                  <2>  pop bx
    60 000003AD 58                  <2>  pop ax
    11 000003AE A1[6209]            <1>   mov ax,[frame_count]
    12                              <1>   println_ax
   102                              <2>  print_ax
    69 000003B1 E8E8FE              <3>  call write_signed_number_word
   103 000003B4 E850FC              <2>  call write_5spaces_newline
    13                              <1> 
    14                              <1>   print "x+: "
    48 000003B7 50                  <2>  push ax
    49 000003B8 53                  <2>  push bx
    50 000003B9 51                  <2>  push cx
    51 000003BA 52                  <2>  push dx
    52 000003BB EB05                <2>  jmp %%endstr
    53 000003BD 782B3A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003C2 BB[BD03]            <2>  mov bx,%%str
    56 000003C5 E83EFE              <2>  call write_string
    57 000003C8 5A                  <2>  pop dx
    58 000003C9 59                  <2>  pop cx
    59 000003CA 5B                  <2>  pop bx
    60 000003CB 58                  <2>  pop ax
    15 000003CC A1[3609]            <1>   mov ax,[ship.pos.x]  
    16                              <1>   println_ax_unsigned
   107                              <2>  print_ax_unsigned
    73 000003CF E876FE              <3>  call write_number_word
   108 000003D2 E832FC              <2>  call write_5spaces_newline
    17                              <1> 
    18                              <1>   print "y+: "
    48 000003D5 50                  <2>  push ax
    49 000003D6 53                  <2>  push bx
    50 000003D7 51                  <2>  push cx
    51 000003D8 52                  <2>  push dx
    52 000003D9 EB05                <2>  jmp %%endstr
    53 000003DB 792B3A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003E0 BB[DB03]            <2>  mov bx,%%str
    56 000003E3 E820FE              <2>  call write_string
    57 000003E6 5A                  <2>  pop dx
    58 000003E7 59                  <2>  pop cx
    59 000003E8 5B                  <2>  pop bx
    60 000003E9 58                  <2>  pop ax
    19 000003EA A1[3809]            <1>   mov ax,[ship.pos.y]
    20                              <1>   println_ax_unsigned
   107                              <2>  print_ax_unsigned
    73 000003ED E858FE              <3>  call write_number_word
   108 000003F0 E814FC              <2>  call write_5spaces_newline
    21                              <1> 
    22                              <1>   print "vx: "
    48 000003F3 50                  <2>  push ax
    49 000003F4 53                  <2>  push bx
    50 000003F5 51                  <2>  push cx
    51 000003F6 52                  <2>  push dx
    52 000003F7 EB05                <2>  jmp %%endstr
    53 000003F9 76783A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003FE BB[F903]            <2>  mov bx,%%str
    56 00000401 E802FE              <2>  call write_string
    57 00000404 5A                  <2>  pop dx
    58 00000405 59                  <2>  pop cx
    59 00000406 5B                  <2>  pop bx
    60 00000407 58                  <2>  pop ax
    23 00000408 A1[3E09]            <1>   mov ax,[ship.vel.x]  
    24                              <1>   println_ax
   102                              <2>  print_ax
    69 0000040B E88EFE              <3>  call write_signed_number_word
   103 0000040E E8F6FB              <2>  call write_5spaces_newline
    25                              <1> 
    26                              <1>   print "vy: "
    48 00000411 50                  <2>  push ax
    49 00000412 53                  <2>  push bx
    50 00000413 51                  <2>  push cx
    51 00000414 52                  <2>  push dx
    52 00000415 EB05                <2>  jmp %%endstr
    53 00000417 76793A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 0000041C BB[1704]            <2>  mov bx,%%str
    56 0000041F E8E4FD              <2>  call write_string
    57 00000422 5A                  <2>  pop dx
    58 00000423 59                  <2>  pop cx
    59 00000424 5B                  <2>  pop bx
    60 00000425 58                  <2>  pop ax
    27 00000426 A1[4009]            <1>   mov ax,[ship.vel.y]
    28                              <1>   println_ax
   102                              <2>  print_ax
    69 00000429 E870FE              <3>  call write_signed_number_word
   103 0000042C E8D8FB              <2>  call write_5spaces_newline
    29                              <1> 
    30                              <1>   ; print "vel.magSq: "
    31                              <1>   ; mov ax,[ship.vel.magSq]
    32                              <1>   ; println_ax_unsigned
    33                              <1> 
    34                              <1>   print "angle: "
    48 0000042F 50                  <2>  push ax
    49 00000430 53                  <2>  push bx
    50 00000431 51                  <2>  push cx
    51 00000432 52                  <2>  push dx
    52 00000433 EB08                <2>  jmp %%endstr
    53 00000435 616E676C653A2000    <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 0000043D BB[3504]            <2>  mov bx,%%str
    56 00000440 E8C3FD              <2>  call write_string
    57 00000443 5A                  <2>  pop dx
    58 00000444 59                  <2>  pop cx
    59 00000445 5B                  <2>  pop bx
    60 00000446 58                  <2>  pop ax
    35 00000447 A1[5209]            <1>   mov ax,[ship.angle] 
    36                              <1>   println_ax
   102                              <2>  print_ax
    69 0000044A E84FFE              <3>  call write_signed_number_word
   103 0000044D E8B7FB              <2>  call write_5spaces_newline
    37                              <1> 
    38                              <1>   ; print "index: "
    39                              <1>   ; mov ax,[ship.sprite_index]
    40                              <1>   ; println_ax
    41                              <1> 
    42                              <1>   ; print "img addr: "
    43                              <1>   ; mov ax,[ship.img_addr]
    44                              <1>   ; println_ax_hex
    45                              <1> 
    46                              <1>   print "force.x: "
    48 00000450 50                  <2>  push ax
    49 00000451 53                  <2>  push bx
    50 00000452 51                  <2>  push cx
    51 00000453 52                  <2>  push dx
    52 00000454 EB0A                <2>  jmp %%endstr
    53 00000456 666F7263652E783A20- <2>  %%str: db %1,0
    53 0000045F 00                  <2>
    54                              <2>  %%endstr:
    55 00000460 BB[5604]            <2>  mov bx,%%str
    56 00000463 E8A0FD              <2>  call write_string
    57 00000466 5A                  <2>  pop dx
    58 00000467 59                  <2>  pop cx
    59 00000468 5B                  <2>  pop bx
    60 00000469 58                  <2>  pop ax
    47 0000046A A1[4E09]            <1>   mov ax,[ship.force.x]
    48                              <1>   println_ax
   102                              <2>  print_ax
    69 0000046D E82CFE              <3>  call write_signed_number_word
   103 00000470 E894FB              <2>  call write_5spaces_newline
    49                              <1> 
    50                              <1>   print "force.y: "
    48 00000473 50                  <2>  push ax
    49 00000474 53                  <2>  push bx
    50 00000475 51                  <2>  push cx
    51 00000476 52                  <2>  push dx
    52 00000477 EB0A                <2>  jmp %%endstr
    53 00000479 666F7263652E793A20- <2>  %%str: db %1,0
    53 00000482 00                  <2>
    54                              <2>  %%endstr:
    55 00000483 BB[7904]            <2>  mov bx,%%str
    56 00000486 E87DFD              <2>  call write_string
    57 00000489 5A                  <2>  pop dx
    58 0000048A 59                  <2>  pop cx
    59 0000048B 5B                  <2>  pop bx
    60 0000048C 58                  <2>  pop ax
    51 0000048D A1[5009]            <1>   mov ax,[ship.force.y]
    52                              <1>   println_ax
   102                              <2>  print_ax
    69 00000490 E809FE              <3>  call write_signed_number_word
   103 00000493 E871FB              <2>  call write_5spaces_newline
    53                              <1> 
    54                              <1>   print "forces.x: "
    48 00000496 50                  <2>  push ax
    49 00000497 53                  <2>  push bx
    50 00000498 51                  <2>  push cx
    51 00000499 52                  <2>  push dx
    52 0000049A EB0B                <2>  jmp %%endstr
    53 0000049C 666F726365732E783A- <2>  %%str: db %1,0
    53 000004A5 2000                <2>
    54                              <2>  %%endstr:
    55 000004A7 BB[9C04]            <2>  mov bx,%%str
    56 000004AA E859FD              <2>  call write_string
    57 000004AD 5A                  <2>  pop dx
    58 000004AE 59                  <2>  pop cx
    59 000004AF 5B                  <2>  pop bx
    60 000004B0 58                  <2>  pop ax
    55 000004B1 A1[4A09]            <1>   mov ax,[ship.forces.x]
    56                              <1>   println_ax
   102                              <2>  print_ax
    69 000004B4 E8E5FD              <3>  call write_signed_number_word
   103 000004B7 E84DFB              <2>  call write_5spaces_newline
    57                              <1> 
    58                              <1>   print "forces.y: "
    48 000004BA 50                  <2>  push ax
    49 000004BB 53                  <2>  push bx
    50 000004BC 51                  <2>  push cx
    51 000004BD 52                  <2>  push dx
    52 000004BE EB0B                <2>  jmp %%endstr
    53 000004C0 666F726365732E793A- <2>  %%str: db %1,0
    53 000004C9 2000                <2>
    54                              <2>  %%endstr:
    55 000004CB BB[C004]            <2>  mov bx,%%str
    56 000004CE E835FD              <2>  call write_string
    57 000004D1 5A                  <2>  pop dx
    58 000004D2 59                  <2>  pop cx
    59 000004D3 5B                  <2>  pop bx
    60 000004D4 58                  <2>  pop ax
    59 000004D5 A1[4C09]            <1>   mov ax,[ship.forces.y]
    60                              <1>   println_ax
   102                              <2>  print_ax
    69 000004D8 E8C1FD              <3>  call write_signed_number_word
   103 000004DB E829FB              <2>  call write_5spaces_newline
    61                              <1> 
    62                              <1>   ; print "DI: "
    63                              <1>   ; mov ax,di
    64                              <1>   ; println_ax_hex
    65                              <1> 
    66 000004DE C3                  <1>   ret
     3                                  %include "vector.asm"
     1                              <1> %include "math.asm"
     1                              <2> ; ───────────────────────────────────────────────────────────────────────────
     2                              <2> 
     3                              <2> xy_from_angle: ; input: ax=angle, (no magnitude!) output: ax:dx = x:y
     4 000004DF 50                  <2>   push ax      ; save angle
     5 000004E0 E81000              <2>   call sin
     6 000004E3 92                  <2>   xchg dx,ax
     7 000004E4 58                  <2>   pop ax       ; restore angle
     8 000004E5 E82D00              <2>   call cos
     9 000004E8 C3                  <2>   ret
    10                              <2> 
    11                              <2> ; ───────────────────────────────────────────────────────────────────────────
    12                              <2> 
    13                              <2> angle_wrap: ; makes any angle positive within 0..360
    14 000004E9 09C0                <2>   or ax,ax
    15 000004EB 7D05                <2>   jge .done
    16 000004ED 056801              <2>   add ax,360
    17 000004F0 EBF7                <2>   jmp angle_wrap
    18                              <2> .done
    19 000004F2 C3                  <2>   ret
    20                              <2> 
    21                              <2> ; ───────────────────────────────────────────────────────────────────────────
    22                              <2> 
    23                              <2> sin: ; ax in degrees (pos or neg), returns sin(ax) -100..100
    24 000004F3 53                  <2>   push bx
    25 000004F4 BB[FC04]            <2>   mov bx,.lut
    26 000004F7 E83D00              <2>   call angle_lookup
    27 000004FA 5B                  <2>   pop bx
    28 000004FB C3                  <2>   ret
    29                              <2> .lut: 
    30 000004FC 001932465660646056- <2>   db 0,25,50,70,86,96,100,96,86,70,50,25,0,-25,-50,-70,-86,-96,-100,-96,-86,-70,-50,-25,0
    30 00000505 46321900E7CEBAAAA0- <2>
    30 0000050E 9CA0AABACEE700      <2>
    31                              <2> 
    32                              <2> ; ───────────────────────────────────────────────────────────────────────────
    33                              <2> 
    34                              <2> cos: ; ax in degrees (pos or neg), returns sin(ax) -100..100
    35 00000515 53                  <2>   push bx
    36 00000516 BB[1E05]            <2>   mov bx,.lut
    37 00000519 E81B00              <2>   call angle_lookup
    38 0000051C 5B                  <2>   pop bx
    39 0000051D C3                  <2>   ret
    40                              <2> .lut: 
    41 0000051E 64605646321900E7CE- <2>   db 100,96,86,70,50,25,0,-25,-50,-70,-86,-96,-100,-96,-86,-70,-49,-25,0,25,49,70,86,96,100
    41 00000527 BAAAA09CA0AABACFE7- <2>
    41 00000530 00193146566064      <2>
    42                              <2> 
    43                              <2> ; ───────────────────────────────────────────────────────────────────────────
    44                              <2> 
    45                              <2> angle_lookup: ; bx=lookup table, ax=angle (>=0) 0..360, result in ah
    46 00000537 E8AFFF              <2>   call angle_wrap ; makes angle between 0..360
    47 0000053A 52                  <2>   push dx
    48 0000053B 53                  <2>   push bx
    49 0000053C 99                  <2>   cwd ; clear dx (always 0 because angle wrap makes ax positive)
    50 0000053D BB0F00              <2>   mov bx,15    ; ax/=15
    51 00000540 F7F3                <2>   div bx
    52 00000542 5B                  <2>   pop bx
    53 00000543 D7                  <2>   xlat
    54 00000544 98                  <2>   cbw ; clear ah, except the sign if al is negative
    55 00000545 5A                  <2>   pop dx
    56 00000546 C3                  <2>   ret
    57                              <2> 
    58                              <2> ; ───────────────────────────────────────────────────────────────────────────
    59                              <2> 
    60                              <2> atan2: ; input bx,ax=y,x, output ax=angle
    61 00000547 83F800              <2>   cmp ax,0
    62 0000054A 750F                <2>   jnz .x_not_0
    63 0000054C 83FB00              <2>   cmp bx,0
    64 0000054F 7C05                <2>   jl .y_lte_0
    65 00000551 B85A00              <2>   mov ax,90
    66 00000554 EB2E                <2>   jmp .ret
    67                              <2> 
    68                              <2> .y_lte_0:
    69 00000556 B8A6FF              <2>   mov ax,-90
    70 00000559 EB29                <2>   jmp .ret
    71                              <2> 
    72                              <2> .x_not_0:
    73 0000055B 50                  <2>   push ax
    74 0000055C 50                  <2>   push ax   ; keep a copy of x
    75 0000055D 89D8                <2>   mov ax,bx
    76 0000055F B96F00              <2>   mov cx,111
    77 00000562 99                  <2>   cwd       ; dx=0
    78 00000563 F7E9                <2>   imul cx
    79 00000565 59                  <2>   pop cx;   ; restore x
    80                              <2> 
    81 00000566 99                  <2>   cwd
    82 00000567 F7F9                <2>   idiv cx   ; ax/=x
    83 00000569 99                  <2>   cwd
    84 0000056A E85200              <2>   call atan
    85 0000056D 59                  <2>   pop cx;   ; restore x
    86 0000056E 83F900              <2>   cmp cx,0
    87 00000571 7C02                <2>   jl .x_lt_0
    88 00000573 EB0F                <2>   jmp .ret
    89                              <2> 
    90                              <2> .x_lt_0:
    91 00000575 83FB00              <2>   cmp bx,0
    92 00000578 7D05                <2>   jge .y_gte_0
    93 0000057A 2DB400              <2>   sub ax,180
    94 0000057D EB05                <2>   jmp .ret
    95                              <2> 
    96                              <2> .y_gte_0:
    97 0000057F 05B400              <2>   add ax,180
    98 00000582 EB00                <2>   jmp .ret
    99                              <2> 
   100                              <2> .ret:
   101 00000584 83F800              <2>   cmp ax,0
   102 00000587 7C01                <2>   jl .add360
   103 00000589 C3                  <2>   ret
   104                              <2> .add360:
   105 0000058A 056801              <2>   add ax,360
   106 0000058D C3                  <2>   ret
   107                              <2> .error_x_0
   108                              <2>   set_cursor 1,1
    43                              <3> 
    44 0000058E BF0000              <3>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   109                              <2>   print "Division Error in atan2: x=0"
    48 00000591 50                  <3>  push ax
    49 00000592 53                  <3>  push bx
    50 00000593 51                  <3>  push cx
    51 00000594 52                  <3>  push dx
    52 00000595 EB1D                <3>  jmp %%endstr
    53 00000597 4469766973696F6E20- <3>  %%str: db %1,0
    53 000005A0 4572726F7220696E20- <3>
    53 000005A9 6174616E323A20783D- <3>
    53 000005B2 3000                <3>
    54                              <3>  %%endstr:
    55 000005B4 BB[9705]            <3>  mov bx,%%str
    56 000005B7 E84CFC              <3>  call write_string
    57 000005BA 5A                  <3>  pop dx
    58 000005BB 59                  <3>  pop cx
    59 000005BC 5B                  <3>  pop bx
    60 000005BD 58                  <3>  pop ax
   110 000005BE F4                  <2>   hlt
   111                              <2> 
   112                              <2> ; ───────────────────────────────────────────────────────────────────────────
   113                              <2> 
   114                              <2> atan: ; cx=z, return value in ax, bx destroyed, cx destroyed, dx destroyed
   115 000005BF 89C1                <2>   mov cx,ax           ; z
   116 000005C1 99                  <2>   cwd
   117 000005C2 83F96F              <2>   cmp cx,111
   118 000005C5 7F29                <2>   jg .z_gt_scale      ; if (z>111)
   119 000005C7 83F991              <2>   cmp cx,-111         ; if (z<-111) 
   120 000005CA 7C34                <2>   jl .z_lt_minus_scale
   121 000005CC 99                  <2>   cwd
   122 000005CD F7E8                <2>   imul ax             ; ax *= ax  (z*z)
   123 000005CF BB4D01              <2>   mov bx,333     
   124 000005D2 F7FB                <2>   idiv bx             ; ax /= 333   Taylor-benadering
   125 000005D4 99                  <2>   cwd
   126 000005D5 89C3                <2>   mov bx,ax
   127 000005D7 B86F00              <2>   mov ax,111
   128 000005DA 29D8                <2>   sub ax,bx           ; ax-=111  
   129 000005DC BBB400              <2>   mov bx,180
   130 000005DF F7EB                <2>   imul bx             ; ax*=180 
   131 000005E1 F7E9                <2>   imul cx             ; ax*=z
   132 000005E3 BB6F00              <2>   mov bx,111
   133 000005E6 F7FB                <2>   idiv bx             ; ax/=111
   134 000005E8 BB3A01              <2>   mov bx,314
   135 000005EB 99                  <2>   cwd
   136 000005EC F7FB                <2>   idiv bx             ; ax/=314
   137 000005EE 99                  <2>   cwd
   138 000005EF C3                  <2>   ret
   139                              <2> 
   140                              <2> .z_gt_scale:
   141 000005F0 B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
   142 000005F3 F7F9                <2>   idiv cx             ; ax/=z
   143 000005F5 E8C7FF              <2>   call atan           ; recursion
   144 000005F8 89C3                <2>   mov bx,ax
   145 000005FA B85A00              <2>   mov ax,90
   146 000005FD 29D8                <2>   sub ax,bx
   147 000005FF C3                  <2>   ret
   148                              <2> 
   149                              <2> .z_lt_minus_scale:
   150 00000600 B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
   151 00000603 F7F9                <2>   idiv cx             ; ax/=z
   152 00000605 E8B7FF              <2>   call atan           ; recursion
   153 00000608 89C3                <2>   mov bx,ax
   154 0000060A B8A6FF              <2>   mov ax,-90
   155 0000060D 29D8                <2>   sub ax,bx
   156 0000060F C3                  <2>   ret
   157                              <2> 
   158                              <2> ; ───────────────────────────────────────────────────────────────────────────
   159                              <2> 
   160                              <2> __atan2:
   161 00000610 50                  <2>   push ax
   162 00000611 53                  <2>   push bx
   163                              <2>   print "atan2(x="
    48 00000612 50                  <3>  push ax
    49 00000613 53                  <3>  push bx
    50 00000614 51                  <3>  push cx
    51 00000615 52                  <3>  push dx
    52 00000616 EB09                <3>  jmp %%endstr
    53 00000618 6174616E3228783D00  <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 00000621 BB[1806]            <3>  mov bx,%%str
    56 00000624 E8DFFB              <3>  call write_string
    57 00000627 5A                  <3>  pop dx
    58 00000628 59                  <3>  pop cx
    59 00000629 5B                  <3>  pop bx
    60 0000062A 58                  <3>  pop ax
   164 0000062B E86EFC              <2>   call write_signed_number_word
   165                              <2>   print ",y="
    48 0000062E 50                  <3>  push ax
    49 0000062F 53                  <3>  push bx
    50 00000630 51                  <3>  push cx
    51 00000631 52                  <3>  push dx
    52 00000632 EB04                <3>  jmp %%endstr
    53 00000634 2C793D00            <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 00000638 BB[3406]            <3>  mov bx,%%str
    56 0000063B E8C8FB              <3>  call write_string
    57 0000063E 5A                  <3>  pop dx
    58 0000063F 59                  <3>  pop cx
    59 00000640 5B                  <3>  pop bx
    60 00000641 58                  <3>  pop ax
   166 00000642 58                  <2>   pop ax
   167 00000643 53                  <2>   push bx
   168 00000644 E855FC              <2>   call write_signed_number_word
   169                              <2>   print ")="
    48 00000647 50                  <3>  push ax
    49 00000648 53                  <3>  push bx
    50 00000649 51                  <3>  push cx
    51 0000064A 52                  <3>  push dx
    52 0000064B EB03                <3>  jmp %%endstr
    53 0000064D 293D00              <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 00000650 BB[4D06]            <3>  mov bx,%%str
    56 00000653 E8B0FB              <3>  call write_string
    57 00000656 5A                  <3>  pop dx
    58 00000657 59                  <3>  pop cx
    59 00000658 5B                  <3>  pop bx
    60 00000659 58                  <3>  pop ax
   170 0000065A 5B                  <2>   pop bx
   171 0000065B 58                  <2>   pop ax
   172 0000065C E8E8FE              <2>   call atan2
   173 0000065F E83AFC              <2>   call write_signed_number_word
   174 00000662 B020                <2>   mov al,' '
   175 00000664 E864FB              <2>   call write_char
   176 00000667 E8C2FC              <2>   call new_line
   177 0000066A C3                  <2>   ret
   178                              <2> 
   179                              <2> ; ───────────────────────────────────────────────────────────────────────────
   180                              <2> 
   181                              <2> rnd:
   182 0000066B 53                  <2>   push bx
   183 0000066C 51                  <2>   push cx
   184 0000066D 52                  <2>   push dx
   185 0000066E B91000              <2>   mov cx, 16
   186                              <2> .lp
   187 00000671 A1[9906]            <2>   mov ax,[.seed]
   188 00000674 31D2                <2>   xor dx, dx           ; DX wordt gebruikt om het nieuwe bit te berekenen
   189 00000676 89C3                <2>   mov bx, ax           ; Kopieer de huidige waarde van AX naar BX
   190                              <2>   ; shr bx, 0            ; Feedback van het laagste bit (bit 0)
   191 00000678 30DA                <2>   xor dl, bl           ; Voeg de laagste bit aan DX toe
   192                              <2> 
   193 0000067A D1EB                <2>   shr bx, 1            ; Feedback bit 1
   194 0000067C 30DA                <2>   xor dl, bl
   195                              <2> 
   196 0000067E 51                  <2>   push cx
   197 0000067F B104                <2>   mov cl,4
   198 00000681 D3EB                <2>   shr bx, cl           ; Feedback bit 4
   199 00000683 30DA                <2>   xor dl, bl
   200                              <2> 
   201 00000685 B10F                <2>   mov cl,15 
   202 00000687 D3EB                <2>   shr bx, cl           ; Feedback bit 15
   203 00000689 30DA                <2>   xor dl, bl
   204                              <2> 
   205 0000068B D1E0                <2>   shl ax, 1            ; Verschuif de registerwaarde in AX
   206 0000068D 09D0                <2>   or ax, dx            ; Voeg de berekende bit toe
   207                              <2> 
   208 0000068F 59                  <2>   pop cx
   209 00000690 E2DF                <2>   loop .lp        ; Herhaal totdat CX 0 is
   210                              <2> 
   211 00000692 A3[9906]            <2>   mov [.seed],ax
   212 00000695 5A                  <2>   pop dx
   213 00000696 59                  <2>   pop cx
   214 00000697 5B                  <2>   pop bx
   215 00000698 C3                  <2>   ret
   216 00000699 00B4                <2>   .seed dw 0B400h
     2                              <1> 
     3                              <1> ; ───────────────────────────────────────────────────────────────────────────
     4                              <1> 
     5                              <1> v_print: ; print ([bx+0],[bx+2] + "    ")
     6 0000069B 50                  <1>   push ax
     7 0000069C 8B07                <1>   mov ax,[bx+0]
     8                              <1>   print_ax
    69 0000069E E8FBFB              <2>  call write_signed_number_word
     9                              <1>   print_char ","
    85 000006A1 50                  <2>  push ax
    86 000006A2 B02C                <2>  mov al,%1
    87 000006A4 E824FB              <2>  call write_char
    88 000006A7 58                  <2>  pop ax
    10 000006A8 8B4702              <1>   mov ax,[bx+2]
    11                              <1>   print_ax
    69 000006AB E8EEFB              <2>  call write_signed_number_word
    12                              <1>   print_2chars "  "
    92 000006AE 50                  <2>  push ax
    93 000006AF B82020              <2>  mov ax,%1
    94 000006B2 E864F9              <2>  call write_2chars
    95 000006B5 58                  <2>  pop ax
    13                              <1>   print_2chars "  "
    92 000006B6 50                  <2>  push ax
    93 000006B7 B82020              <2>  mov ax,%1
    94 000006BA E85CF9              <2>  call write_2chars
    95 000006BD 58                  <2>  pop ax
    14 000006BE 58                  <1>   pop ax
    15 000006BF C3                  <1>   ret
    16                              <1> 
    17                              <1> ; ───────────────────────────────────────────────────────────────────────────
    18                              <1> 
    19                              <1> v_println_unsigned:
    20 000006C0 50                  <1>   push ax
    21 000006C1 8B07                <1>   mov ax,[bx+0]
    22                              <1>   print_ax_unsigned
    73 000006C3 E882FB              <2>  call write_number_word
    23                              <1>   print_char ","
    85 000006C6 50                  <2>  push ax
    86 000006C7 B02C                <2>  mov al,%1
    87 000006C9 E8FFFA              <2>  call write_char
    88 000006CC 58                  <2>  pop ax
    24 000006CD 8B4702              <1>   mov ax,[bx+2]
    25                              <1>   print_ax_unsigned
    73 000006D0 E875FB              <2>  call write_number_word
    26                              <1>   print_2chars "  "
    92 000006D3 50                  <2>  push ax
    93 000006D4 B82020              <2>  mov ax,%1
    94 000006D7 E83FF9              <2>  call write_2chars
    95 000006DA 58                  <2>  pop ax
    27                              <1>   print_2chars "  "
    92 000006DB 50                  <2>  push ax
    93 000006DC B82020              <2>  mov ax,%1
    94 000006DF E837F9              <2>  call write_2chars
    95 000006E2 58                  <2>  pop ax
    28 000006E3 58                  <1>   pop ax
    29 000006E4 C3                  <1>   ret
    30                              <1> 
    31                              <1> ; ───────────────────────────────────────────────────────────────────────────
    32                              <1> 
    33                              <1> v_println:
    34 000006E5 E8B3FF              <1>   call v_print
    35                              <1>   println " "
    64                              <2>  print %1
    48 000006E8 50                  <3>  push ax
    49 000006E9 53                  <3>  push bx
    50 000006EA 51                  <3>  push cx
    51 000006EB 52                  <3>  push dx
    52 000006EC EB02                <3>  jmp %%endstr
    53 000006EE 2000                <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 000006F0 BB[EE06]            <3>  mov bx,%%str
    56 000006F3 E810FB              <3>  call write_string
    57 000006F6 5A                  <3>  pop dx
    58 000006F7 59                  <3>  pop cx
    59 000006F8 5B                  <3>  pop bx
    60 000006F9 58                  <3>  pop ax
    65 000006FA E82FFC              <2>  call new_line
    36 000006FD C3                  <1>   ret
    37                              <1> 
    38                              <1> ; ───────────────────────────────────────────────────────────────────────────
    39                              <1> 
    40                              <1> 
    41                              <1> v_normalize: ; [bx]
    42                              <1> 
    43                              <1>   ; int mag = intSqrt(magSq(p));
    44                              <1>   ; mem[p+0] = (mem[p+0] * 100) / mag;
    45                              <1>   ; mem[p+1] = (mem[p+1] * 100) / mag;
    46 000006FE C3                  <1>   ret
    47                              <1> 
    48                              <1> ; ───────────────────────────────────────────────────────────────────────────
    49                              <1> 
    50                              <1> v_from_angle_mag: ; input: ax=angle, cx=mag, output: bx=vector
    51 000006FF 52                  <1>   push dx
    52 00000700 E8DCFD              <1>   call xy_from_angle ; ax = angle [any] -> ax,dx = x,y [-100..100]
    53 00000703 8907                <1>   mov [bx+0],ax
    54 00000705 895702              <1>   mov [bx+2],dx
    55 00000708 5A                  <1>   pop dx
    56 00000709 E81300              <1>   call v_mult  ;bx=vector, cx=scaler
    57 0000070C C3                  <1>   ret
    58                              <1> 
    59                              <1> ; ───────────────────────────────────────────────────────────────────────────
    60                              <1> 
    61                              <1> v_clear: ; [bx]=0
    62 0000070D C7070000            <1>   mov word [bx+0],0
    63 00000711 C747020000          <1>   mov word [bx+2],0
    64 00000716 C3                  <1>   ret
    65                              <1> 
    66                              <1> ; ───────────────────────────────────────────────────────────────────────────
    67                              <1> 
    68                              <1> v_if_zero: ; [bx]==0    ; dit is geen goede test. want x=5,y=-5 levert ook 0 op.
    69 00000717 8B07                <1>   mov ax,[bx]
    70 00000719 034702              <1>   add ax,[bx+2]
    71 0000071C 09C0                <1>   or ax,ax
    72 0000071E C3                  <1>   ret
    73                              <1> 
    74                              <1> ; ───────────────────────────────────────────────────────────────────────────
    75                              <1> 
    76                              <1> v_mult:  ; bx=vector, cx=scaler, output: bx=vector
    77 0000071F 8B07                <1>   mov ax,[bx]   ; x
    78 00000721 99                  <1>   cwd
    79 00000722 F7E9                <1>   imul cx
    80 00000724 8907                <1>   mov [bx],ax
    81                              <1> 
    82 00000726 8B4702              <1>   mov ax,[bx+2] ; y
    83 00000729 99                  <1>   cwd
    84 0000072A F7E9                <1>   imul cx
    85 0000072C 894702              <1>   mov [bx+2],ax
    86 0000072F C3                  <1>   ret
    87                              <1> 
    88                              <1> ; ───────────────────────────────────────────────────────────────────────────
    89                              <1> 
    90                              <1> v_div:  ; bx=vector, cx=scaler
    91 00000730 8B07                <1>   mov ax,[bx]   ; x
    92 00000732 99                  <1>   cwd
    93 00000733 F7F9                <1>   idiv cx
    94 00000735 8907                <1>   mov [bx],ax
    95                              <1>   
    96 00000737 8B4702              <1>   mov ax,[bx+2] ; y
    97 0000073A 99                  <1>   cwd
    98 0000073B F7F9                <1>   idiv cx
    99 0000073D 894702              <1>   mov [bx+2],ax
   100 00000740 C3                  <1>   ret
   101                              <1> 
   102                              <1> ; ───────────────────────────────────────────────────────────────────────────
   103                              <1> 
   104                              <1> v_scale:  ; bx=vector,  cx=scaler (x100), updates bx
   105 00000741 50                  <1>   push ax
   106 00000742 8B07                <1>   mov ax, [bx]   ; x
   107 00000744 99                  <1>   cwd
   108 00000745 F7E9                <1>   imul cx
   109 00000747 51                  <1>   push cx
   110 00000748 B96400              <1>   mov cx,100
   111 0000074B F7F9                <1>   idiv cx
   112 0000074D 59                  <1>   pop cx
   113 0000074E 8907                <1>   mov [bx], ax
   114                              <1> 
   115 00000750 8B4702              <1>   mov ax, [bx+2]   ; y
   116 00000753 99                  <1>   cwd
   117 00000754 F7E9                <1>   imul cx
   118 00000756 51                  <1>   push cx
   119 00000757 B96400              <1>   mov cx,100
   120 0000075A F7F9                <1>   idiv cx
   121 0000075C 59                  <1>   pop cx
   122 0000075D 894702              <1>   mov [bx+2], ax
   123 00000760 58                  <1>   pop ax
   124 00000761 C3                  <1>   ret
   125                              <1> 
   126                              <1> ; ───────────────────────────────────────────────────────────────────────────
   127                              <1> 
   128                              <1> v_copy:    ; input bx=target,bp=source: copy vec bp into vec bx
   129 00000762 8B4600              <1>   mov ax,[bp]
   130 00000765 8907                <1>   mov [bx],ax
   131 00000767 8B4602              <1>   mov ax,[bp+2]
   132 0000076A 894702              <1>   mov [bx+2],ax
   133 0000076D C3                  <1>   ret
   134                              <1> 
   135                              <1> ; ───────────────────────────────────────────────────────────────────────────
   136                              <1> 
   137                              <1> v_set: ; [bx]=ax:dx
   138 0000076E 8907                <1>   mov [bx+0],ax
   139 00000770 895702              <1>   mov [bx+2],dx
   140 00000773 C3                  <1>   ret
   141                              <1> 
   142                              <1> ; ───────────────────────────────────────────────────────────────────────────
   143                              <1> 
   144                              <1> v_add: ; [bx]+=[bp]
   145 00000774 8B07                <1>   mov ax,[bx]
   146 00000776 034600              <1>   add ax,[bp]     ; bx.x += bp.x
   147 00000779 8907                <1>   mov [bx],ax
   148 0000077B 8B4702              <1>   mov ax,[bx+2]
   149 0000077E 034602              <1>   add ax,[bp+2]   ; bx.y += bp.y
   150 00000781 894702              <1>   mov [bx+2],ax
   151 00000784 C3                  <1>   ret
   152                              <1> 
   153                              <1> ; ───────────────────────────────────────────────────────────────────────────
   154                              <1> 
   155                              <1> v_sub: ; [bx]-=[bp]
   156 00000785 8B07                <1>   mov ax,[bx]
   157 00000787 2B4600              <1>   sub ax,[bp]     ; bx.x -= bp.x
   158 0000078A 8907                <1>   mov [bx],ax
   159 0000078C 8B4702              <1>   mov ax,[bx+2]
   160 0000078F 2B4602              <1>   sub ax,[bp+2]   ; bx.y -= bp.y
   161 00000792 894702              <1>   mov [bx+2],ax
   162 00000795 C3                  <1>   ret
   163                              <1> 
   164                              <1> ; ───────────────────────────────────────────────────────────────────────────
   165                              <1> 
   166                              <1> v_heading: ; bx contains address of 4 bytes vector
   167 00000796 8B07                <1>   mov ax,[bx]
   168 00000798 8B5F02              <1>   mov bx,[bx+2]
   169 0000079B E8A9FD              <1>   call atan2
   170 0000079E C3                  <1>   ret
   171                              <1> 
   172                              <1> ; ───────────────────────────────────────────────────────────────────────────
   173                              <1> 
   174                              <1> v_limit: ; [bx] input vector, ax=max_length. destroys dx, updates [bx]      ; erg inefficient. zou moeten kunnen zonder loop
   175 0000079F 53                  <1>   push bx
   176 000007A0 55                  <1>   push bp
   177 000007A1 F7E0                <1>   mul ax  ; ax*=ax
   178                              <1> 
   179 000007A3 95                  <1>   xchg bp,ax  ; bp now contains max*max
   180                              <1> 
   181                              <1> .lp:
   182 000007A4 E80F00              <1>   call v_mag_sq     ; ax = magSq([bx])
   183                              <1> 
   184                              <1> 
   185 000007A7 39E8                <1>   cmp ax,bp
   186 000007A9 7E08                <1>   jle .done
   187 000007AB B95F00              <1>   mov cx,95
   188                              <1> 
   189 000007AE E890FF              <1>   call v_scale      ; bx=vector, cx=scaler (x100), updates bx
   190 000007B1 EBF1                <1>   jmp .lp
   191                              <1> .done:
   192 000007B3 5D                  <1>   pop bp
   193 000007B4 5B                  <1>   pop bx
   194 000007B5 C3                  <1>   ret
   195                              <1> 
   196                              <1> ; ───────────────────────────────────────────────────────────────────────────
   197                              <1> 
   198                              <1> v_mag_sq:   ; ax=magSq([bx])
   199 000007B6 E80100              <1>   call v_mag_sq_scaled
   200 000007B9 C3                  <1>   ret
   201                              <1> 
   202                              <1> 
   203                              <1> v_mag_sq_scaled:   ; ax=magSq([bx])
   204                              <1>   ; scaled down with 10
   205                              <1> 
   206 000007BA 53                  <1>   push bx
   207 000007BB 52                  <1>   push dx
   208 000007BC 51                  <1>   push cx
   209                              <1> 
   210 000007BD 8B07                <1>   mov ax,[bx]
   211 000007BF 99                  <1>   cwd
   212 000007C0 B90A00              <1>   mov cx,10   ; let op cx ipv cl
   213 000007C3 F7F9                <1>   idiv cx
   214 000007C5 99                  <1>   cwd
   215 000007C6 F7E8                <1>   imul ax   ; moet dit niet gewoon mul zijn ipv imul?
   216 000007C8 A3[EB07]            <1>   mov [.xx],ax   ; use cx for tmp copy of x*x
   217                              <1> 
   218                              <1>   ; print "vec="
   219                              <1>   ; call v_print
   220                              <1>   ; print "x*x="
   221                              <1>   ; print_ax ; //y*y
   222                              <1> 
   223 000007CB 8B4702              <1>   mov ax,[bx+2]
   224 000007CE 99                  <1>   cwd
   225 000007CF B90A00              <1>   mov cx,10   ; let op cx ipv cl
   226 000007D2 F7F9                <1>   idiv cx
   227 000007D4 99                  <1>   cwd
   228 000007D5 F7E8                <1>   imul ax   ; moet dit niet gewoon mul zijn ipv imul?
   229 000007D7 A3[ED07]            <1>   mov [.yy],ax   ; use cx for tmp copy of x*x
   230                              <1> 
   231                              <1>   ; print " y*y="
   232                              <1>   ; println_ax ; //y*y
   233                              <1> 
   234 000007DA A1[EB07]            <1>   mov ax,[.xx]
   235 000007DD 0306[ED07]          <1>   add ax,[.yy]
   236 000007E1 99                  <1>   cwd
   237                              <1> 
   238 000007E2 B90A00              <1>   mov cx,10   ; let op cx ipv cl
   239 000007E5 F7E1                <1>   mul cx
   240                              <1> 
   241 000007E7 59                  <1>   pop cx
   242 000007E8 5A                  <1>   pop dx
   243                              <1> 
   244 000007E9 5B                  <1>   pop bx
   245 000007EA C3                  <1>   ret
   246 000007EB 0000                <1> .xx: dw 0
   247 000007ED 0000                <1> .yy: dw 0
   248                              <1> 
   249                              <1> 
   250                              <1> ; v_mag_sq32:   ; ax:dx = magSq([bx])
   251                              <1> ;   push bp
   252                              <1> ;   push cx
   253                              <1> ;   mov ax, [bx]      ; Laad X in AX
   254                              <1> ;   mul ax            ; AX * AX -> resultaat in DX:AX
   255                              <1> ;   mov cx, ax        ; Bewaar laag deel (X²) in CX
   256                              <1> ;   mov bp, dx        ; Bewaar hoog deel (X²) in BP(!) (voor overloop)
   257                              <1> ;   mov ax, [bx+2]    ; Laad Y in AX
   258                              <1> ;   mul ax            ; AX * AX -> resultaat in DX:AX
   259                              <1> ;   add cx, ax        ; Voeg laag deel (Y²) toe aan CX
   260                              <1> ;   adc bp, dx        ; Voeg hoog deel (Y²) toe aan BP(!) met carry
   261                              <1> ;   mov ax, cx        ; Laag deel terugzetten in AX
   262                              <1> ;   mov dx, bp        ; Hoog deel terugzetten in DX
   263                              <1> ;   pop cx
   264                              <1> ;   pop bp
   265                              <1> ;   ret
   266                              <1> 
   267                              <1> 
   268                              <1> ; ───────────────────────────────────────────────────────────────────────────
   269                              <1> 
   270                              <1> ; v_mag:   ; ax=sqrt(magSq([bx]))
   271                              <1> ;   call v_mag_sq32
   272                              <1> ;   call sqrt32
   273                              <1> ;   ret
   274                              <1>   
   275                              <1> ; ───────────────────────────────────────────────────────────────────────────
   276                              <1> 
   277                              <1> 
   278                              <1> 
     4                                  %include "stars.asm"
     1                              <1> init_stars:
     2 000007EF B96400              <1>   mov cx,NUM_STARS*2   ; *2 for both x and y
     3                              <1> .lp
     4 000007F2 89CB                <1>   mov bx,cx
     5 000007F4 8B87[A20A]          <1>   mov ax,[setup+bx]   ; use setup and draw instructions as seed
     6 000007F8 A3[9906]            <1>   mov [rnd.seed],ax
     7 000007FB E86DFE              <1>   call rnd
     8 000007FE 2E8987[6509]        <1>   mov [cs:bx+stars],ax
     9 00000803 E2ED                <1>   loop .lp
    10 00000805 C3                  <1>   ret
    11                              <1> 
    12                              <1> ; ───────────────────────────────────────────────────────────────────────────
    13                              <1> 
    14                              <1> undraw_and_draw_star:    ; now ax=x, bx=y   location of star in world coords
    15 00000806 8EC1                <1>   mov es,cx
    16                              <1> 
    17 00000808 51                  <1>   push cx
    18                              <1> 
    19                              <1>   ; undraw star
    20 00000809 50                  <1>   push ax
    21 0000080A 53                  <1>   push bx
    22 0000080B 2B06[3A09]          <1>     sub ax,[ship.prev.x]
    23 0000080F 2B1E[3C09]          <1>     sub bx,[ship.prev.y]
    24 00000813 E81203              <1>     call world2screen
    25 00000816 E8F9FA              <1>     call calc_di_from_bx
    26 00000819 B80000              <1>     mov ax,0
    27 0000081C AB                  <1>     stosw
    28 0000081D AA                  <1>     stosb
    29 0000081E 5B                  <1>   pop bx
    30 0000081F 58                  <1>   pop ax
    31                              <1> 
    32                              <1> ; draw star new position
    33 00000820 50                  <1>   push ax
    34 00000821 53                  <1>   push bx
    35 00000822 2B06[3609]          <1>     sub ax,[ship.pos.x]
    36 00000826 2B1E[3809]          <1>     sub bx,[ship.pos.y]
    37 0000082A E8FB02              <1>     call world2screen
    38 0000082D E8E2FA              <1>     call calc_di_from_bx
    39 00000830 A1[6708]            <1>     mov ax,[draw_stars.shape]
    40 00000833 AB                  <1>     stosw
    41 00000834 AA                  <1>     stosb
    42 00000835 5B                  <1>   pop bx
    43 00000836 58                  <1>   pop ax
    44                              <1> 
    45 00000837 59                  <1>   pop cx
    46 00000838 C3                  <1>   ret
    47                              <1> 
    48                              <1> ; ───────────────────────────────────────────────────────────────────────────
    49                              <1> 
    50                              <1> draw_stars:  ; call 3 times, for every color channel
    51 00000839 B93200              <1>   mov cx,NUM_STARS
    52 0000083C BE[6509]            <1>   mov si,stars
    53                              <1> 
    54                              <1> .lp
    55                              <1> 
    56 0000083F B80010              <1>   mov ax,0b0001000000000000
    57 00000842 09C9                <1>   or cx,cx
    58 00000844 7A03                <1>   jp .l1
    59 00000846 B81038              <1>   mov ax,0b0011100000010000
    60                              <1> .l1
    61 00000849 A3[6708]            <1>   mov [.shape],ax
    62 0000084C AD                  <1>   lodsw
    63 0000084D 93                  <1>   xchg bx,ax
    64 0000084E AD                  <1>   lodsw
    65 0000084F 93                  <1>   xchg bx,ax     ; now ax=x, bx=y
    66                              <1> 
    67 00000850 51                  <1>   push cx
    68 00000851 B900F0              <1>   mov cx,RED
    69 00000854 E8AFFF              <1>   call undraw_and_draw_star
    70 00000857 B9001C              <1>   mov cx,GREEN
    71 0000085A E8A9FF              <1>   call undraw_and_draw_star
    72 0000085D B900F4              <1>   mov cx,BLUE
    73 00000860 E8A3FF              <1>   call undraw_and_draw_star
    74 00000863 59                  <1>   pop cx
    75                              <1> 
    76                              <1> 
    77                              <1> .next
    78 00000864 E2D9                <1>   loop .lp
    79 00000866 C3                  <1>   ret
    80 00000867 0000                <1>   .shape dw 0
    81                              <1> 
    82                              <1> 
     5                                  %include "ship.asm"
     1                              <1> update_ship:
     2                              <1> 
     3 00000869 BB[3A09]            <1>   mov bx,ship.prev
     4 0000086C BD[3609]            <1>   mov bp,ship.pos
     5 0000086F E8F0FE              <1>   call v_copy             ; previous position of ship
     6                              <1> 
     7                              <1>   ; mov bx,ship.force
     8                              <1>   ; mov bp,ship.forces
     9                              <1>   ; call v_copy             ; force = forces.copy()
    10                              <1> 
    11                              <1>   ; mov bx,ship.force
    12                              <1>   ; mov cx,2
    13                              <1>   ; call v_limit            ; force.limit(25)
    14                              <1> 
    15                              <1>   ; mov bx,ship.forces
    16                              <1>   ; mov bp,ship.force
    17                              <1>   ; call v_sub              ; forces -= force
    18                              <1> 
    19                              <1>   ; mov bx,ship.forces
    20                              <1>   ; mov cx,98
    21                              <1>   ; call v_scale            ; forces *= 0.90
    22                              <1> 
    23                              <1>   ; mov bx,ship.acc
    24                              <1>   ; mov bp,ship.force
    25                              <1>   ; call v_add              ; acceleration += forces
    26                              <1> 
    27                              <1>   ; mov bx,ship.force
    28                              <1>   ; mov cx,0
    29                              <1>   ; call v_mult             ; ///force is altijd maar tijdelijk
    30                              <1> 
    31                              <1> 
    32                              <1>   ; mov bx,ship.vel
    33                              <1>   ; mov bp,ship.acc
    34                              <1>   ; call v_add              ; velocity += acceleration
    35                              <1> 
    36                              <1>   ; mov bx,ship.acc
    37                              <1>   ; mov cx,0
    38                              <1>   ; call v_mult             ; acceleration = 0
    39                              <1> 
    40                              <1>   ; mov bx,ship.pos
    41                              <1>   ; mov bp,ship.vel
    42                              <1>   ; call v_add              ; position += velocity
    43                              <1> 
    44                              <1>   ; mov bx,ship.vel
    45                              <1>   ; mov cx,98
    46                              <1>   ; call v_scale            ; velocity *= .98
    47                              <1> 
    48                              <1> 
    49                              <1> 
    50                              <1> 
    51 00000872 BB[4E09]            <1>    mov bx,ship.force
    52 00000875 BD[4A09]            <1>   mov bp,ship.forces
    53 00000878 E8E7FE              <1>   call v_copy             ; force = forces.copy()
    54                              <1> 
    55 0000087B BB[4E09]            <1>   mov bx,ship.force
    56 0000087E B81900              <1>   mov ax,25
    57 00000881 E81BFF              <1>   call v_limit            ; force.limit(25)
    58                              <1> 
    59 00000884 BB[4A09]            <1>   mov bx,ship.forces
    60 00000887 BD[4E09]            <1>   mov bp,ship.force
    61 0000088A E8F8FE              <1>   call v_sub              ; forces -= force
    62                              <1> 
    63 0000088D E855FE              <1>   call v_println ; bx
    64 00000890 87EB                <1>   xchg bx,bp
    65 00000892 E850FE              <1>   call v_println ; bp
    66                              <1> 
    67 00000895 BB[4A09]            <1>   mov bx,ship.forces
    68 00000898 B95A00              <1>   mov cx,90
    69 0000089B E8A3FE              <1>   call v_scale            ; forces *= 0.90
    70                              <1> 
    71 0000089E BB[4609]            <1>   mov bx,ship.acc
    72 000008A1 BD[4E09]            <1>   mov bp,ship.force
    73 000008A4 E8CDFE              <1>   call v_add              ; acceleration += forces
    74                              <1> 
    75 000008A7 BB[3E09]            <1>   mov bx,ship.vel
    76 000008AA BD[4609]            <1>   mov bp,ship.acc
    77 000008AD E8C4FE              <1>   call v_add              ; velocity += acceleration
    78                              <1> 
    79 000008B0 BB[4609]            <1>   mov bx,ship.acc
    80 000008B3 E857FE              <1>   call v_clear
    81                              <1> 
    82 000008B6 BB[3609]            <1>   mov bx,ship.pos
    83 000008B9 BD[3E09]            <1>   mov bp,ship.vel
    84 000008BC E8B5FE              <1>   call v_add              ; position += velocity
    85                              <1> 
    86 000008BF BB[3E09]            <1>   mov bx,ship.vel
    87 000008C2 B96200              <1>   mov cx,98
    88 000008C5 E879FE              <1>   call v_scale            ; velocity *= .98
    89                              <1> 
    90                              <1>   ; mov bx,ship.vel
    91                              <1>   ; mov cx,100
    92                              <1>   ; call v_limit            ; max velocity
    93                              <1> 
    94                              <1>   ; mov bx,ship.vel
    95                              <1>   ; call v_mag_sq
    96                              <1>   ; mov [ship.vel.magSq],ax  ;USED for debug
    97                              <1> 
    98                              <1> 
    99                              <1> .begin_angle:
   100 000008C8 BB[3E09]            <1>   mov bx,ship.vel
   101 000008CB E849FE              <1>   call v_if_zero
   102 000008CE 741B                <1>   jz .end_angle
   103 000008D0 E8C3FE              <1>   call v_heading   
   104 000008D3 A3[5209]            <1>   mov [ship.angle],ax     ; angle = heading(velocity)
   105                              <1> 
   106                              <1>   ;calc sprite index from angle in ax
   107 000008D6 31D2                <1>   xor dx,dx
   108 000008D8 BB0F00              <1>   mov bx,15
   109 000008DB F7FB                <1>   idiv bx                 ; sprite_index = angle/15 (range 0..23)
   110 000008DD A3[5409]            <1>   mov [ship.sprite_index],ax   
   111 000008E0 BB0203              <1>   mov bx,770
   112 000008E3 F7E3                <1>   mul bx                  ; img_addr = (668+2 bytes per image * sprite_index)
   113 000008E5 05[390B]            <1>   add ax,img_first        ; img_addr += img_first (offset)
   114 000008E8 A3[5609]            <1>   mov [ship.img_addr],ax
   115                              <1> .end_angle:
   116                              <1> 
   117 000008EB C3                  <1>   ret
   118                              <1> 
   119                              <1> ; ───────────────────────────────────────────────────────────────────────────
   120                              <1> 
   121                              <1> draw_ship_static:
   122 000008EC BF5022              <1>   mov di,8784
   123 000008EF 8B36[5609]          <1>   mov si,[ship.img_addr]
   124 000008F3 E8DAF9              <1>   call draw_spr
   125 000008F6 C3                  <1>   ret
   126                              <1> 
   127                              <1> draw_ship:
   128 000008F7 A1[3609]            <1>   mov ax,[ship.pos.x]
   129 000008FA 8B1E[3809]          <1>   mov bx,[ship.pos.y]
   130 000008FE E82702              <1>   call world2screen
   131 00000901 E80EFA              <1>   call calc_di_from_bx
   132                              <1> 
   133                              <1>   ; cmp [ship.prev_di],di  
   134                              <1>   ; je .return             ; no screen update needed >>>  DISABLED because ship on fixed position
   135                              <1> 
   136 00000904 8B3E[5809]          <1>   mov di,[ship.prev_di]
   137                              <1> 
   138 00000908 A1[3609]            <1>   mov ax,[ship.pos.x]
   139 0000090B 8B1E[3809]          <1>   mov bx,[ship.pos.y]
   140 0000090F E81602              <1>   call world2screen
   141 00000912 E8FDF9              <1>   call calc_di_from_bx
   142 00000915 83FF00              <1>   cmp di,0
   143 00000918 7F03                <1>   jg .ok
   144 0000091A BF0000              <1>   mov di,0
   145                              <1> .ok
   146 0000091D 893E[5809]          <1>   mov [ship.prev_di],di
   147                              <1> 
   148 00000921 8B36[5609]          <1>   mov si,[ship.img_addr]
   149 00000925 A1[3609]            <1>   mov ax,[ship.pos.x]
   150 00000928 8B1E[3809]          <1>   mov bx,[ship.pos.y]
   151 0000092C E8F901              <1>   call world2screen ; ax and bx are already set by pop bx, pop ax
   152 0000092F E8E0F9              <1>   call calc_di_from_bx
   153 00000932 E89BF9              <1>   call draw_spr
   154                              <1> 
   155                              <1> .return
   156 00000935 C3                  <1>   ret
     6                                  
     7                                  ship:
     8                                   .pos:
     9 00000936 0090                     .pos.x: dw 73728/2              ; 0..73728  (65536)
    10 00000938 F03C                     .pos.y: dw 51200/2 - 10000      ; 0..51200  (=1024*50)
    11                                   .prev:
    12 0000093A 0090                     .prev.x: dw 73728/2              ; 0..73728  (65536)
    13 0000093C F03C                     .prev.y: dw 51200/2 - 10000      ; 0..51200  (=1024*50)
    14                                   .vel: 
    15 0000093E 0000                     .vel.x: dw 0
    16 00000940 0000                     .vel.y: dw 0
    17 00000942 0000                     .vel.flags: dw 0
    18 00000944 0000                     .vel.magSq: dw 0
    19                                   .acc:
    20 00000946 0000                     .acc.x: dw 0
    21 00000948 0000                     .acc.y: dw 0
    22                                   .forces:             ; accumulated forces over time
    23 0000094A 0000                     .forces.x: dw 0
    24 0000094C 0000                     .forces.y: dw 0
    25                                   .force:              ; force for this frame derived from accumulated forces
    26 0000094E 0000                     .force.x: dw 0
    27 00000950 0000                     .force.y: dw 0
    28 00000952 0000                     .angle: dw 0
    29 00000954 0000                     .sprite_index: dw 0
    30 00000956 [390B]                   .img_addr: dw img_first
    31 00000958 0000                     .prev_di: dw 0
    32                                  
    33                                  debug:
    34 0000095A 0000                      .ax: dw 0
    35 0000095C 0000                      .bx: dw 0
    36 0000095E 0000                      .cx: dw 0
    37 00000960 0000                      .dx: dw 0
    38                                  
    39 00000962 0000                    frame_count: dw 0
    40 00000964 02                      color: db Color.G
    41                                  FRICTION equ 94
    42                                  STEP equ 1000
    43                                  FRAME_DELAY EQU 1
    44                                  NUM_STARS equ 50
    45 00000965 0000<rep 64h>           stars: times (2*NUM_STARS) dw 0  ; 50 stars at 0,0
    46                                  
    47                                  debug_test:
    48                                    set_cursor 1,1
    43                              <1> 
    44 00000A2D BF0000              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
    49                                  
    50 00000A30 B8F1FF                    mov ax,-15
    51 00000A33 E87300                    call addForceFromAngle
    52                                  
    53 00000A36 BB[4E09]                  mov bx,ship.force
    54 00000A39 BD[4A09]                  mov bp,ship.forces
    55 00000A3C E823FD                    call v_copy             ; force = forces.copy()
    56                                  
    57 00000A3F BB[4E09]                  mov bx,ship.force
    58                                    ; mov ax,25
    59                                    ; call v_limit            ; force.limit(25)
    60 00000A42 E871FD                    call v_mag_sq
    61                                  
    62 00000A45 BB[4A09]                  mov bx,ship.forces
    63 00000A48 BD[4E09]                  mov bp,ship.force
    64 00000A4B E837FD                    call v_sub              ; forces -= force
    65                                  
    66 00000A4E E894FC                    call v_println ; bx
    67 00000A51 87EB                      xchg bx,bp
    68 00000A53 E88FFC                    call v_println ; bp
    69                                  
    70 00000A56 BB[4A09]                  mov bx,ship.forces
    71 00000A59 B95A00                    mov cx,90
    72 00000A5C E8E2FC                    call v_scale            ; forces *= 0.90
    73                                  
    74 00000A5F BB[4609]                  mov bx,ship.acc
    75 00000A62 BD[4E09]                  mov bp,ship.force
    76 00000A65 E80CFD                    call v_add              ; acceleration += forces
    77                                  
    78 00000A68 BB[3E09]                  mov bx,ship.vel
    79 00000A6B BD[4609]                  mov bp,ship.acc
    80 00000A6E E803FD                    call v_add              ; velocity += acceleration
    81                                  
    82 00000A71 BB[4609]                  mov bx,ship.acc
    83 00000A74 E896FC                    call v_clear
    84                                  
    85 00000A77 BB[3609]                  mov bx,ship.pos
    86 00000A7A BD[3E09]                  mov bp,ship.vel
    87 00000A7D E8F4FC                    call v_add              ; position += velocity
    88                                  
    89 00000A80 BB[3E09]                  mov bx,ship.vel
    90 00000A83 B96200                    mov cx,98
    91 00000A86 E8B8FC                    call v_scale            ; velocity *= .98
    92                                  
    93                                  
    94                                  ; ----------------------------------
    95                                  
    96                                    ; mov bx,ship.vel
    97                                    ; mov cx,100
    98                                    ; call v_limit            ; max velocity
    99                                  
   100                                    ; mov bx,ship.vel
   101                                    ; call v_mag_sq
   102                                    ; mov [ship.vel.magSq],ax  ;USED for debug
   103                                  
   104                                  ;------ mov bx,ship.force
   105                                  ;------   mov cx,0
   106                                  ;------   call v_mult             ; ///force is altijd maar tijdelijk
   107                                    
   108                                    ; print "FORCES: "
   109                                    ; mov bx,ship.forces 
   110                                    ; call v_println
   111                                  
   112                                    ; print "FORCE: "
   113                                    ; mov bx,ship.force
   114                                    ; call v_println
   115                                  
   116                                    ; print "POS: "
   117                                    ; mov bx,ship.pos 
   118                                    ; call v_println_unsigned
   119                                  
   120                                    println "done"
    64                              <1>  print %1
    48 00000A89 50                  <2>  push ax
    49 00000A8A 53                  <2>  push bx
    50 00000A8B 51                  <2>  push cx
    51 00000A8C 52                  <2>  push dx
    52 00000A8D EB05                <2>  jmp %%endstr
    53 00000A8F 646F6E6500          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000A94 BB[8F0A]            <2>  mov bx,%%str
    56 00000A97 E86CF7              <2>  call write_string
    57 00000A9A 5A                  <2>  pop dx
    58 00000A9B 59                  <2>  pop cx
    59 00000A9C 5B                  <2>  pop bx
    60 00000A9D 58                  <2>  pop ax
    65 00000A9E E88BF8              <1>  call new_line
   121 00000AA1 F4                        hlt
   122                                  
   123                                  setup:
   124                                    ; call debug_test
   125                                    ; hlt
   126                                  
   127 00000AA2 E84AFD                    call init_stars
   128 00000AA5 31ED                      xor bp,bp
   129 00000AA7 EB19                      jmp draw
   130                                  
   131                                  
   132                                  ; ───────────────────────────────────────────────────────────────────────────
   133                                  
   134                                  addForceFromAngle:  ; input ax = current angle + rel angle
   135 00000AA9 B90500                    mov cx,5    ; magnitude
   136                                  
   137                                  
   138                                    ; mov ax,0 ; TMP
   139                                  
   140 00000AAC BB[4E09]                  mov bx,ship.force
   141 00000AAF E84DFC                    call v_from_angle_mag
   142                                  
   143 00000AB2 BB[4A09]                  mov bx,ship.forces
   144 00000AB5 BD[4E09]                  mov bp,ship.force
   145 00000AB8 E8B9FC                    call v_add  ; [bx]+=[bp]
   146                                  
   147 00000ABB BB[4E09]                  mov bx,ship.force
   148 00000ABE E84CFC                    call v_clear         ; FORCE wordt hier gebruikt als tmp variabele
   149                                     
   150                                  
   151 00000AC1 C3                        ret
   152                                  
   153                                  ; ───────────────────────────────────────────────────────────────────────────
   154                                  
   155                                  draw:
   156 00000AC2 0E                        push cs
   157 00000AC3 1F                        pop ds   ; make sure DS is set to CS for data lookups like [ship.pos.x]
   158                                  
   159 00000AC4 E8A2FD                    call update_ship
   160                                  
   161 00000AC7 E86FFD                    call draw_stars
   162 00000ACA E81FFE                    call draw_ship_static
   163 00000ACD E8A4F8                    call draw_debug_info
   164                                  
   165                                    ; call _wait
   166 00000AD0 FF06[6209]                inc word [frame_count]
   167                                  
   168 00000AD4 E8D9F7                    call check_keys
   169 00000AD7 7502                      jnz on_key
   170                                  
   171 00000AD9 EBE7                      jmp draw          ; this code is only getting called when no key is pressed
   172                                  
   173                                  
   174                                  ; ───────────────────────────────────────────────────────────────────────────
   175                                  
   176                                  
   177                                  on_key:
   178 00000ADB 83F877                    cmp ax,'w'
   179 00000ADE 7411                      je on_key_w
   180 00000AE0 83F861                    cmp ax,'a'
   181 00000AE3 7414                      je on_key_a
   182 00000AE5 83F873                    cmp ax,'s'
   183 00000AE8 7425                      je on_key_s
   184 00000AEA 83F864                    cmp ax,'d'
   185 00000AED 7415                      je on_key_d
   186                                  .done
   187 00000AEF EBD1                      jmp draw  ; no ret here because onkey is called by jnz
   188                                  
   189                                  
   190                                  ; ───────────────────────────────────────────────────────────────────────────
   191                                  
   192                                  on_key_w:
   193 00000AF1 A1[5209]                  mov ax,[ship.angle]
   194 00000AF4 E8B2FF                    call addForceFromAngle
   195 00000AF7 EBF6                      jmp on_key.done
   196                                  
   197                                  ; ───────────────────────────────────────────────────────────────────────────
   198                                  
   199                                  on_key_a:
   200 00000AF9 A1[5209]                  mov ax,[ship.angle]
   201 00000AFC 83E85A                    sub ax,90
   202 00000AFF E8A7FF                    call addForceFromAngle
   203 00000B02 EBEB                      jmp on_key.done
   204                                  
   205                                  ; ───────────────────────────────────────────────────────────────────────────
   206                                  
   207                                  on_key_d:
   208 00000B04 A1[5209]                  mov ax,[ship.angle]
   209 00000B07 83C05A                    add ax,90
   210 00000B0A E89CFF                    call addForceFromAngle
   211 00000B0D EBE0                      jmp on_key.done
   212                                  
   213                                  ; ───────────────────────────────────────────────────────────────────────────
   214                                  
   215                                  on_key_s:   ;;;;;;;;;;;;; remmen:  
   216 00000B0F BB[4A09]                  mov bx,ship.forces
   217 00000B12 E8F8FB                    call v_clear
   218                                  
   219 00000B15 BB[3E09]                  mov bx,ship.vel
   220 00000B18 B93200                    mov cx,50
   221 00000B1B E823FC                    call v_scale
   222                                  
   223 00000B1E EBCF                      jmp on_key.done
   224                                    ; ───────────────────────────────────────────────────────────────────────────
   225                                  
   226                                  
   227                                  _wait:
   228 00000B20 B90100                    mov cx,FRAME_DELAY
   229 00000B23 D40A                      .lp aam
   230 00000B25 E2FC                      loop .lp
   231 00000B27 C3                        ret
   232                                  
   233                                  ; ───────────────────────────────────────────────────────────────────────────
   234                                  
   235                                  world2screen:  ; input (ax,bx) = (world.x, world.y)   ; screen (row,col) ; output (bx)
   236                                    ; WORLD:
   237                                    ;   0..73728  (65536) -> col
   238                                    ;   0..51200  (=1024*50) -> row
   239                                    ; SCREEN (ROW,COL):
   240                                    ;   0..49 (row)
   241                                    ;   0..71 (col)
   242 00000B28 51                        push cx
   243 00000B29 B10A                      mov cl,10
   244 00000B2B D3EB                      shr bx,cl   ; //bl=row 0..49
   245 00000B2D D3E8                      shr ax,cl   ; 
   246 00000B2F FEC9                      dec cl
   247 00000B31 FEC9                      dec cl      ; cl=8
   248 00000B33 D3E3                      shl bx,cl   
   249                                    ; mov bh,al   ; //bh=col 0..71
   250                                    ; xchg bh,bl
   251 00000B35 09C3                      or bx,ax
   252 00000B37 59                        pop cx
   253 00000B38 C3                        ret
   254                                  
   255                                  ; ───────────────────────────────────────────────────────────────────────────
   256                                  
   257                                  img_first:
   258                                  img_right:
   259 00000B39 <bin 302h>              img7: incbin "data/ship-7.spr" ;right
   260 00000E3B <bin 302h>              img8: incbin "data/ship-8.spr"
   261 0000113D <bin 302h>              img9: incbin "data/ship-9.spr"
   262                                  img_down_right:
   263 0000143F <bin 302h>              img10: incbin "data/ship-10.spr" ;down-right
   264 00001741 <bin 302h>              img11: incbin "data/ship-11.spr"
   265 00001A43 <bin 302h>              img12: incbin "data/ship-12.spr"
   266                                  img_down:
   267 00001D45 <bin 302h>              img13: incbin "data/ship-13.spr" ;down
   268 00002047 <bin 302h>              img14: incbin "data/ship-14.spr"
   269 00002349 <bin 302h>              img15: incbin "data/ship-15.spr"
   270                                  img_down_left:
   271 0000264B <bin 302h>              img16: incbin "data/ship-16.spr" ;down-left
   272 0000294D <bin 302h>              img17: incbin "data/ship-17.spr"
   273 00002C4F <bin 302h>              img18: incbin "data/ship-18.spr"
   274                                  img_left:
   275 00002F51 <bin 302h>              img19: incbin "data/ship-19.spr" ;left
   276 00003253 <bin 302h>              img20: incbin "data/ship-20.spr"
   277 00003555 <bin 302h>              img21: incbin "data/ship-21.spr"
   278                                  img_up_left:
   279 00003857 <bin 302h>              img22: incbin "data/ship-22.spr" ;up-left
   280 00003B59 <bin 302h>              img23: incbin "data/ship-23.spr"
   281 00003E5B <bin 302h>              img24: incbin "data/ship-24.spr"
   282                                  img_up:
   283 0000415D <bin 302h>              img1: incbin "data/ship-1.spr" ;up
   284 0000445F <bin 302h>              img2: incbin "data/ship-2.spr"
   285 00004761 <bin 302h>              img3: incbin "data/ship-3.spr"
   286                                  img_up_right:
   287 00004A63 <bin 302h>              img4: incbin "data/ship-4.spr" ;up-right
   288 00004D65 <bin 302h>              img5: incbin "data/ship-5.spr"
   289 00005067 <bin 302h>              img6: incbin "data/ship-6.spr"
   290                                  
   291                                  
   292                                  ; %assign num $-$$
   293                                  ; %warning total num
   294                                  
   295 00005369 00<rep 27C97h>          times (180*1024)-($-$$) db 0
   296                                  
   297                                  
   298                                  
