     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 E9C700              <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 80          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34                              <1> cursor:
    35 00000003 00                  <1> .col: db 0
    36 00000004 00                  <1> .row: db 0
    37                              <1> 
    38                              <1> key:
    39 00000005 00                  <1>   .code db 0
    40 00000006 00                  <1>   .ctrl db 0
    41                              <1> 
    42                              <1> %macro set_cursor 2
    43                              <1>   ; mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    44                              <1>   mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    45                              <1> %endmacro
    46                              <1> 
    47                              <1> %macro print 1
    48                              <1>   push ax
    49                              <1>   push bx
    50                              <1>   push cx
    51                              <1>   push dx
    52                              <1>   jmp %%endstr 
    53                              <1>   %%str: db %1,0
    54                              <1>   %%endstr: 
    55                              <1>   mov bx,%%str
    56                              <1>   call write_string
    57                              <1>   pop dx
    58                              <1>   pop cx
    59                              <1>   pop bx
    60                              <1>   pop ax
    61                              <1> %endmacro
    62                              <1> 
    63                              <1> %macro println 1
    64                              <1>   print %1
    65                              <1>   call new_line
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro print_ax 0
    69                              <1>   call write_signed_number_word
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro print_ax_unsigned 0
    73                              <1>   call write_number_word
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro print_ax_hex 0
    77                              <1>   call write_ax_hex
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro print_ax_bin 0
    81                              <1>   call write_binary_word
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %macro print_char 1
    85                              <1>   push ax
    86                              <1>   mov al,%1
    87                              <1>   call write_char
    88                              <1>   pop ax
    89                              <1> %endmacro
    90                              <1> 
    91                              <1> %macro print_2chars 1
    92                              <1>   push ax
    93                              <1>   mov ax,%1
    94                              <1>   call write_2chars
    95                              <1>   pop ax
    96                              <1> %endmacro
    97                              <1> 
    98                              <1> ; ------------
    99                              <1> ; println
   100                              <1> 
   101                              <1> %macro println_ax 0
   102                              <1>   print_ax
   103                              <1>   call write_5spaces_newline
   104                              <1> %endmacro
   105                              <1> 
   106                              <1> %macro println_ax_unsigned 0
   107                              <1>   print_ax_unsigned
   108                              <1>   call write_5spaces_newline
   109                              <1> %endmacro
   110                              <1> 
   111                              <1> %macro println_ax_hex 0
   112                              <1>   print_ax_hex
   113                              <1>   call write_5spaces_newline
   114                              <1> %endmacro
   115                              <1> 
   116                              <1> %macro println_ax_bin 0
   117                              <1>   print_ax_bin
   118                              <1>   call write_5spaces_newline
   119                              <1> %endmacro
   120                              <1> 
   121                              <1> write_5spaces_newline:
   122 00000007 50                  <1>   push ax
   123 00000008 B82020              <1>   mov ax,"  "
   124 0000000B E80B00              <1>   call write_2chars
   125 0000000E E80800              <1>   call write_2chars
   126 00000011 E8B701              <1>   call write_char
   127 00000014 E81503              <1>   call new_line
   128 00000017 58                  <1>   pop ax
   129 00000018 C3                  <1>   ret
   130                              <1> 
   131                              <1> write_2chars:
   132 00000019 E8AF01              <1>   call write_char
   133 0000001C 86C4                <1>   xchg ah,al
   134 0000001E E8AA01              <1>   call write_char
   135 00000021 C3                  <1>   ret
   136                              <1> 
   137                              <1> %macro register_interrupt 1
   138                              <1>   mov ax,%1
   139                              <1>   stosw
   140                              <1>   mov ax,cs
   141                              <1>   stosw
   142                              <1> %endmacro
   143                              <1> 
   144                              <1> ; int0: hlt
   145                              <1> ; int1: hlt
   146                              <1> ; int2: hlt
   147                              <1> ; int3: hlt
   148                              <1> ; int4: hlt
   149                              <1> 
   150                              <1> int0:; int0: Division by zero
   151 00000022 FC                  <1>   cld
   152 00000023 B800F4              <1>   mov ax,BLUE
   153 00000026 8EC0                <1>   mov es,ax
   154 00000028 31FF                <1>   xor di,di
   155 0000002A B9201C              <1>   mov cx,7200
   156 0000002D B8FFFF              <1>   mov ax,-1
   157 00000030 F3AB                <1>   rep stosw
   158                              <1>   set_cursor 1,1
    43                              <2> 
    44 00000032 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   159                              <1>   print "Division by zero"
    48 00000035 50                  <2>  push ax
    49 00000036 53                  <2>  push bx
    50 00000037 51                  <2>  push cx
    51 00000038 52                  <2>  push dx
    52 00000039 EB11                <2>  jmp %%endstr
    53 0000003B 4469766973696F6E20- <2>  %%str: db %1,0
    53 00000044 6279207A65726F00    <2>
    54                              <2>  %%endstr:
    55 0000004C BB[3B00]            <2>  mov bx,%%str
    56 0000004F E8B401              <2>  call write_string
    57 00000052 5A                  <2>  pop dx
    58 00000053 59                  <2>  pop cx
    59 00000054 5B                  <2>  pop bx
    60 00000055 58                  <2>  pop ax
   160                              <1>   set_cursor 3,1
    43                              <2> 
    44 00000056 BF8004              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   161 00000059 58                  <1>   pop ax
   162                              <1>   print "IP="
    48 0000005A 50                  <2>  push ax
    49 0000005B 53                  <2>  push bx
    50 0000005C 51                  <2>  push cx
    51 0000005D 52                  <2>  push dx
    52 0000005E EB04                <2>  jmp %%endstr
    53 00000060 49503D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000064 BB[6000]            <2>  mov bx,%%str
    56 00000067 E89C01              <2>  call write_string
    57 0000006A 5A                  <2>  pop dx
    58 0000006B 59                  <2>  pop cx
    59 0000006C 5B                  <2>  pop bx
    60 0000006D 58                  <2>  pop ax
   163                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 0000006E E8D802              <3>  call write_ax_hex
   113 00000071 E893FF              <2>  call write_5spaces_newline
   164 00000074 E8B502              <1>   call new_line
   165                              <1>   print "CS="
    48 00000077 50                  <2>  push ax
    49 00000078 53                  <2>  push bx
    50 00000079 51                  <2>  push cx
    51 0000007A 52                  <2>  push dx
    52 0000007B EB04                <2>  jmp %%endstr
    53 0000007D 43533D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000081 BB[7D00]            <2>  mov bx,%%str
    56 00000084 E87F01              <2>  call write_string
    57 00000087 5A                  <2>  pop dx
    58 00000088 59                  <2>  pop cx
    59 00000089 5B                  <2>  pop bx
    60 0000008A 58                  <2>  pop ax
   166 0000008B 58                  <1>   pop ax
   167                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 0000008C E8BA02              <3>  call write_ax_hex
   113 0000008F E875FF              <2>  call write_5spaces_newline
   168 00000092 E89702              <1>   call new_line
   169                              <1>   print "FLAGS="
    48 00000095 50                  <2>  push ax
    49 00000096 53                  <2>  push bx
    50 00000097 51                  <2>  push cx
    51 00000098 52                  <2>  push dx
    52 00000099 EB07                <2>  jmp %%endstr
    53 0000009B 464C4147533D00      <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000000A2 BB[9B00]            <2>  mov bx,%%str
    56 000000A5 E85E01              <2>  call write_string
    57 000000A8 5A                  <2>  pop dx
    58 000000A9 59                  <2>  pop cx
    59 000000AA 5B                  <2>  pop bx
    60 000000AB 58                  <2>  pop ax
   170 000000AC 58                  <1>   pop ax
   171 000000AD E87E01              <1>   call write_binary_word
   172 000000B0 F4                  <1>   hlt
   173                              <1> 
   174                              <1> int1:; int1: Single step debugging
   175 000000B1 B001                <1>   mov al,1
   176 000000B3 EB0C                <1>   jmp int_msg
   177                              <1> int2:; int2: Non maskable interrupt
   178 000000B5 B002                <1>   mov al,2
   179 000000B7 EB08                <1>   jmp int_msg
   180                              <1> int3:; int3: For one-byte interrupt
   181 000000B9 B003                <1>   mov al,3
   182 000000BB EB04                <1>   jmp int_msg
   183                              <1>   ; push ax
   184                              <1>   ; push bx
   185                              <1>   ; push cx
   186                              <1>   ; push dx
   187                              <1>   ; push si
   188                              <1>   ; push di
   189                              <1>   ; push bp
   190                              <1>   ; push ds
   191                              <1>   ; push es
   192                              <1> 
   193                              <1>   ; ; mov di,10*4
   194                              <1>   ; ; set_cursor 5,5
   195                              <1>   ; xor di,di
   196                              <1>   ; print "int3:"
   197                              <1>   ; ; mov ax,cx
   198                              <1>   ; ; call write_number_word
   199                              <1> 
   200                              <1>   ; pop es
   201                              <1>   ; pop ds
   202                              <1>   ; pop bp
   203                              <1>   ; pop di
   204                              <1>   ; pop si
   205                              <1>   ; pop dx
   206                              <1>   ; pop cx
   207                              <1>   ; pop bx
   208                              <1>   ; pop ax
   209                              <1>   ; iret
   210                              <1> 
   211                              <1> int4:; int4: Signed overflow
   212 000000BD B004                <1>   mov al,4
   213 000000BF EB00                <1>   jmp int_msg
   214                              <1> int_msg:
   215 000000C1 BFF401              <1>   mov di,500
   216                              <1>   ; xor di,di
   217                              <1>   ; mov ax,di
   218                              <1>   ; mov cx,8*72  
   219                              <1>   ; rep stosw
   220                              <1>   ; xor di,di
   221                              <1>   ; push ax
   222                              <1>   ; print "int: "
   223                              <1>   ; pop ax
   224 000000C4 0430                <1>   add al,'0'
   225 000000C6 E80201              <1>   call write_char
   226                              <1>   ; print "      "
   227                              <1>   
   228 000000C9 F4                  <1>   hlt
   229                              <1> 
   230                              <1> boot:
   231 000000CA FA                  <1>   cli
   232 000000CB FC                  <1>   cld
   233 000000CC E8E900              <1>   call clear_green    
   234                              <1> 
   235                              <1>   ; init video      
   236 000000CF B005                <1>   mov al, 5
   237 000000D1 E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
   238                              <1>  
   239                              <1>   ; register interrupts
   240 000000D3 31FF                <1>   xor di,di ; offset 0
   241 000000D5 8EC7                <1>   mov es,di ; segment 0
   242                              <1>   register_interrupt int0
   138 000000D7 B8[2200]            <2>  mov ax,%1
   139 000000DA AB                  <2>  stosw
   140 000000DB 8CC8                <2>  mov ax,cs
   141 000000DD AB                  <2>  stosw
   243                              <1>   register_interrupt int1
   138 000000DE B8[B100]            <2>  mov ax,%1
   139 000000E1 AB                  <2>  stosw
   140 000000E2 8CC8                <2>  mov ax,cs
   141 000000E4 AB                  <2>  stosw
   244                              <1>   register_interrupt int2
   138 000000E5 B8[B500]            <2>  mov ax,%1
   139 000000E8 AB                  <2>  stosw
   140 000000E9 8CC8                <2>  mov ax,cs
   141 000000EB AB                  <2>  stosw
   245                              <1>   register_interrupt int3
   138 000000EC B8[B900]            <2>  mov ax,%1
   139 000000EF AB                  <2>  stosw
   140 000000F0 8CC8                <2>  mov ax,cs
   141 000000F2 AB                  <2>  stosw
   246                              <1>   register_interrupt int4
   138 000000F3 B8[BD00]            <2>  mov ax,%1
   139 000000F6 AB                  <2>  stosw
   140 000000F7 8CC8                <2>  mov ax,cs
   141 000000F9 AB                  <2>  stosw
   247                              <1> 
   248                              <1> 
   249                              <1>   ; init other hardware
   250 000000FA B000                <1>   mov al,0
   251 000000FC E63A                <1>   out 0x3a,al           ; keyboard \force state/
   252 000000FE E63A                <1>   out 0x3a,al           ; keyboard \force state/
   253 00000100 B0FF                <1>   mov al,0xFF
   254 00000102 E63A                <1>   out 0x3a,al           ; keyboard \reset/
   255 00000104 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   256 00000106 B037                <1>   mov al,0x37
   257 00000108 E63A                <1>   out 0x3a,al           ; keyboard \set command
   258                              <1> 
   259 0000010A B8001C              <1>   mov ax,GREEN      
   260 0000010D 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   261 0000010F B83800              <1>   mov ax,DST                
   262 00000112 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   263 00000114 BF0000              <1>   mov di,0                  ;
   264 00000117 B200                <1>   mov dl,0                  ; track=0
   265 00000119 B601                <1>   mov dh,1                  ; sector=1
   266 0000011B B95000              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   267 0000011E EB0B                <1>   jmp move_head
   268                              <1> 
   269                              <1> ; ───────────────────────────────────────────────────────────────────────────
   270                              <1> 
   271                              <1> next_sector:
   272 00000120 FEC6                <1>   inc dh                    ; sector++
   273 00000122 80FE0A              <1>   cmp dh,10
   274 00000125 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   275 00000127 B601                <1>   mov dh,1
   276 00000129 FEC2                <1>   inc dl                    ; else track++ ; sector=1
   277                              <1> 
   278                              <1> move_head:
   279 0000012B 88D0                <1>   mov al,dl
   280 0000012D E60E                <1>   out 0Eh,al               ; set track number
   281 0000012F B018                <1>   mov al,18h     
   282 00000131 E608                <1>   out 8,al                 ; seek track, load head
   283 00000133 B000                <1>   mov al,0
   284 00000135 E61C                <1>   out 1Ch,al               ; set desired drive/side
   285 00000137 D40A                <1>   aam
   286                              <1> 
   287                              <1> head_moving:
   288 00000139 E408                <1>   in al,8
   289 0000013B A801                <1>   test al,1
   290 0000013D 75FA                <1>   jnz head_moving
   291                              <1> 
   292                              <1> read_sector:
   293 0000013F 88F0                <1>   mov al,dh
   294 00000141 E60C                <1>   out 0Ch,al                ; sector number
   295 00000143 B702                <1>   mov bh,2                  ; 00000010b
   296 00000145 B396                <1>   mov bl,96h                ; 10010110b
   297 00000147 B400                <1>   mov ah,0
   298 00000149 B080                <1>   mov al,80h
   299 0000014B E608                <1>   out 8,al                  ; read sector
   300 0000014D D40A<rep 4h>        <1>   times 4 aam               ; wait
   301                              <1> 
   302                              <1> check_status_1:
   303 00000155 E408                <1>   in al,8                   ; read status
   304 00000157 D0F8                <1>   sar al,1                  ; status/=2
   305 00000159 731F                <1>   jnb check_status_3
   306 0000015B 75F8                <1>   jnz check_status_1
   307                              <1> 
   308                              <1> wait_for_data:
   309 0000015D E408                <1>   in al,8                   ; read status
   310 0000015F 20D8                <1>   and al,bl                 ; 96h
   311 00000161 74FA                <1>   jz wait_for_data
   312                              <1> 
   313                              <1> store_byte_1:
   314 00000163 E40E                <1>   in al,0Eh
   315 00000165 AA                  <1>   stosb
   316                              <1> 
   317                              <1> check_status_2:
   318 00000166 E408                <1>   in al,8                   ; read status
   319 00000168 48                  <1>   dec ax                    ; status--
   320 00000169 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   321 0000016B 38F8                <1>   cmp al, bh                ; bh=2
   322 0000016D 750B                <1>   jnz check_status_3        ; if (status==1) 
   323                              <1> 
   324                              <1> store_byte_2:
   325 0000016F E40E                <1>   in al,0Eh  
   326 00000171 AA                  <1>   stosb
   327                              <1> 
   328                              <1> check_status_4:
   329 00000172 E408                <1>   in al,8                   ; read status
   330 00000174 38F8                <1>   cmp al, bh                ; bh=2
   331 00000176 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   332 00000178 EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   333                              <1> 
   334                              <1> ; ───────────────────────────────────────────────────────────────────────────
   335                              <1> 
   336                              <1> check_status_3:
   337 0000017A E408                <1>   in al, 8                  ; read status
   338 0000017C A81C                <1>   test al, 1Ch              ; 00011100
   339 0000017E 7402                <1>   jz while_sectors
   340 00000180 EBBD                <1>   jmp read_sector
   341                              <1> 
   342                              <1> ; ───────────────────────────────────────────────────────────────────────────
   343                              <1> 
   344                              <1> while_sectors:
   345 00000182 E81200              <1>   call progress_bar
   346 00000185 E299                <1>   loop next_sector
   347                              <1> 
   348                              <1> done_reading:
   349 00000187 0E                  <1>   push cs
   350 00000188 17                  <1>   pop ss
   351 00000189 BC0000              <1>   mov sp,0
   352 0000018C E82900              <1>   call clear_green
   353 0000018F 0E                  <1>   push cs
   354 00000190 1F                  <1>   pop ds
   355                              <1>   set_cursor 1,1 ; nodig?
    43                              <2> 
    44 00000191 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   356 00000194 E9CF09              <1>   jmp setup
   357                              <1> 
   358                              <1> ; ───────────────────────────────────────────────────────────────────────────
   359                              <1> 
   360                              <1> progress_bar:
   361                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   362 00000197 52                  <1>   push dx
   363 00000198 53                  <1>   push bx
   364 00000199 31D2                <1>   xor dx,dx
   365 0000019B B81E00              <1>   mov ax,BAR_WIDTH
   366 0000019E BB5000              <1>   mov bx,NUM_SECTORS    
   367 000001A1 F7E1                <1>   mul cx
   368 000001A3 F7F3                <1>   div bx
   369 000001A5 5B                  <1>   pop bx
   370 000001A6 5A                  <1>   pop dx
   371 000001A7 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   372 000001A9 D1E6                <1>   shl si,1                  ; *=2
   373 000001AB D1E6                <1>   shl si,1                  ; *=2  
   374 000001AD BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   375 000001B0 29F5                <1>   sub bp,si
   376 000001B2 3EC64600FF          <1>   mov byte [ds:bp],-1
   377 000001B7 C3                  <1>   ret
   378                              <1> 
   379                              <1> ; clear_red:
   380                              <1> ;   mov ax,RED
   381                              <1> ;   call clear_channel
   382                              <1> ;   ret
   383                              <1> 
   384                              <1> clear_green:
   385 000001B8 B8001C              <1>   mov ax,GREEN
   386 000001BB E80100              <1>   call clear_channel
   387 000001BE C3                  <1>   ret
   388                              <1> 
   389                              <1> ; clear_blue:
   390                              <1> ;   mov ax,BLUE
   391                              <1> ;   call clear_channel
   392                              <1> ;   ret
   393                              <1> 
   394                              <1> ; clear_screen:
   395                              <1> ;   call clear_red
   396                              <1> ;   call clear_green
   397                              <1> ;   call clear_blue
   398                              <1> ;   ret
   399                              <1> 
   400                              <1> clear_channel:
   401 000001BF 8EC0                <1>   mov es,ax
   402 000001C1 B9201C              <1>   mov cx,COLS*ROWS*2
   403 000001C4 31FF                <1>   xor di,di
   404 000001C6 31C0                <1>   xor ax,ax
   405 000001C8 F3AB                <1>   rep stosw         ; clear screen
   406 000001CA C3                  <1>   ret
   407                              <1> 
   408                              <1> ; ───────────────────────────────────────────────────────────────────────────
   409                              <1> 
   410                              <1> ; write_char:   ; ds=FONT, es=GREEN, al=charcode
   411                              <1> ;   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   412                              <1> ;   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   413                              <1> ;   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   414                              <1> 
   415                              <1> ;   push ds
   416                              <1> ;   push es
   417                              <1> ;   push ax
   418                              <1> ;   push bx
   419                              <1> ;   push cx
   420                              <1> 
   421                              <1> ;   push ax
   422                              <1> ;   mov ax,GREEN
   423                              <1> ;   mov es,ax
   424                              <1> ;   mov ax,FONT
   425                              <1> ;   mov ds,ax
   426                              <1> ;   pop ax
   427                              <1> 
   428                              <1> ;   ; mov ax,65*8
   429                              <1> ;   ; mov al,'x'
   430                              <1> ;   mov ah,8
   431                              <1> ;   mul ah        ; ax=al*ah
   432                              <1> 
   433                              <1> ;   mov si,ax
   434                              <1> ;   movsw
   435                              <1> ;   movsw
   436                              <1> ;   add di,0x11c
   437                              <1> ;   movsw
   438                              <1> ;   movsw
   439                              <1> ;   mov bx,288
   440                              <1> ;   sub di,bx
   441                              <1>   
   442                              <1> ;   ; pop ax
   443                              <1> ;   ; pop es
   444                              <1> ;   ; pop ds
   445                              <1> ;   ; ret
   446                              <1> 
   447                              <1> 
   448                              <1> ;   ; row snap
   449                              <1> ;   xor dx,dx
   450                              <1> ;   mov ax,di
   451                              <1> ;   div bx
   452                              <1> ;   cmp dx,0
   453                              <1> ;   jne .return
   454                              <1> ;   add di,bx
   455                              <1> 
   456                              <1> 
   457                              <1> ;   ; wrap to top
   458                              <1> ;   cmp di,14400   ; dit later oplossen met cursor positie
   459                              <1> ;   jb .return
   460                              <1> ;   ; xor di,di      ; move to left top. change later to scroll
   461                              <1> 
   462                              <1> ;   ; TODO: call scroll_down
   463                              <1> ;   ; std
   464                              <1> ;   ; push di
   465                              <1> ;   ; push cx
   466                              <1> ;   ; mov cx,4*72*24
   467                              <1> ;   ; mov ax,0
   468                              <1> ;   ; rep stosw
   469                              <1> ;   ; pop cx
   470                              <1> ;   ; pop di
   471                              <1> ;   ; cld
   472                              <1> 
   473                              <1> ;   ; DONE: clear last line
   474                              <1> ;   sub di,bx
   475                              <1> ;   sub di,bx
   476                              <1> ;   push di
   477                              <1> ;   push cx
   478                              <1> ;   mov cx,COLS*ROWS*2
   479                              <1> ;   xor ax,ax
   480                              <1> ;   rep stosw         ; clear screen
   481                              <1> ;   pop cx
   482                              <1> ;   pop di
   483                              <1> 
   484                              <1> ; .return
   485                              <1> ;   push bx
   486                              <1> ;   push cx
   487                              <1> ;   pop ax
   488                              <1> ;   pop es
   489                              <1> ;   pop ds
   490                              <1> ;   ret
   491                              <1> 
   492                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   493                              <1> 
   494                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   495 000001CB 52                  <1>   push dx
   496 000001CC 1E                  <1>   push ds
   497 000001CD 06                  <1>   push es
   498 000001CE 50                  <1>   push ax
   499 000001CF 53                  <1>   push bx
   500 000001D0 31D2                <1>   xor dx,dx
   501 000001D2 50                  <1>   push ax  ; voor character pop
   502 000001D3 B8001C              <1>   mov ax,GREEN
   503 000001D6 8EC0                <1>   mov es,ax
   504 000001D8 B800FF              <1>   mov ax,FONT
   505 000001DB 8ED8                <1>   mov ds,ax
   506 000001DD 58                  <1>   pop ax
   507 000001DE B408                <1>   mov ah,8
   508 000001E0 F6E4                <1>   mul ah        ; al*=ah
   509 000001E2 89C6                <1>   mov si,ax  
   510                              <1> 
   511 000001E4 A5                  <1>   movsw
   512 000001E5 A5                  <1>   movsw
   513 000001E6 81C71C01            <1>   add di,0x11c
   514 000001EA A5                  <1>   movsw
   515 000001EB A5                  <1>   movsw
   516 000001EC 81EF2001            <1>   sub di,0x120
   517                              <1> 
   518                              <1> 
   519                              <1>   ; cmp di,14400   ; dit later oplossen met cursor positie
   520                              <1>   ; jb .return
   521                              <1>   ; xor di,di      ; move to left top. change later to scroll
   522                              <1> 
   523                              <1>   ; row snap
   524 000001F0 BB2001              <1>   mov bx,288   ; /////////// dit gaf problemen waarsch omdat bx niet gepushed werd
   525 000001F3 31D2                <1>   xor dx,dx
   526 000001F5 89F8                <1>   mov ax,di
   527 000001F7 F7F3                <1>   div bx       ; ///dit ook als BX 0 is
   528 000001F9 83FA00              <1>   cmp dx,0
   529 000001FC 7502                <1>   jne .return
   530 000001FE 01DF                <1>   add di,bx
   531                              <1> 
   532                              <1> .return
   533 00000200 5B                  <1>   pop bx
   534 00000201 58                  <1>   pop ax
   535 00000202 07                  <1>   pop es
   536 00000203 1F                  <1>   pop ds
   537 00000204 5A                  <1>   pop dx
   538 00000205 C3                  <1>   ret
   539                              <1> 
   540                              <1> write_string:
   541 00000206 2E8A07              <1>   mov al,[cs:bx]
   542 00000209 43                  <1>   inc bx
   543 0000020A 08C0                <1>   or al,al
   544 0000020C 7405                <1>   jz .return
   545 0000020E E8BAFF              <1>   call write_char
   546 00000211 EBF3                <1>   jmp short write_string
   547                              <1> .return
   548 00000213 C3                  <1>   ret
   549                              <1> 
   550                              <1> ; ───────────────────────────────────────────────────────────────────────────
   551                              <1> 
   552                              <1> write_binary_byte:    ; input AL
   553 00000214 53                  <1>   push bx
   554 00000215 51                  <1>   push cx
   555 00000216 50                  <1>   push ax
   556 00000217 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   557 00000219 B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   558                              <1> .lp:
   559 0000021C D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   560 0000021E B80000              <1>   mov ax, 0           ; AH leegmaken
   561 00000221 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   562 00000223 51                  <1>   push cx             ; CX opslaan
   563 00000224 E8A4FF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   564 00000227 59                  <1>   pop cx              ; CX herstellen
   565 00000228 E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   566 0000022A 58                  <1>   pop ax
   567 0000022B 59                  <1>   pop cx
   568 0000022C 5B                  <1>   pop bx
   569 0000022D C3                  <1>   ret
   570                              <1> 
   571                              <1> ; ───────────────────────────────────────────────────────────────────────────
   572                              <1> 
   573                              <1> write_binary_word:    ; input AX
   574 0000022E 51                  <1>   push cx
   575 0000022F 50                  <1>   push ax
   576 00000230 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   577 00000231 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   578 00000233 B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   579                              <1> .lp:
   580 00000236 D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   581 00000238 B80000              <1>   mov ax, 0          ; AH leegmaken
   582 0000023B 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   583 0000023D 51                  <1>   push cx            ; CX opslaan
   584 0000023E E88AFF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   585 00000241 59                  <1>   pop cx             ; CX herstellen
   586 00000242 E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   587 00000244 5A                  <1>   pop dx             ; DX herstellen
   588 00000245 58                  <1>   pop ax
   589 00000246 59                  <1>   pop cx
   590 00000247 C3                  <1>   ret
   591                              <1> 
   592                              <1> 
   593                              <1> ; ───────────────────────────────────────────────────────────────────────────
   594                              <1> 
   595                              <1> write_number_word:
   596 00000248 50                  <1>     push ax
   597 00000249 52                  <1>     push dx
   598 0000024A 31D2                <1>     xor dx,dx
   599 0000024C 52                  <1>     push dx ;high byte is zero
   600 0000024D 31D2                <1> .clp xor dx,dx
   601 0000024F 2EF736[6B02]        <1>     cs div word [.base]
   602 00000254 92                  <1>     xchg ax,dx
   603 00000255 05300E              <1>     add ax,0xe30
   604 00000258 50                  <1>     push ax
   605 00000259 92                  <1>     xchg ax,dx
   606 0000025A 09C0                <1>     or ax,ax
   607 0000025C 75EF                <1>     jnz .clp
   608 0000025E 58                  <1> .dlp pop ax
   609 0000025F 08E4                <1>     or ah,ah
   610 00000261 7405                <1>     jz .done
   611 00000263 E865FF              <1>     call write_char
   612 00000266 EBF6                <1>     jmp short .dlp
   613 00000268 5A                  <1> .done pop dx
   614 00000269 58                  <1>     pop ax
   615 0000026A C3                  <1>     ret
   616 0000026B 0A00                <1> .base dw 10
   617                              <1> 
   618                              <1> ; ───────────────────────────────────────────────────────────────────────────
   619                              <1> 
   620                              <1> write_number_dword:
   621                              <1>     ;https://stackoverflow.com/questions/45904075/displaying-numbers-with-dos/45904076#45904076
   622 0000026D 50                  <1>     push ax          ;me
   623 0000026E 53                  <1>     push bx          ;me
   624 0000026F 51                  <1>     push cx          ;me
   625 00000270 52                  <1>     push dx          ;me
   626                              <1> 
   627 00000271 BB0A00              <1>     mov     bx,10          ;CONST
   628 00000274 53                  <1>     push    bx             ;Sentinel
   629 00000275 89C1                <1> .a: mov     cx,ax          ;Temporarily store LowDividend in CX
   630 00000277 89D0                <1>     mov     ax,dx          ;First divide the HighDividend
   631 00000279 31D2                <1>     xor     dx,dx          ;Setup for division DX:AX / BX
   632 0000027B F7F3                <1>     div     bx             ; -> AX is HighQuotient, Remainder is re-used
   633 0000027D 91                  <1>     xchg    ax,cx          ;Temporarily move it to CX restoring LowDividend
   634 0000027E F7F3                <1>     div     bx             ; -> AX is LowQuotient, Remainder DX=[0,9]
   635 00000280 52                  <1>     push    dx             ;(1) Save remainder for now
   636 00000281 89CA                <1>     mov     dx,cx          ;Build true 32-bit quotient in DX:AX
   637 00000283 09C1                <1>     or      cx,ax          ;Is the true 32-bit quotient zero?
   638 00000285 75EE                <1>     jnz     .a             ;No, use as next dividend
   639 00000287 5A                  <1>     pop     dx             ;(1a) First pop (Is digit for sure)
   640 00000288 80C230              <1> .b: add     dl,"0"         ;Turn into character [0,9] -> ["0","9"]
   641                              <1>     
   642 0000028B 86D0                <1>     xchg    al,dl        ;me
   643 0000028D E83BFF              <1>     call    write_char   ;me
   644 00000290 86D0                <1>     xchg    al,dl        ;me
   645                              <1>     
   646 00000292 5A                  <1>     pop     dx             ;(1b) All remaining pops
   647 00000293 39DA                <1>     cmp     dx,bx          ;Was it the sentinel?
   648 00000295 72F1                <1>     jb      .b             ;Not yet
   649                              <1> 
   650 00000297 5A                  <1>     pop dx         ;me
   651 00000298 59                  <1>     pop cx         ;me
   652 00000299 5B                  <1>     pop bx         ;me
   653 0000029A 58                  <1>     pop ax         ;me
   654 0000029B C3                  <1>     ret
   655                              <1> 
   656                              <1> 
   657                              <1> ; ───────────────────────────────────────────────────────────────────────────
   658                              <1> 
   659                              <1> write_signed_number_word:  
   660 0000029C 50                  <1>     push ax
   661 0000029D 09C0                <1>     or ax,ax
   662 0000029F 790A                <1>     jns .write_return        ; if >0 write and return
   663 000002A1 50                  <1>     push ax
   664 000002A2 B82D00              <1>     mov ax,'-'
   665 000002A5 E823FF              <1>     call write_char
   666 000002A8 58                  <1>     pop ax
   667 000002A9 F7D8                <1>     neg ax                   ; destroys ax when negative
   668                              <1> .write_return:
   669 000002AB E89AFF              <1>     call write_number_word
   670 000002AE 58                  <1>     pop ax
   671 000002AF C3                  <1>     ret
   672                              <1> 
   673                              <1> ; ───────────────────────────────────────────────────────────────────────────
   674                              <1> 
   675                              <1> check_keys:
   676 000002B0 E43A                <1>   in al,0x3a        ; get keyboard status
   677 000002B2 88C4                <1>   mov ah,al
   678 000002B4 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   679 000002B6 2EA2[0600]          <1>   mov [cs:key.ctrl],al
   680 000002BA F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   681 000002BD 7410                <1>   jz .return
   682 000002BF E438                <1>   in al,0x38        ; get data byte from keyboard  
   683 000002C1 2EA2[0500]          <1>   mov [cs:key.code],al
   684 000002C5 B037                <1>   mov al,0x37
   685 000002C7 E63A                <1>   out 0x3a,al       ; drop key?  
   686 000002C9 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   687 000002CB 2EA1[0500]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   688 000002CF C3                  <1> .return ret
   689                              <1> 
   690                              <1> 
   691                              <1> 
   692                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   693                              <1> ;   ret
   694                              <1> 
   695                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   696                              <1> 
   697                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   698                              <1> ; much faster and simpler on the grid than off the grid
   699                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   700                              <1> 
   701                              <1> 
   702                              <1> ; wide font by stretching the font horizontally using bitshift
   703                              <1> 
   704                              <1> 
   705                              <1> ; fill_white:
   706                              <1> ;   mov ax,0xffff
   707                              <1> ;   call fill_red
   708                              <1> ;   call fill_green
   709                              <1> ;   call fill_blue
   710                              <1> ;   ret
   711                              <1> 
   712                              <1> ; fill_pink:
   713                              <1> ;   mov ax,0xffff
   714                              <1> ;   call fill_red
   715                              <1> ;   mov ah,0b01010101
   716                              <1> ;   mov al,0b10101010
   717                              <1> ;   call fill_green
   718                              <1> ;   call fill_blue
   719                              <1> ;   ret
   720                              <1> 
   721                              <1> ; fill_pink2:
   722                              <1> ;   mov ax,0xffff
   723                              <1> ;   call fill_red
   724                              <1> ;   mov ah,0b11001100
   725                              <1> ;   mov al,0b00110011
   726                              <1> ;   call fill_green
   727                              <1> ;   call fill_blue
   728                              <1> ;   ret
   729                              <1> 
   730                              <1> ; fill_pink3:
   731                              <1> ;   mov ax,0xffff
   732                              <1> ;   call fill_red
   733                              <1> ;   mov ah,0b00010001
   734                              <1> ;   mov al,0b01000100
   735                              <1> ;   call fill_green
   736                              <1> ;   call fill_blue
   737                              <1> ;   ret
   738                              <1> 
   739                              <1> ; fill_pink4:
   740                              <1> ;   mov ax,0xffff
   741                              <1> ;   call fill_red
   742                              <1> ;   mov ah,0b11110111
   743                              <1> ;   mov al,0b01111111
   744                              <1> ;   call fill_green
   745                              <1> ;   call fill_blue
   746                              <1> ;   ret
   747                              <1> 
   748                              <1> ; fill_red:
   749                              <1> ;   mov bx,RED
   750                              <1> ;   call fill_channel
   751                              <1> ;   ret
   752                              <1> ; fill_green:
   753                              <1> ;   mov bx,GREEN
   754                              <1> ;   call fill_channel
   755                              <1> ;   ret
   756                              <1> ; fill_blue:
   757                              <1> ;   mov bx,BLUE
   758                              <1> ;   call fill_channel
   759                              <1> ;   ret
   760                              <1> 
   761                              <1> ; fill_channel: ;ax=pattern
   762                              <1> ;   mov es,bx
   763                              <1> ;   mov cx,COLS*ROWS*2
   764                              <1> ;   xor di,di
   765                              <1> ;   rep stosw
   766                              <1> ;   ret
   767                              <1> 
   768                              <1> ; ───────────────────────────────────────────────────────────────────────────
   769                              <1> 
   770                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   771                              <1> ;   push bx
   772                              <1> ;   push di
   773                              <1> ;   mov es,ax
   774                              <1> ;   xor cx,cx
   775                              <1> ;   mov cl,bh        ; rows (bl)
   776                              <1> ; .rows_loop:
   777                              <1> ;   push cx
   778                              <1> ;   xor cx,cx
   779                              <1> ;   mov cl,bl        ; cols (bh)
   780                              <1> ; .cols_loop:
   781                              <1> ;   mov ax,0
   782                              <1> ;   stosw
   783                              <1> ;   stosw
   784                              <1> ;   loop .cols_loop
   785                              <1> ;   add di,COLS*4    ; one row down
   786                              <1> ;   mov ah,0
   787                              <1> ;   mov al,bl
   788                              <1> ;   times 2 shl ax,1
   789                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   790                              <1> ;   pop cx
   791                              <1> ;   loop .rows_loop
   792                              <1> ;   pop di
   793                              <1> ;   pop bx
   794                              <1> ;   ret
   795                              <1> 
   796                              <1> ; ───────────────────────────────────────────────────────────────────────────
   797                              <1> 
   798                              <1> ; fill_rect_black: 
   799                              <1> ;   mov ax,RED
   800                              <1> ;   call clear_area
   801                              <1> ;   mov ax,GREEN
   802                              <1> ;   call clear_area
   803                              <1> ;   mov ax,BLUE
   804                              <1> ;   call clear_area
   805                              <1> ;   ret
   806                              <1> 
   807                              <1> ; ───────────────────────────────────────────────────────────────────────────
   808                              <1> 
   809                              <1> draw_spr:
   810 000002D0 53                  <1>   push bx
   811 000002D1 8B1C                <1>   mov bx,[si]
   812 000002D3 46                  <1>   inc si
   813 000002D4 46                  <1>   inc si
   814 000002D5 E80200              <1>   call draw_pic
   815 000002D8 5B                  <1>   pop bx
   816 000002D9 C3                  <1>   ret
   817                              <1> 
   818                              <1> draw_pic:
   819 000002DA 50                  <1>   push ax
   820 000002DB B800F0              <1>   mov ax, RED
   821 000002DE E80E00              <1>   call draw_channel
   822 000002E1 B8001C              <1>   mov ax, GREEN
   823 000002E4 E80800              <1>   call draw_channel
   824 000002E7 B800F4              <1>   mov ax, BLUE
   825 000002EA E80200              <1>   call draw_channel
   826 000002ED 58                  <1>   pop ax
   827 000002EE C3                  <1>   ret
   828                              <1> 
   829                              <1> ; ───────────────────────────────────────────────────────────────────────────
   830                              <1> 
   831                              <1> draw_channel:
   832 000002EF 57                  <1>   push di
   833 000002F0 8EC0                <1>   mov es,ax
   834 000002F2 31C9                <1>   xor cx,cx
   835 000002F4 88F9                <1>   mov cl,bh        ; rows (bl)
   836                              <1> .rows_loop:
   837 000002F6 51                  <1>   push cx
   838 000002F7 31C9                <1>   xor cx,cx
   839 000002F9 88D9                <1>   mov cl,bl        ; cols (bh)
   840                              <1> .cols_loop:
   841 000002FB A5                  <1>   movsw
   842 000002FC A5                  <1>   movsw
   843 000002FD E2FC                <1>   loop .cols_loop
   844 000002FF 81C72001            <1>   add di,COLS*4    ; one row down
   845 00000303 B400                <1>   mov ah,0
   846 00000305 88D8                <1>   mov al,bl
   847 00000307 D1E0<rep 2h>        <1>   times 2 shl ax,1
   848 0000030B 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   849 0000030D 59                  <1>   pop cx
   850 0000030E E2E6                <1>   loop .rows_loop
   851 00000310 5F                  <1>   pop di
   852 00000311 C3                  <1>   ret
   853                              <1> 
   854                              <1> ; ───────────────────────────────────────────────────────────────────────────
   855                              <1> 
   856                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   857 00000312 B89000              <1>   mov ax,144      ; 2*72 cols
   858 00000315 F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   859 00000317 D1E0                <1>   shl ax,1        ; verdubbel AX
   860 00000319 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   861 0000031B D0E3                <1>   shl bl,1        ; bl*=2
   862 0000031D D0E3                <1>   shl bl,1        ; bl*=2
   863 0000031F B700                <1>   mov bh,0
   864 00000321 01DF                <1>   add di,bx       ; di+=bl
   865 00000323 83FF00              <1>   cmp di,0
   866 00000326 7C01                <1>   jl .clamp_top
   867 00000328 C3                  <1>   ret
   868                              <1> .clamp_top
   869 00000329 31FF                <1>   xor di,di
   870 0000032B C3                  <1>   ret
   871                              <1> 
   872                              <1> 
   873                              <1> ; ───────────────────────────────────────────────────────────────────────────
   874                              <1> 
   875                              <1> new_line:         ; find the value of DI at start of the next line
   876 0000032C 50                  <1>   push ax
   877 0000032D 53                  <1>   push bx
   878 0000032E 52                  <1>   push dx
   879 0000032F BB2001              <1>   mov bx,288
   880 00000332 31D2                <1>   xor dx,dx
   881 00000334 89F8                <1>   mov ax,di
   882 00000336 F7F3                <1>   div bx
   883 00000338 31D2                <1>   xor dx,dx       ; cwd?
   884 0000033A BB2001              <1>   mov bx,288      ; can reuse x from above?
   885 0000033D 40                  <1>   inc ax
   886 0000033E F7E3                <1>   mul bx
   887 00000340 052001              <1>   add ax,288      ; use bx?
   888 00000343 89C7                <1>   mov di,ax
   889 00000345 5A                  <1>   pop dx
   890 00000346 5B                  <1>   pop bx
   891 00000347 58                  <1>   pop ax
   892 00000348 C3                  <1>   ret
   893                              <1> 
   894                              <1> ; ───────────────────────────────────────────────────────────────────────────
   895                              <1> 
   896                              <1> write_ax_hex:
   897 00000349 50                  <1>   push ax
   898 0000034A 52                  <1>   push dx
   899 0000034B 31D2                <1>   xor dx,dx
   900 0000034D 52                  <1>   push dx ;high byte is zero
   901 0000034E 31D2                <1> .clp xor dx,dx
   902 00000350 2EF736[7203]        <1>   cs div word [.base]
   903 00000355 92                  <1>   xchg ax,dx
   904 00000356 3C0A                <1>   cmp al,10
   905 00000358 7202                <1>   jb .l1     ; 0-9
   906 0000035A 0407                <1>   add al,7   ; A-F
   907 0000035C 05300E              <1> .l1 add ax,0xe30
   908 0000035F 50                  <1>   push ax
   909 00000360 92                  <1>   xchg ax,dx
   910 00000361 09C0                <1>   or ax,ax
   911 00000363 75E9                <1>   jnz .clp
   912 00000365 58                  <1> .dlp pop ax
   913 00000366 08E4                <1>   or ah,ah
   914 00000368 7405                <1>   jz .done
   915 0000036A E85EFE              <1>   call write_char
   916 0000036D EBF6                <1>   jmp short .dlp
   917 0000036F 5A                  <1> .done pop dx
   918 00000370 58                  <1>   pop ax
   919 00000371 C3                  <1>   ret
   920 00000372 1000                <1> .base dw 16
   921                              <1> 
   922                              <1> ; calc_di_from_cursor:  ; input cursor, output di
   923                              <1> ;   mov ax,[cursor] 
   924                              <1> ;   sub ax,0x0101   ; cursor is 1 based
   925                              <1> ;   xchg ax,bx      ; bx=ax
   926                              <1> ;   mov ax,144      ; 2*72 cols
   927                              <1> ;   mul bh          ; bh*=144 resultaat in AX
   928                              <1> ;   shl ax,1        ; verdubbel AX
   929                              <1> ;   shl ax,1        ; verdubbel AX
   930                              <1> ;   mov di,ax       ; di=ax (=bh*288)
   931                              <1> ;   shl bl,1        ; bl*=2
   932                              <1> ;   shl bl,1        ; bl*=2
   933                              <1> ;   mov bh,0
   934                              <1> ;   add di,bx       ; di+=bl
   935                              <1> ;   ret
   936                              <1> 
   937                              <1> 
   938                              <1> 
   939                              <1> 
   940                              <1> ; als je cursor gebruikt is dit missch niet nodig.
   941                              <1> ; row_snap:  ; this code detects if DI is in between rows. When DI goes to the next half row it converts it to a whole row.
   942                              <1> ;   push ax
   943                              <1> ;   push bx
   944                              <1> ;   push dx
   945                              <1> ;   mov bx,288
   946                              <1> ;   mov ax,di
   947                              <1> ;   cwd ; xor dx,dx
   948                              <1> ;   div bx
   949                              <1> ;   jnp .done  ; if ax%288==0 
   950                              <1> ;   add di,bx
   951                              <1> ;   .done
   952                              <1> ;   ; add di,dx
   953                              <1> ;   pop dx
   954                              <1> ;   pop bx
   955                              <1> ;   pop ax
   956                              <1> ;   ret
   957                              <1> 
   958                              <1> 
   959                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   960                              <1> 
   961                              <1> ; calc_di_from_cursor_index:  ; index is cursor index from 0 tot 72*25
   962                              <1> ;   push ax
   963                              <1> ;   push bx
   964                              <1> ;   push dx
   965                              <1> ;   xor dx,dx
   966                              <1> ;   mov ax,[cursor.index]
   967                              <1> ;   mov bx,72
   968                              <1> ;   div bx       ; ax=rows
   969                              <1> ;   push dx      ; dx=cols
   970                              <1> ;   xor dx,dx    ; clear dx for multiplication
   971                              <1> ;   mov bx,576
   972                              <1> ;   mul bx       ; ax contains DI position for row
   973                              <1> ;   mov di,ax
   974                              <1> ;   pop ax       ; ax now contains cols
   975                              <1> ;   shl ax,1     ; *=2
   976                              <1> ;   shl ax,1     ; *=2
   977                              <1> ;   add di,ax
   978                              <1> ;   pop dx
   979                              <1> ;   pop bx
   980                              <1> ;   pop ax
   981                              <1> ;   ret
   982                              <1> 
   983                              <1> ; ───────────────────────────────────────────────────────────────────────────
   984                              <1> 
   985                              <1> 
   986                              <1> ; set_cursor:
   987                              <1> ; cursor_next_char
   988                              <1> 
   989                              <1> 
   990                              <1> 
   991                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   992                              <1> 
     2                                  %include "debug.asm"
     1                              <1> 
     2                              <1> draw_debug_info:
     3                              <1>   
     4                              <1>   set_cursor 1,1
    43                              <2> 
    44 00000374 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
     5                              <1> 
     6                              <1>   print "key: "
    48 00000377 50                  <2>  push ax
    49 00000378 53                  <2>  push bx
    50 00000379 51                  <2>  push cx
    51 0000037A 52                  <2>  push dx
    52 0000037B EB06                <2>  jmp %%endstr
    53 0000037D 6B65793A2000        <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000383 BB[7D03]            <2>  mov bx,%%str
    56 00000386 E87DFE              <2>  call write_string
    57 00000389 5A                  <2>  pop dx
    58 0000038A 59                  <2>  pop cx
    59 0000038B 5B                  <2>  pop bx
    60 0000038C 58                  <2>  pop ax
     7 0000038D A1[0500]            <1>   mov ax,[key]
     8                              <1>   println_ax_bin
   117                              <2>  print_ax_bin
    81 00000390 E89BFE              <3>  call write_binary_word
   118 00000393 E871FC              <2>  call write_5spaces_newline
     9                              <1> 
    10                              <1>   print "frame: "
    48 00000396 50                  <2>  push ax
    49 00000397 53                  <2>  push bx
    50 00000398 51                  <2>  push cx
    51 00000399 52                  <2>  push dx
    52 0000039A EB08                <2>  jmp %%endstr
    53 0000039C 6672616D653A2000    <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003A4 BB[9C03]            <2>  mov bx,%%str
    56 000003A7 E85CFE              <2>  call write_string
    57 000003AA 5A                  <2>  pop dx
    58 000003AB 59                  <2>  pop cx
    59 000003AC 5B                  <2>  pop bx
    60 000003AD 58                  <2>  pop ax
    11 000003AE A1[1E0A]            <1>   mov ax,[frame_count]
    12                              <1>   println_ax
   102                              <2>  print_ax
    69 000003B1 E8E8FE              <3>  call write_signed_number_word
   103 000003B4 E850FC              <2>  call write_5spaces_newline
    13                              <1> 
    14                              <1>   print "x+: "
    48 000003B7 50                  <2>  push ax
    49 000003B8 53                  <2>  push bx
    50 000003B9 51                  <2>  push cx
    51 000003BA 52                  <2>  push dx
    52 000003BB EB05                <2>  jmp %%endstr
    53 000003BD 782B3A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003C2 BB[BD03]            <2>  mov bx,%%str
    56 000003C5 E83EFE              <2>  call write_string
    57 000003C8 5A                  <2>  pop dx
    58 000003C9 59                  <2>  pop cx
    59 000003CA 5B                  <2>  pop bx
    60 000003CB 58                  <2>  pop ax
    15 000003CC A1[F209]            <1>   mov ax,[ship.pos.x]  
    16                              <1>   println_ax_unsigned
   107                              <2>  print_ax_unsigned
    73 000003CF E876FE              <3>  call write_number_word
   108 000003D2 E832FC              <2>  call write_5spaces_newline
    17                              <1> 
    18                              <1>   print "y+: "
    48 000003D5 50                  <2>  push ax
    49 000003D6 53                  <2>  push bx
    50 000003D7 51                  <2>  push cx
    51 000003D8 52                  <2>  push dx
    52 000003D9 EB05                <2>  jmp %%endstr
    53 000003DB 792B3A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003E0 BB[DB03]            <2>  mov bx,%%str
    56 000003E3 E820FE              <2>  call write_string
    57 000003E6 5A                  <2>  pop dx
    58 000003E7 59                  <2>  pop cx
    59 000003E8 5B                  <2>  pop bx
    60 000003E9 58                  <2>  pop ax
    19 000003EA A1[F409]            <1>   mov ax,[ship.pos.y]
    20                              <1>   println_ax_unsigned
   107                              <2>  print_ax_unsigned
    73 000003ED E858FE              <3>  call write_number_word
   108 000003F0 E814FC              <2>  call write_5spaces_newline
    21                              <1> 
    22                              <1>   print "vx: "
    48 000003F3 50                  <2>  push ax
    49 000003F4 53                  <2>  push bx
    50 000003F5 51                  <2>  push cx
    51 000003F6 52                  <2>  push dx
    52 000003F7 EB05                <2>  jmp %%endstr
    53 000003F9 76783A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000003FE BB[F903]            <2>  mov bx,%%str
    56 00000401 E802FE              <2>  call write_string
    57 00000404 5A                  <2>  pop dx
    58 00000405 59                  <2>  pop cx
    59 00000406 5B                  <2>  pop bx
    60 00000407 58                  <2>  pop ax
    23 00000408 A1[FA09]            <1>   mov ax,[ship.vel.x]  
    24                              <1>   println_ax
   102                              <2>  print_ax
    69 0000040B E88EFE              <3>  call write_signed_number_word
   103 0000040E E8F6FB              <2>  call write_5spaces_newline
    25                              <1> 
    26                              <1>   print "vy: "
    48 00000411 50                  <2>  push ax
    49 00000412 53                  <2>  push bx
    50 00000413 51                  <2>  push cx
    51 00000414 52                  <2>  push dx
    52 00000415 EB05                <2>  jmp %%endstr
    53 00000417 76793A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 0000041C BB[1704]            <2>  mov bx,%%str
    56 0000041F E8E4FD              <2>  call write_string
    57 00000422 5A                  <2>  pop dx
    58 00000423 59                  <2>  pop cx
    59 00000424 5B                  <2>  pop bx
    60 00000425 58                  <2>  pop ax
    27 00000426 A1[FC09]            <1>   mov ax,[ship.vel.y]
    28                              <1>   println_ax
   102                              <2>  print_ax
    69 00000429 E870FE              <3>  call write_signed_number_word
   103 0000042C E8D8FB              <2>  call write_5spaces_newline
    29                              <1> 
    30                              <1>   print "vel.magSq: "
    48 0000042F 50                  <2>  push ax
    49 00000430 53                  <2>  push bx
    50 00000431 51                  <2>  push cx
    51 00000432 52                  <2>  push dx
    52 00000433 EB0C                <2>  jmp %%endstr
    53 00000435 76656C2E6D61675371- <2>  %%str: db %1,0
    53 0000043E 3A2000              <2>
    54                              <2>  %%endstr:
    55 00000441 BB[3504]            <2>  mov bx,%%str
    56 00000444 E8BFFD              <2>  call write_string
    57 00000447 5A                  <2>  pop dx
    58 00000448 59                  <2>  pop cx
    59 00000449 5B                  <2>  pop bx
    60 0000044A 58                  <2>  pop ax
    31 0000044B A1[000A]            <1>   mov ax,[ship.vel.magSq]
    32                              <1>   println_ax_unsigned
   107                              <2>  print_ax_unsigned
    73 0000044E E8F7FD              <3>  call write_number_word
   108 00000451 E8B3FB              <2>  call write_5spaces_newline
    33                              <1> 
    34                              <1>   print "angle: "
    48 00000454 50                  <2>  push ax
    49 00000455 53                  <2>  push bx
    50 00000456 51                  <2>  push cx
    51 00000457 52                  <2>  push dx
    52 00000458 EB08                <2>  jmp %%endstr
    53 0000045A 616E676C653A2000    <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000462 BB[5A04]            <2>  mov bx,%%str
    56 00000465 E89EFD              <2>  call write_string
    57 00000468 5A                  <2>  pop dx
    58 00000469 59                  <2>  pop cx
    59 0000046A 5B                  <2>  pop bx
    60 0000046B 58                  <2>  pop ax
    35 0000046C A1[0E0A]            <1>   mov ax,[ship.angle] 
    36                              <1>   println_ax
   102                              <2>  print_ax
    69 0000046F E82AFE              <3>  call write_signed_number_word
   103 00000472 E892FB              <2>  call write_5spaces_newline
    37                              <1> 
    38                              <1>   print "index: "
    48 00000475 50                  <2>  push ax
    49 00000476 53                  <2>  push bx
    50 00000477 51                  <2>  push cx
    51 00000478 52                  <2>  push dx
    52 00000479 EB08                <2>  jmp %%endstr
    53 0000047B 696E6465783A2000    <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000483 BB[7B04]            <2>  mov bx,%%str
    56 00000486 E87DFD              <2>  call write_string
    57 00000489 5A                  <2>  pop dx
    58 0000048A 59                  <2>  pop cx
    59 0000048B 5B                  <2>  pop bx
    60 0000048C 58                  <2>  pop ax
    39 0000048D A1[100A]            <1>   mov ax,[ship.sprite_index]
    40                              <1>   println_ax
   102                              <2>  print_ax
    69 00000490 E809FE              <3>  call write_signed_number_word
   103 00000493 E871FB              <2>  call write_5spaces_newline
    41                              <1> 
    42                              <1>   print "img addr: "
    48 00000496 50                  <2>  push ax
    49 00000497 53                  <2>  push bx
    50 00000498 51                  <2>  push cx
    51 00000499 52                  <2>  push dx
    52 0000049A EB0B                <2>  jmp %%endstr
    53 0000049C 696D6720616464723A- <2>  %%str: db %1,0
    53 000004A5 2000                <2>
    54                              <2>  %%endstr:
    55 000004A7 BB[9C04]            <2>  mov bx,%%str
    56 000004AA E859FD              <2>  call write_string
    57 000004AD 5A                  <2>  pop dx
    58 000004AE 59                  <2>  pop cx
    59 000004AF 5B                  <2>  pop bx
    60 000004B0 58                  <2>  pop ax
    43 000004B1 A1[120A]            <1>   mov ax,[ship.img_addr]
    44                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 000004B4 E892FE              <3>  call write_ax_hex
   113 000004B7 E84DFB              <2>  call write_5spaces_newline
    45                              <1> 
    46                              <1>   print "force.x: "
    48 000004BA 50                  <2>  push ax
    49 000004BB 53                  <2>  push bx
    50 000004BC 51                  <2>  push cx
    51 000004BD 52                  <2>  push dx
    52 000004BE EB0A                <2>  jmp %%endstr
    53 000004C0 666F7263652E783A20- <2>  %%str: db %1,0
    53 000004C9 00                  <2>
    54                              <2>  %%endstr:
    55 000004CA BB[C004]            <2>  mov bx,%%str
    56 000004CD E836FD              <2>  call write_string
    57 000004D0 5A                  <2>  pop dx
    58 000004D1 59                  <2>  pop cx
    59 000004D2 5B                  <2>  pop bx
    60 000004D3 58                  <2>  pop ax
    47 000004D4 A1[0A0A]            <1>   mov ax,[ship.force.x]
    48                              <1>   println_ax
   102                              <2>  print_ax
    69 000004D7 E8C2FD              <3>  call write_signed_number_word
   103 000004DA E82AFB              <2>  call write_5spaces_newline
    49                              <1> 
    50                              <1>   print "force.y: "
    48 000004DD 50                  <2>  push ax
    49 000004DE 53                  <2>  push bx
    50 000004DF 51                  <2>  push cx
    51 000004E0 52                  <2>  push dx
    52 000004E1 EB0A                <2>  jmp %%endstr
    53 000004E3 666F7263652E793A20- <2>  %%str: db %1,0
    53 000004EC 00                  <2>
    54                              <2>  %%endstr:
    55 000004ED BB[E304]            <2>  mov bx,%%str
    56 000004F0 E813FD              <2>  call write_string
    57 000004F3 5A                  <2>  pop dx
    58 000004F4 59                  <2>  pop cx
    59 000004F5 5B                  <2>  pop bx
    60 000004F6 58                  <2>  pop ax
    51 000004F7 A1[0C0A]            <1>   mov ax,[ship.force.y]
    52                              <1>   println_ax
   102                              <2>  print_ax
    69 000004FA E89FFD              <3>  call write_signed_number_word
   103 000004FD E807FB              <2>  call write_5spaces_newline
    53                              <1> 
    54                              <1>   print "forces.x: "
    48 00000500 50                  <2>  push ax
    49 00000501 53                  <2>  push bx
    50 00000502 51                  <2>  push cx
    51 00000503 52                  <2>  push dx
    52 00000504 EB0B                <2>  jmp %%endstr
    53 00000506 666F726365732E783A- <2>  %%str: db %1,0
    53 0000050F 2000                <2>
    54                              <2>  %%endstr:
    55 00000511 BB[0605]            <2>  mov bx,%%str
    56 00000514 E8EFFC              <2>  call write_string
    57 00000517 5A                  <2>  pop dx
    58 00000518 59                  <2>  pop cx
    59 00000519 5B                  <2>  pop bx
    60 0000051A 58                  <2>  pop ax
    55 0000051B A1[060A]            <1>   mov ax,[ship.forces.x]
    56                              <1>   println_ax
   102                              <2>  print_ax
    69 0000051E E87BFD              <3>  call write_signed_number_word
   103 00000521 E8E3FA              <2>  call write_5spaces_newline
    57                              <1> 
    58                              <1>   print "forces.y: "
    48 00000524 50                  <2>  push ax
    49 00000525 53                  <2>  push bx
    50 00000526 51                  <2>  push cx
    51 00000527 52                  <2>  push dx
    52 00000528 EB0B                <2>  jmp %%endstr
    53 0000052A 666F726365732E793A- <2>  %%str: db %1,0
    53 00000533 2000                <2>
    54                              <2>  %%endstr:
    55 00000535 BB[2A05]            <2>  mov bx,%%str
    56 00000538 E8CBFC              <2>  call write_string
    57 0000053B 5A                  <2>  pop dx
    58 0000053C 59                  <2>  pop cx
    59 0000053D 5B                  <2>  pop bx
    60 0000053E 58                  <2>  pop ax
    59 0000053F A1[080A]            <1>   mov ax,[ship.forces.y]
    60                              <1>   println_ax
   102                              <2>  print_ax
    69 00000542 E857FD              <3>  call write_signed_number_word
   103 00000545 E8BFFA              <2>  call write_5spaces_newline
    61                              <1> 
    62                              <1>   print "DI: "
    48 00000548 50                  <2>  push ax
    49 00000549 53                  <2>  push bx
    50 0000054A 51                  <2>  push cx
    51 0000054B 52                  <2>  push dx
    52 0000054C EB05                <2>  jmp %%endstr
    53 0000054E 44493A2000          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000553 BB[4E05]            <2>  mov bx,%%str
    56 00000556 E8ADFC              <2>  call write_string
    57 00000559 5A                  <2>  pop dx
    58 0000055A 59                  <2>  pop cx
    59 0000055B 5B                  <2>  pop bx
    60 0000055C 58                  <2>  pop ax
    63 0000055D 89F8                <1>   mov ax,di
    64                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 0000055F E8E7FD              <3>  call write_ax_hex
   113 00000562 E8A2FA              <2>  call write_5spaces_newline
    65                              <1> 
    66 00000565 C3                  <1>   ret
     3                                  %include "vector.asm"
     1                              <1> %include "math.asm"
     1                              <2> ; ───────────────────────────────────────────────────────────────────────────
     2                              <2> 
     3                              <2> xy_from_angle: ; input: ax=angle, (no magnitude!) output: ax:dx = x:y
     4 00000566 50                  <2>   push ax      ; save angle
     5 00000567 E81000              <2>   call sin
     6 0000056A 92                  <2>   xchg dx,ax
     7 0000056B 58                  <2>   pop ax       ; restore angle
     8 0000056C E82D00              <2>   call cos
     9 0000056F C3                  <2>   ret
    10                              <2> 
    11                              <2> ; ───────────────────────────────────────────────────────────────────────────
    12                              <2> 
    13                              <2> angle_wrap: ; makes any angle positive within 0..360
    14 00000570 09C0                <2>   or ax,ax
    15 00000572 7D05                <2>   jge .done
    16 00000574 056801              <2>   add ax,360
    17 00000577 EBF7                <2>   jmp angle_wrap
    18                              <2> .done
    19 00000579 C3                  <2>   ret
    20                              <2> 
    21                              <2> ; ───────────────────────────────────────────────────────────────────────────
    22                              <2> 
    23                              <2> sin: ; ax in degrees (pos or neg), returns sin(ax) -100..100
    24 0000057A 53                  <2>   push bx
    25 0000057B BB[8305]            <2>   mov bx,.lut
    26 0000057E E83D00              <2>   call angle_lookup
    27 00000581 5B                  <2>   pop bx
    28 00000582 C3                  <2>   ret
    29                              <2> .lut: 
    30 00000583 001932465660646056- <2>   db 0,25,50,70,86,96,100,96,86,70,50,25,0,-25,-50,-70,-86,-96,-100,-96,-86,-70,-50,-25,0
    30 0000058C 46321900E7CEBAAAA0- <2>
    30 00000595 9CA0AABACEE700      <2>
    31                              <2> 
    32                              <2> ; ───────────────────────────────────────────────────────────────────────────
    33                              <2> 
    34                              <2> cos: ; ax in degrees (pos or neg), returns sin(ax) -100..100
    35 0000059C 53                  <2>   push bx
    36 0000059D BB[A505]            <2>   mov bx,.lut
    37 000005A0 E81B00              <2>   call angle_lookup
    38 000005A3 5B                  <2>   pop bx
    39 000005A4 C3                  <2>   ret
    40                              <2> .lut: 
    41 000005A5 64605646321900E7CE- <2>   db 100,96,86,70,50,25,0,-25,-50,-70,-86,-96,-100,-96,-86,-70,-49,-25,0,25,49,70,86,96,100
    41 000005AE BAAAA09CA0AABACFE7- <2>
    41 000005B7 00193146566064      <2>
    42                              <2> 
    43                              <2> ; ───────────────────────────────────────────────────────────────────────────
    44                              <2> 
    45                              <2> angle_lookup: ; bx=lookup table, ax=angle (>=0) 0..360, result in ah
    46 000005BE E8AFFF              <2>   call angle_wrap ; makes angle between 0..360
    47 000005C1 52                  <2>   push dx
    48 000005C2 53                  <2>   push bx
    49 000005C3 99                  <2>   cwd ; clear dx (always 0 because angle wrap makes ax positive)
    50 000005C4 BB0F00              <2>   mov bx,15    ; ax/=15
    51 000005C7 F7F3                <2>   div bx
    52 000005C9 5B                  <2>   pop bx
    53 000005CA D7                  <2>   xlat
    54 000005CB 98                  <2>   cbw ; clear ah, except the sign if al is negative
    55 000005CC 5A                  <2>   pop dx
    56 000005CD C3                  <2>   ret
    57                              <2> 
    58                              <2> ; ───────────────────────────────────────────────────────────────────────────
    59                              <2> 
    60                              <2> atan2: ; input bx,ax=y,x, output ax=angle
    61 000005CE 83F800              <2>   cmp ax,0
    62 000005D1 750F                <2>   jnz .x_not_0
    63 000005D3 83FB00              <2>   cmp bx,0
    64 000005D6 7C05                <2>   jl .y_lte_0
    65 000005D8 B85A00              <2>   mov ax,90
    66 000005DB EB2E                <2>   jmp .ret
    67                              <2> 
    68                              <2> .y_lte_0:
    69 000005DD B8A6FF              <2>   mov ax,-90
    70 000005E0 EB29                <2>   jmp .ret
    71                              <2> 
    72                              <2> .x_not_0:
    73 000005E2 50                  <2>   push ax
    74 000005E3 50                  <2>   push ax   ; keep a copy of x
    75 000005E4 89D8                <2>   mov ax,bx
    76 000005E6 B96F00              <2>   mov cx,111
    77 000005E9 99                  <2>   cwd       ; dx=0
    78 000005EA F7E9                <2>   imul cx
    79 000005EC 59                  <2>   pop cx;   ; restore x
    80                              <2> 
    81 000005ED 99                  <2>   cwd
    82 000005EE F7F9                <2>   idiv cx   ; ax/=x
    83 000005F0 99                  <2>   cwd
    84 000005F1 E85200              <2>   call atan
    85 000005F4 59                  <2>   pop cx;   ; restore x
    86 000005F5 83F900              <2>   cmp cx,0
    87 000005F8 7C02                <2>   jl .x_lt_0
    88 000005FA EB0F                <2>   jmp .ret
    89                              <2> 
    90                              <2> .x_lt_0:
    91 000005FC 83FB00              <2>   cmp bx,0
    92 000005FF 7D05                <2>   jge .y_gte_0
    93 00000601 2DB400              <2>   sub ax,180
    94 00000604 EB05                <2>   jmp .ret
    95                              <2> 
    96                              <2> .y_gte_0:
    97 00000606 05B400              <2>   add ax,180
    98 00000609 EB00                <2>   jmp .ret
    99                              <2> 
   100                              <2> .ret:
   101 0000060B 83F800              <2>   cmp ax,0
   102 0000060E 7C01                <2>   jl .add360
   103 00000610 C3                  <2>   ret
   104                              <2> .add360:
   105 00000611 056801              <2>   add ax,360
   106 00000614 C3                  <2>   ret
   107                              <2> .error_x_0
   108                              <2>   set_cursor 1,1
    43                              <3> 
    44 00000615 BF0000              <3>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   109                              <2>   print "Division Error in atan2: x=0"
    48 00000618 50                  <3>  push ax
    49 00000619 53                  <3>  push bx
    50 0000061A 51                  <3>  push cx
    51 0000061B 52                  <3>  push dx
    52 0000061C EB1D                <3>  jmp %%endstr
    53 0000061E 4469766973696F6E20- <3>  %%str: db %1,0
    53 00000627 4572726F7220696E20- <3>
    53 00000630 6174616E323A20783D- <3>
    53 00000639 3000                <3>
    54                              <3>  %%endstr:
    55 0000063B BB[1E06]            <3>  mov bx,%%str
    56 0000063E E8C5FB              <3>  call write_string
    57 00000641 5A                  <3>  pop dx
    58 00000642 59                  <3>  pop cx
    59 00000643 5B                  <3>  pop bx
    60 00000644 58                  <3>  pop ax
   110 00000645 F4                  <2>   hlt
   111                              <2> 
   112                              <2> ; ───────────────────────────────────────────────────────────────────────────
   113                              <2> 
   114                              <2> atan: ; cx=z, return value in ax, bx destroyed, cx destroyed, dx destroyed
   115 00000646 89C1                <2>   mov cx,ax           ; z
   116 00000648 99                  <2>   cwd
   117 00000649 83F96F              <2>   cmp cx,111
   118 0000064C 7F29                <2>   jg .z_gt_scale      ; if (z>111)
   119 0000064E 83F991              <2>   cmp cx,-111         ; if (z<-111) 
   120 00000651 7C34                <2>   jl .z_lt_minus_scale
   121 00000653 99                  <2>   cwd
   122 00000654 F7E8                <2>   imul ax             ; ax *= ax  (z*z)
   123 00000656 BB4D01              <2>   mov bx,333     
   124 00000659 F7FB                <2>   idiv bx             ; ax /= 333   Taylor-benadering
   125 0000065B 99                  <2>   cwd
   126 0000065C 89C3                <2>   mov bx,ax
   127 0000065E B86F00              <2>   mov ax,111
   128 00000661 29D8                <2>   sub ax,bx           ; ax-=111  
   129 00000663 BBB400              <2>   mov bx,180
   130 00000666 F7EB                <2>   imul bx             ; ax*=180 
   131 00000668 F7E9                <2>   imul cx             ; ax*=z
   132 0000066A BB6F00              <2>   mov bx,111
   133 0000066D F7FB                <2>   idiv bx             ; ax/=111
   134 0000066F BB3A01              <2>   mov bx,314
   135 00000672 99                  <2>   cwd
   136 00000673 F7FB                <2>   idiv bx             ; ax/=314
   137 00000675 99                  <2>   cwd
   138 00000676 C3                  <2>   ret
   139                              <2> 
   140                              <2> .z_gt_scale:
   141 00000677 B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
   142 0000067A F7F9                <2>   idiv cx             ; ax/=z
   143 0000067C E8C7FF              <2>   call atan           ; recursion
   144 0000067F 89C3                <2>   mov bx,ax
   145 00000681 B85A00              <2>   mov ax,90
   146 00000684 29D8                <2>   sub ax,bx
   147 00000686 C3                  <2>   ret
   148                              <2> 
   149                              <2> .z_lt_minus_scale:
   150 00000687 B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
   151 0000068A F7F9                <2>   idiv cx             ; ax/=z
   152 0000068C E8B7FF              <2>   call atan           ; recursion
   153 0000068F 89C3                <2>   mov bx,ax
   154 00000691 B8A6FF              <2>   mov ax,-90
   155 00000694 29D8                <2>   sub ax,bx
   156 00000696 C3                  <2>   ret
   157                              <2> 
   158                              <2> ; ───────────────────────────────────────────────────────────────────────────
   159                              <2> 
   160                              <2> __atan2:
   161 00000697 50                  <2>   push ax
   162 00000698 53                  <2>   push bx
   163                              <2>   print "atan2(x="
    48 00000699 50                  <3>  push ax
    49 0000069A 53                  <3>  push bx
    50 0000069B 51                  <3>  push cx
    51 0000069C 52                  <3>  push dx
    52 0000069D EB09                <3>  jmp %%endstr
    53 0000069F 6174616E3228783D00  <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 000006A8 BB[9F06]            <3>  mov bx,%%str
    56 000006AB E858FB              <3>  call write_string
    57 000006AE 5A                  <3>  pop dx
    58 000006AF 59                  <3>  pop cx
    59 000006B0 5B                  <3>  pop bx
    60 000006B1 58                  <3>  pop ax
   164 000006B2 E8E7FB              <2>   call write_signed_number_word
   165                              <2>   print ",y="
    48 000006B5 50                  <3>  push ax
    49 000006B6 53                  <3>  push bx
    50 000006B7 51                  <3>  push cx
    51 000006B8 52                  <3>  push dx
    52 000006B9 EB04                <3>  jmp %%endstr
    53 000006BB 2C793D00            <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 000006BF BB[BB06]            <3>  mov bx,%%str
    56 000006C2 E841FB              <3>  call write_string
    57 000006C5 5A                  <3>  pop dx
    58 000006C6 59                  <3>  pop cx
    59 000006C7 5B                  <3>  pop bx
    60 000006C8 58                  <3>  pop ax
   166 000006C9 58                  <2>   pop ax
   167 000006CA 53                  <2>   push bx
   168 000006CB E8CEFB              <2>   call write_signed_number_word
   169                              <2>   print ")="
    48 000006CE 50                  <3>  push ax
    49 000006CF 53                  <3>  push bx
    50 000006D0 51                  <3>  push cx
    51 000006D1 52                  <3>  push dx
    52 000006D2 EB03                <3>  jmp %%endstr
    53 000006D4 293D00              <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 000006D7 BB[D406]            <3>  mov bx,%%str
    56 000006DA E829FB              <3>  call write_string
    57 000006DD 5A                  <3>  pop dx
    58 000006DE 59                  <3>  pop cx
    59 000006DF 5B                  <3>  pop bx
    60 000006E0 58                  <3>  pop ax
   170 000006E1 5B                  <2>   pop bx
   171 000006E2 58                  <2>   pop ax
   172 000006E3 E8E8FE              <2>   call atan2
   173 000006E6 E8B3FB              <2>   call write_signed_number_word
   174 000006E9 B020                <2>   mov al,' '
   175 000006EB E8DDFA              <2>   call write_char
   176 000006EE E83BFC              <2>   call new_line
   177 000006F1 C3                  <2>   ret
   178                              <2> 
   179                              <2> ; ───────────────────────────────────────────────────────────────────────────
   180                              <2> 
   181                              <2> rnd:
   182 000006F2 53                  <2>   push bx
   183 000006F3 51                  <2>   push cx
   184 000006F4 52                  <2>   push dx
   185 000006F5 B91000              <2>   mov cx, 16
   186                              <2> .lp
   187 000006F8 A1[2007]            <2>   mov ax,[.seed]
   188 000006FB 31D2                <2>   xor dx, dx           ; DX wordt gebruikt om het nieuwe bit te berekenen
   189 000006FD 89C3                <2>   mov bx, ax           ; Kopieer de huidige waarde van AX naar BX
   190                              <2>   ; shr bx, 0            ; Feedback van het laagste bit (bit 0)
   191 000006FF 30DA                <2>   xor dl, bl           ; Voeg de laagste bit aan DX toe
   192                              <2> 
   193 00000701 D1EB                <2>   shr bx, 1            ; Feedback bit 1
   194 00000703 30DA                <2>   xor dl, bl
   195                              <2> 
   196 00000705 51                  <2>   push cx
   197 00000706 B104                <2>   mov cl,4
   198 00000708 D3EB                <2>   shr bx, cl           ; Feedback bit 4
   199 0000070A 30DA                <2>   xor dl, bl
   200                              <2> 
   201 0000070C B10F                <2>   mov cl,15 
   202 0000070E D3EB                <2>   shr bx, cl           ; Feedback bit 15
   203 00000710 30DA                <2>   xor dl, bl
   204                              <2> 
   205 00000712 D1E0                <2>   shl ax, 1            ; Verschuif de registerwaarde in AX
   206 00000714 09D0                <2>   or ax, dx            ; Voeg de berekende bit toe
   207                              <2> 
   208 00000716 59                  <2>   pop cx
   209 00000717 E2DF                <2>   loop .lp        ; Herhaal totdat CX 0 is
   210                              <2> 
   211 00000719 A3[2007]            <2>   mov [.seed],ax
   212 0000071C 5A                  <2>   pop dx
   213 0000071D 59                  <2>   pop cx
   214 0000071E 5B                  <2>   pop bx
   215 0000071F C3                  <2>   ret
   216 00000720 00B4                <2>   .seed dw 0B400h
     2                              <1> 
     3                              <1> ; ───────────────────────────────────────────────────────────────────────────
     4                              <1> 
     5                              <1> v_print: ; print ([bx+0],[bx+2] + "    ")
     6 00000722 50                  <1>   push ax
     7 00000723 8B07                <1>   mov ax,[bx+0]
     8                              <1>   print_ax
    69 00000725 E874FB              <2>  call write_signed_number_word
     9                              <1>   print_char ","
    85 00000728 50                  <2>  push ax
    86 00000729 B02C                <2>  mov al,%1
    87 0000072B E89DFA              <2>  call write_char
    88 0000072E 58                  <2>  pop ax
    10 0000072F 8B4702              <1>   mov ax,[bx+2]
    11                              <1>   print_ax
    69 00000732 E867FB              <2>  call write_signed_number_word
    12                              <1>   print_2chars "  "
    92 00000735 50                  <2>  push ax
    93 00000736 B82020              <2>  mov ax,%1
    94 00000739 E8DDF8              <2>  call write_2chars
    95 0000073C 58                  <2>  pop ax
    13                              <1>   print_2chars "  "
    92 0000073D 50                  <2>  push ax
    93 0000073E B82020              <2>  mov ax,%1
    94 00000741 E8D5F8              <2>  call write_2chars
    95 00000744 58                  <2>  pop ax
    14 00000745 58                  <1>   pop ax
    15 00000746 C3                  <1>   ret
    16                              <1> 
    17                              <1> ; ───────────────────────────────────────────────────────────────────────────
    18                              <1> 
    19                              <1> v_println:
    20 00000747 E8D8FF              <1>   call v_print
    21                              <1>   println " "
    64                              <2>  print %1
    48 0000074A 50                  <3>  push ax
    49 0000074B 53                  <3>  push bx
    50 0000074C 51                  <3>  push cx
    51 0000074D 52                  <3>  push dx
    52 0000074E EB02                <3>  jmp %%endstr
    53 00000750 2000                <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 00000752 BB[5007]            <3>  mov bx,%%str
    56 00000755 E8AEFA              <3>  call write_string
    57 00000758 5A                  <3>  pop dx
    58 00000759 59                  <3>  pop cx
    59 0000075A 5B                  <3>  pop bx
    60 0000075B 58                  <3>  pop ax
    65 0000075C E8CDFB              <2>  call new_line
    22 0000075F C3                  <1>   ret
    23                              <1> 
    24                              <1> ; ───────────────────────────────────────────────────────────────────────────
    25                              <1> 
    26                              <1> 
    27                              <1> v_normalize: ; [bx]
    28                              <1> 
    29                              <1>   ; int mag = intSqrt(magSq(p));
    30                              <1>   ; mem[p+0] = (mem[p+0] * 100) / mag;
    31                              <1>   ; mem[p+1] = (mem[p+1] * 100) / mag;
    32 00000760 C3                  <1>   ret
    33                              <1> 
    34                              <1> ; ───────────────────────────────────────────────────────────────────────────
    35                              <1> 
    36                              <1> v_from_angle_mag: ; input: ax=angle, cx=mag, output: bx=vector
    37 00000761 52                  <1>   push dx
    38 00000762 E801FE              <1>   call xy_from_angle ; ax = angle [any] -> ax,dx = x,y [-100..100]
    39 00000765 8907                <1>   mov [bx+0],ax
    40 00000767 895702              <1>   mov [bx+2],dx
    41 0000076A 5A                  <1>   pop dx
    42 0000076B E81300              <1>   call v_mult  ;bx=vector, cx=scaler
    43 0000076E C3                  <1>   ret
    44                              <1> 
    45                              <1> ; ───────────────────────────────────────────────────────────────────────────
    46                              <1> 
    47                              <1> v_clear: ; [bx]=0
    48 0000076F C7070000            <1>   mov word [bx+0],0
    49 00000773 C747020000          <1>   mov word [bx+2],0
    50 00000778 C3                  <1>   ret
    51                              <1> 
    52                              <1> ; ───────────────────────────────────────────────────────────────────────────
    53                              <1> 
    54                              <1> v_if_zero: ; [bx]==0
    55 00000779 8B07                <1>   mov ax,[bx]
    56 0000077B 034702              <1>   add ax,[bx+2]
    57 0000077E 09C0                <1>   or ax,ax
    58 00000780 C3                  <1>   ret
    59                              <1> 
    60                              <1> ; ───────────────────────────────────────────────────────────────────────────
    61                              <1> 
    62                              <1> v_mult:  ; bx=vector, cx=scaler, output: bx=vector
    63 00000781 8B07                <1>   mov ax,[bx]   ; x
    64 00000783 99                  <1>   cwd
    65 00000784 F7E9                <1>   imul cx
    66 00000786 8907                <1>   mov [bx],ax
    67                              <1> 
    68 00000788 8B4702              <1>   mov ax,[bx+2] ; y
    69 0000078B 99                  <1>   cwd
    70 0000078C F7E9                <1>   imul cx
    71 0000078E 894702              <1>   mov [bx+2],ax
    72 00000791 C3                  <1>   ret
    73                              <1> 
    74                              <1> ; ───────────────────────────────────────────────────────────────────────────
    75                              <1> 
    76                              <1> v_div:  ; bx=vector, cx=scaler
    77 00000792 8B07                <1>   mov ax,[bx]   ; x
    78 00000794 99                  <1>   cwd
    79 00000795 F7F9                <1>   idiv cx
    80 00000797 8907                <1>   mov [bx],ax
    81                              <1>   
    82 00000799 8B4702              <1>   mov ax,[bx+2] ; y
    83 0000079C 99                  <1>   cwd
    84 0000079D F7F9                <1>   idiv cx
    85 0000079F 894702              <1>   mov [bx+2],ax
    86 000007A2 C3                  <1>   ret
    87                              <1> 
    88                              <1> ; ───────────────────────────────────────────────────────────────────────────
    89                              <1> 
    90                              <1> v_scale:  ; bx=vector,  cx=scaler (x100), updates bx
    91 000007A3 50                  <1>   push ax
    92 000007A4 8B07                <1>   mov ax, [bx]   ; x
    93 000007A6 99                  <1>   cwd
    94 000007A7 F7E9                <1>   imul cx
    95 000007A9 51                  <1>   push cx
    96 000007AA B96400              <1>   mov cx,100
    97 000007AD F7F9                <1>   idiv cx
    98 000007AF 59                  <1>   pop cx
    99 000007B0 8907                <1>   mov [bx], ax
   100                              <1> 
   101 000007B2 8B4702              <1>   mov ax, [bx+2]   ; y
   102 000007B5 99                  <1>   cwd
   103 000007B6 F7E9                <1>   imul cx
   104 000007B8 51                  <1>   push cx
   105 000007B9 B96400              <1>   mov cx,100
   106 000007BC F7F9                <1>   idiv cx
   107 000007BE 59                  <1>   pop cx
   108 000007BF 894702              <1>   mov [bx+2], ax
   109 000007C2 58                  <1>   pop ax
   110 000007C3 C3                  <1>   ret
   111                              <1> 
   112                              <1> ; ───────────────────────────────────────────────────────────────────────────
   113                              <1> 
   114                              <1> v_copy:    ; input bx=target,bp=source: copy vec bp into vec bx
   115 000007C4 8B4600              <1>   mov ax,[bp]
   116 000007C7 8907                <1>   mov [bx],ax
   117 000007C9 8B4602              <1>   mov ax,[bp+2]
   118 000007CC 894702              <1>   mov [bx+2],ax
   119 000007CF C3                  <1>   ret
   120                              <1> 
   121                              <1> ; ───────────────────────────────────────────────────────────────────────────
   122                              <1> 
   123                              <1> v_set: ; [bx]=ax:dx
   124 000007D0 8907                <1>   mov [bx+0],ax
   125 000007D2 895702              <1>   mov [bx+2],dx
   126 000007D5 C3                  <1>   ret
   127                              <1> 
   128                              <1> ; ───────────────────────────────────────────────────────────────────────────
   129                              <1> 
   130                              <1> v_add: ; [bx]+=[bp]
   131 000007D6 8B07                <1>   mov ax,[bx]
   132 000007D8 034600              <1>   add ax,[bp]     ; bx.x += bp.x
   133 000007DB 8907                <1>   mov [bx],ax
   134 000007DD 8B4702              <1>   mov ax,[bx+2]
   135 000007E0 034602              <1>   add ax,[bp+2]   ; bx.y += bp.y
   136 000007E3 894702              <1>   mov [bx+2],ax
   137 000007E6 C3                  <1>   ret
   138                              <1> 
   139                              <1> ; ───────────────────────────────────────────────────────────────────────────
   140                              <1> 
   141                              <1> v_sub: ; [bx]-=[bp]
   142 000007E7 8B07                <1>   mov ax,[bx]
   143 000007E9 2B4600              <1>   sub ax,[bp]     ; bx.x -= bp.x
   144 000007EC 8907                <1>   mov [bx],ax
   145 000007EE 8B4702              <1>   mov ax,[bx+2]
   146 000007F1 2B4602              <1>   sub ax,[bp+2]   ; bx.y -= bp.y
   147 000007F4 894702              <1>   mov [bx+2],ax
   148 000007F7 C3                  <1>   ret
   149                              <1> 
   150                              <1> ; ───────────────────────────────────────────────────────────────────────────
   151                              <1> 
   152                              <1> v_heading: ; bx contains address of 4 bytes vector
   153 000007F8 8B07                <1>   mov ax,[bx]
   154 000007FA 8B5F02              <1>   mov bx,[bx+2]
   155 000007FD E8CEFD              <1>   call atan2
   156 00000800 C3                  <1>   ret
   157                              <1> 
   158                              <1> ; ───────────────────────────────────────────────────────────────────────────
   159                              <1> 
   160                              <1> v_limit: ; [bx] input vector, ax=max_length. destroys dx, updates [bx]      ; erg inefficient. zou moeten kunnen zonder loop
   161 00000801 53                  <1>   push bx
   162 00000802 55                  <1>   push bp
   163 00000803 F7E0                <1>   mul ax  ; ax*=ax
   164                              <1>   print "ax*ax="
    48 00000805 50                  <2>  push ax
    49 00000806 53                  <2>  push bx
    50 00000807 51                  <2>  push cx
    51 00000808 52                  <2>  push dx
    52 00000809 EB07                <2>  jmp %%endstr
    53 0000080B 61782A61783D00      <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000812 BB[0B08]            <2>  mov bx,%%str
    56 00000815 E8EEF9              <2>  call write_string
    57 00000818 5A                  <2>  pop dx
    58 00000819 59                  <2>  pop cx
    59 0000081A 5B                  <2>  pop bx
    60 0000081B 58                  <2>  pop ax
   165                              <1>   println_ax
   102                              <2>  print_ax
    69 0000081C E87DFA              <3>  call write_signed_number_word
   103 0000081F E8E5F7              <2>  call write_5spaces_newline
   166                              <1>   ; jz .done ; ax*ax==0 -> done
   167                              <1> 
   168 00000822 95                  <1>   xchg bp,ax
   169                              <1> .lp:
   170 00000823 E82C00              <1>   call v_mag_sq     ; ax = magSq([bx])
   171                              <1> 
   172                              <1>   ; or ax,ax   ; magSq([bx])==0 -> done  
   173                              <1>   ; jz .done
   174                              <1> 
   175                              <1>   print "magSq="
    48 00000826 50                  <2>  push ax
    49 00000827 53                  <2>  push bx
    50 00000828 51                  <2>  push cx
    51 00000829 52                  <2>  push dx
    52 0000082A EB07                <2>  jmp %%endstr
    53 0000082C 6D616753713D00      <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000833 BB[2C08]            <2>  mov bx,%%str
    56 00000836 E8CDF9              <2>  call write_string
    57 00000839 5A                  <2>  pop dx
    58 0000083A 59                  <2>  pop cx
    59 0000083B 5B                  <2>  pop bx
    60 0000083C 58                  <2>  pop ax
   176                              <1>   println_ax
   102                              <2>  print_ax
    69 0000083D E85CFA              <3>  call write_signed_number_word
   103 00000840 E8C4F7              <2>  call write_5spaces_newline
   177                              <1> 
   178 00000843 39E8                <1>   cmp ax,bp
   179 00000845 7E08                <1>   jle .done
   180 00000847 B95F00              <1>   mov cx,95
   181                              <1> 
   182                              <1>   ; print_ax
   183                              <1>   ; print " "
   184                              <1> 
   185 0000084A E856FF              <1>   call v_scale      ; bx=vector, cx=scaler (x100), updates bx
   186 0000084D EBD4                <1>   jmp .lp
   187                              <1> .done:
   188 0000084F 5D                  <1>   pop bp
   189 00000850 5B                  <1>   pop bx
   190 00000851 C3                  <1>   ret
   191                              <1> 
   192                              <1> ; ───────────────────────────────────────────────────────────────────────────
   193                              <1> 
   194                              <1> v_mag_sq:   ; ax=magSq([bx])
   195 00000852 52                  <1>   push dx
   196 00000853 51                  <1>   push cx
   197 00000854 8B07                <1>   mov ax,[bx]
   198 00000856 99                  <1>   cwd
   199 00000857 F7E8                <1>   imul ax   ; moet dit niet gewoon mul zijn ipv imul?
   200 00000859 89C1                <1>   mov cx,ax   ; use cx for tmp copy of x*x
   201 0000085B 8B4702              <1>   mov ax,[bx+2]
   202 0000085E 99                  <1>   cwd
   203 0000085F F7E8                <1>   imul ax   ; moet dit niet gewoon mul zijn ipv imul?
   204 00000861 01C8                <1>   add ax,cx
   205                              <1> 
   206 00000863 59                  <1>   pop cx
   207 00000864 5A                  <1>   pop dx
   208 00000865 C3                  <1>   ret
   209                              <1> 
   210                              <1> 
   211                              <1> v_mag_sq_scaled:   ; ax=magSq([bx])
   212 00000866 53                  <1> push bx
   213 00000867 FF37                <1> push word [bx]
   214 00000869 8F06[8D08]          <1> pop word [.tmp]
   215 0000086D FF7702              <1> push word [bx+2]
   216 00000870 8F06[8F08]          <1> pop word [.tmp+2]
   217 00000874 52                  <1>   push dx
   218 00000875 51                  <1>   push cx
   219                              <1> 
   220 00000876 B90A00              <1> mov cx,10
   221                              <1> div [.tmp],cx
   221          ******************  <1>  error: invalid combination of opcode and operands
   222                              <1> 
   223                              <1> 
   224                              <1>   mov ax,[tmp]
   224          ******************  <1>  error: symbol `tmp' not defined
   225 00000879 99                  <1>   cwd
   226 0000087A F7E8                <1>   imul ax   ; moet dit niet gewoon mul zijn ipv imul?
   227 0000087C 89C1                <1>   mov cx,ax   ; use cx for tmp copy of x*x
   228                              <1>   mov ax,[tmp+2]
   228          ******************  <1>  error: symbol `tmp' not defined
   229 0000087E 99                  <1>   cwd
   230 0000087F F7E8                <1>   imul ax   ; moet dit niet gewoon mul zijn ipv imul?
   231 00000881 01C8                <1>   add ax,cx
   232                              <1> 
   233 00000883 59                  <1>   pop cx
   234 00000884 5A                  <1>   pop dx
   235                              <1> 
   236 00000885 5B                  <1> pop bx
   237 00000886 C3                  <1>   ret
   238 00000887 00000000            <1> .tmp: dw 0,0
   239                              <1> 
   240                              <1> 
   241                              <1> ; v_mag_sq32:   ; ax:dx = magSq([bx])
   242                              <1> ;   push bp
   243                              <1> ;   push cx
   244                              <1> ;   mov ax, [bx]      ; Laad X in AX
   245                              <1> ;   mul ax            ; AX * AX -> resultaat in DX:AX
   246                              <1> ;   mov cx, ax        ; Bewaar laag deel (X²) in CX
   247                              <1> ;   mov bp, dx        ; Bewaar hoog deel (X²) in BP(!) (voor overloop)
   248                              <1> ;   mov ax, [bx+2]    ; Laad Y in AX
   249                              <1> ;   mul ax            ; AX * AX -> resultaat in DX:AX
   250                              <1> ;   add cx, ax        ; Voeg laag deel (Y²) toe aan CX
   251                              <1> ;   adc bp, dx        ; Voeg hoog deel (Y²) toe aan BP(!) met carry
   252                              <1> ;   mov ax, cx        ; Laag deel terugzetten in AX
   253                              <1> ;   mov dx, bp        ; Hoog deel terugzetten in DX
   254                              <1> ;   pop cx
   255                              <1> ;   pop bp
   256                              <1> ;   ret
   257                              <1> 
   258                              <1> 
   259                              <1> ; ───────────────────────────────────────────────────────────────────────────
   260                              <1> 
   261                              <1> ; v_mag:   ; ax=sqrt(magSq([bx]))
   262                              <1> ;   call v_mag_sq32
   263                              <1> ;   call sqrt32
   264                              <1> ;   ret
   265                              <1>   
   266                              <1> ; ───────────────────────────────────────────────────────────────────────────
   267                              <1> 
   268                              <1> 
   269                              <1> 
     4                                  %include "stars.asm"
     1                              <1> init_stars:
     2 0000088B B96400              <1>   mov cx,NUM_STARS*2   ; *2 for both x and y
     3                              <1> .lp
     4 0000088E 89CB                <1>   mov bx,cx
     5 00000890 8B87[660B]          <1>   mov ax,[setup+bx]   ; use setup and draw instructions as seed
     6 00000894 A3[2007]            <1>   mov [rnd.seed],ax
     7 00000897 E858FE              <1>   call rnd
     8 0000089A 2E8987[210A]        <1>   mov [cs:bx+stars],ax
     9 0000089F E2ED                <1>   loop .lp
    10 000008A1 C3                  <1>   ret
    11                              <1> 
    12                              <1> ; ───────────────────────────────────────────────────────────────────────────
    13                              <1> 
    14                              <1> undraw_and_draw_star:    ; now ax=x, bx=y   location of star in world coords
    15 000008A2 8EC1                <1>   mov es,cx
    16                              <1> 
    17 000008A4 51                  <1>   push cx
    18                              <1> 
    19                              <1>   ; undraw star
    20 000008A5 50                  <1>   push ax
    21 000008A6 53                  <1>   push bx
    22 000008A7 2B06[F609]          <1>     sub ax,[ship.prev.x]
    23 000008AB 2B1E[F809]          <1>     sub bx,[ship.prev.y]
    24 000008AF E83E03              <1>     call world2screen
    25 000008B2 E85DFA              <1>     call calc_di_from_bx
    26 000008B5 B80000              <1>     mov ax,0
    27 000008B8 AB                  <1>     stosw
    28 000008B9 AA                  <1>     stosb
    29 000008BA 5B                  <1>   pop bx
    30 000008BB 58                  <1>   pop ax
    31                              <1> 
    32                              <1> ; draw star new position
    33 000008BC 50                  <1>   push ax
    34 000008BD 53                  <1>   push bx
    35 000008BE 2B06[F209]          <1>     sub ax,[ship.pos.x]
    36 000008C2 2B1E[F409]          <1>     sub bx,[ship.pos.y]
    37 000008C6 E82703              <1>     call world2screen
    38 000008C9 E846FA              <1>     call calc_di_from_bx
    39 000008CC A1[0909]            <1>     mov ax,[draw_stars.shape]
    40 000008CF AB                  <1>     stosw
    41 000008D0 AA                  <1>     stosb
    42 000008D1 5B                  <1>   pop bx
    43 000008D2 58                  <1>   pop ax
    44                              <1> 
    45 000008D3 59                  <1>   pop cx
    46 000008D4 C3                  <1>   ret
    47                              <1> 
    48                              <1> ; ───────────────────────────────────────────────────────────────────────────
    49                              <1> 
    50                              <1> draw_stars:  ; call 3 times, for every color channel
    51 000008D5 B93200              <1>   mov cx,NUM_STARS
    52 000008D8 BE[210A]            <1>   mov si,stars
    53                              <1> 
    54                              <1> .lp
    55                              <1> 
    56 000008DB B80010              <1>   mov ax,0b0001000000000000
    57 000008DE 09C9                <1>   or cx,cx
    58 000008E0 7A09                <1>   jp .l1
    59 000008E2 B81038              <1>   mov ax,0b0011100000010000
    60                              <1> .l1
    61 000008E5 A3[0909]            <1>   mov [.shape],ax
    62 000008E8 AD                  <1>   lodsw
    63 000008E9 93                  <1>   xchg bx,ax
    64 000008EA AD                  <1>   lodsw
    65 000008EB 93                  <1>   xchg bx,ax     ; now ax=x, bx=y
    66                              <1> 
    67 000008EC 51                  <1>   push cx
    68 000008ED B900F0              <1>   mov cx,RED
    69 000008F0 E8AFFF              <1>   call undraw_and_draw_star
    70 000008F3 B9001C              <1>   mov cx,GREEN
    71 000008F6 E8A9FF              <1>   call undraw_and_draw_star
    72 000008F9 B900F4              <1>   mov cx,BLUE
    73 000008FC E8A3FF              <1>   call undraw_and_draw_star
    74 000008FF 59                  <1>   pop cx
    75                              <1> 
    76                              <1> 
    77                              <1> .next
    78 00000900 E2D9                <1>   loop .lp
    79 00000902 C3                  <1>   ret
    80 00000903 0000                <1>   .shape dw 0
    81                              <1> 
    82                              <1> 
     5                                  %include "ship.asm"
     1                              <1> update_ship:
     2                              <1> 
     3 00000905 BB[F609]            <1>   mov bx,ship.prev
     4 00000908 BD[F209]            <1>   mov bp,ship.pos
     5 0000090B E8B6FE              <1>   call v_copy             ; previous position of ship
     6                              <1> 
     7 0000090E BB[0A0A]            <1>   mov bx,ship.force
     8 00000911 BD[060A]            <1>   mov bp,ship.forces
     9 00000914 E8ADFE              <1>   call v_copy             ; force = forces.copy()
    10                              <1> 
    11 00000917 BB[0A0A]            <1>   mov bx,ship.force
    12 0000091A B90200              <1>   mov cx,2
    13 0000091D E8E1FE              <1>   call v_limit            ; force.limit(25)
    14                              <1> 
    15 00000920 BB[060A]            <1>   mov bx,ship.forces
    16 00000923 BD[0A0A]            <1>   mov bp,ship.force
    17 00000926 E8BEFE              <1>   call v_sub              ; forces -= force
    18                              <1> 
    19 00000929 BB[060A]            <1>   mov bx,ship.forces
    20 0000092C B96200              <1>   mov cx,98
    21 0000092F E871FE              <1>   call v_scale            ; forces *= 0.90
    22                              <1> 
    23 00000932 BB[020A]            <1>   mov bx,ship.acc
    24 00000935 BD[0A0A]            <1>   mov bp,ship.force
    25 00000938 E89BFE              <1>   call v_add              ; acceleration += forces
    26                              <1> 
    27 0000093B BB[0A0A]            <1>   mov bx,ship.force
    28 0000093E B90000              <1>   mov cx,0
    29 00000941 E83DFE              <1>   call v_mult             ; ///force is altijd maar tijdelijk
    30                              <1> 
    31                              <1> 
    32 00000944 BB[FA09]            <1>   mov bx,ship.vel
    33 00000947 BD[020A]            <1>   mov bp,ship.acc
    34 0000094A E889FE              <1>   call v_add              ; velocity += acceleration
    35                              <1> 
    36 0000094D BB[020A]            <1>   mov bx,ship.acc
    37 00000950 B90000              <1>   mov cx,0
    38 00000953 E82BFE              <1>   call v_mult             ; acceleration = 0
    39                              <1> 
    40 00000956 BB[F209]            <1>   mov bx,ship.pos
    41 00000959 BD[FA09]            <1>   mov bp,ship.vel
    42 0000095C E877FE              <1>   call v_add              ; position += velocity
    43                              <1> 
    44 0000095F BB[FA09]            <1>   mov bx,ship.vel
    45 00000962 B96200              <1>   mov cx,98
    46 00000965 E83BFE              <1>   call v_scale            ; velocity *= .98
    47                              <1> 
    48 00000968 BB[FA09]            <1>   mov bx,ship.vel
    49 0000096B B96400              <1>   mov cx,100
    50 0000096E E890FE              <1>   call v_limit            ; max velocity
    51                              <1> 
    52 00000971 BB[FA09]            <1>   mov bx,ship.vel
    53 00000974 E8DBFE              <1>   call v_mag_sq
    54 00000977 A3[000A]            <1>   mov [ship.vel.magSq],ax  ;USED for debug
    55                              <1> 
    56                              <1> .begin_angle:
    57 0000097A BB[FA09]            <1>   mov bx,ship.vel
    58 0000097D E8F9FD              <1>   call v_if_zero
    59 00000980 7421                <1>   jz .end_angle
    60 00000982 E873FE              <1>   call v_heading   
    61 00000985 A3[0E0A]            <1>   mov [ship.angle],ax     ; angle = heading(velocity)
    62                              <1> 
    63                              <1>   ;calc sprite index from angle in ax
    64 00000988 31D2                <1>   xor dx,dx
    65 0000098A BB0F00              <1>   mov bx,15
    66 0000098D F7FB                <1>   idiv bx                 ; sprite_index = angle/15 (range 0..23)
    67 0000098F A3[100A]            <1>   mov [ship.sprite_index],ax   
    68 00000992 BB0203              <1>   mov bx,770
    69 00000995 F7E3                <1>   mul bx                  ; img_addr = (668+2 bytes per image * sprite_index)
    70 00000997 05[010C]            <1>   add ax,img_first        ; img_addr += img_first (offset)
    71 0000099A A3[120A]            <1>   mov [ship.img_addr],ax
    72                              <1> .end_angle:
    73                              <1> 
    74 0000099D C3                  <1>   ret
    75                              <1> 
    76                              <1> ; ───────────────────────────────────────────────────────────────────────────
    77                              <1> 
    78                              <1> draw_ship_static:
    79 0000099E BF5022              <1>   mov di,8784
    80 000009A1 8B36[120A]          <1>   mov si,[ship.img_addr]
    81 000009A5 E828F9              <1>   call draw_spr
    82 000009A8 C3                  <1>   ret
    83                              <1> 
    84                              <1> draw_ship:
    85 000009A9 A1[F209]            <1>   mov ax,[ship.pos.x]
    86 000009AC 8B1E[F409]          <1>   mov bx,[ship.pos.y]
    87 000009B0 E83D02              <1>   call world2screen
    88 000009B3 E85CF9              <1>   call calc_di_from_bx
    89                              <1> 
    90 000009B6 393E[140A]          <1>   cmp [ship.prev_di],di  
    91                              <1>   ; je .return             ; no screen update needed >>>  DISABLED because ship on fixed position
    92                              <1> 
    93 000009BA 8B3E[140A]          <1>   mov di,[ship.prev_di]
    94                              <1> 
    95 000009BE A1[F209]            <1>   mov ax,[ship.pos.x]
    96 000009C1 8B1E[F409]          <1>   mov bx,[ship.pos.y]
    97 000009C5 E82802              <1>   call world2screen
    98 000009C8 E847F9              <1>   call calc_di_from_bx
    99 000009CB 83FF00              <1>   cmp di,0
   100 000009CE 7F09                <1>   jg .ok
   101 000009D0 BF0000              <1>   mov di,0
   102                              <1> .ok
   103 000009D3 893E[140A]          <1>   mov [ship.prev_di],di
   104                              <1> 
   105 000009D7 8B36[120A]          <1>   mov si,[ship.img_addr]
   106 000009DB A1[F209]            <1>   mov ax,[ship.pos.x]
   107 000009DE 8B1E[F409]          <1>   mov bx,[ship.pos.y]
   108 000009E2 E80B02              <1>   call world2screen ; ax and bx are already set by pop bx, pop ax
   109 000009E5 E82AF9              <1>   call calc_di_from_bx
   110 000009E8 E8E5F8              <1>   call draw_spr
   111                              <1> 
   112                              <1> .return
   113 000009EB C3                  <1>   ret
     6                                  
     7                                  ship:
     8                                   .pos:
     9 000009EC 0090                     .pos.x: dw 73728/2              ; 0..73728  (65536)
    10 000009EE F03C                     .pos.y: dw 51200/2 - 10000      ; 0..51200  (=1024*50)
    11                                   .prev:
    12 000009F0 0090                     .prev.x: dw 73728/2              ; 0..73728  (65536)
    13 000009F2 F03C                     .prev.y: dw 51200/2 - 10000      ; 0..51200  (=1024*50)
    14                                   .vel: 
    15 000009F4 0000                     .vel.x: dw 0
    16 000009F6 0000                     .vel.y: dw 0
    17 000009F8 0000                     .vel.flags: dw 0
    18 000009FA 0000                     .vel.magSq: dw 0
    19                                   .acc:
    20 000009FC 0000                     .acc.x: dw 0
    21 000009FE 0000                     .acc.y: dw 0
    22                                   .forces:             ; accumulated forces over time
    23 00000A00 0000                     .forces.x: dw 0
    24 00000A02 0000                     .forces.y: dw 0
    25                                   .force:              ; force for this frame derived from accumulated forces
    26 00000A04 0000                     .force.x: dw 0
    27 00000A06 0000                     .force.y: dw 0
    28 00000A08 0000                     .angle: dw 0
    29 00000A0A 0000                     .sprite_index: dw 0
    30 00000A0C [010C]                   .img_addr: dw img_first
    31 00000A0E 0000                     .prev_di: dw 0
    32                                  
    33                                  debug:
    34 00000A10 0000                      .ax: dw 0
    35 00000A12 0000                      .bx: dw 0
    36 00000A14 0000                      .cx: dw 0
    37 00000A16 0000                      .dx: dw 0
    38                                  
    39 00000A18 0000                    frame_count: dw 0
    40 00000A1A 02                      color: db Color.G
    41                                  FRICTION equ 94
    42                                  STEP equ 1000
    43                                  FRAME_DELAY EQU 1
    44                                  NUM_STARS equ 50
    45 00000A1B 0000<rep 64h>           stars: times (2*NUM_STARS) dw 0  ; 50 stars at 0,0
    46                                  
    47                                  debug_test:
    48                                    set_cursor 1,1
    43                              <1> 
    44 00000AE3 BF0000              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
    49                                  
    50 00000AE6 B80000                    mov ax,0
    51 00000AE9 E88500                    call addForceFromAngle
    52                                  
    53 00000AEC B80F00                    mov ax,15
    54 00000AEF E87F00                    call addForceFromAngle
    55                                  
    56 00000AF2 B80F00                    mov ax,15
    57 00000AF5 E87900                    call addForceFromAngle
    58                                  
    59                                  
    60                                  
    61 00000AF8 BB[040A]                  mov bx,ship.force
    62 00000AFB BD[000A]                  mov bp,ship.forces
    63 00000AFE E8C3FC                    call v_copy             ; force = forces.copy()
    64                                  
    65 00000B01 BB[040A]                  mov bx,ship.force
    66 00000B04 B80200                    mov ax,2
    67 00000B07 E8F7FC                    call v_limit            ; force.limit(25)
    68                                  
    69                                    ; mov bx,ship.forces
    70                                    ; mov bp,ship.force
    71                                    ; call v_sub              ; forces -= force
    72                                  
    73                                    ; mov bx,ship.forces
    74                                    ; mov cx,98
    75                                    ; call v_scale            ; forces *= 0.90
    76                                  
    77                                    ; mov bx,ship.acc
    78                                    ; mov bp,ship.force
    79                                    ; call v_add              ; acceleration += forces
    80                                  
    81                                    ; mov bx,ship.force
    82                                    ; mov cx,0
    83                                    ; call v_mult             ; ///force is altijd maar tijdelijk
    84                                  
    85                                  
    86                                    ; mov bx,ship.vel
    87                                    ; mov bp,ship.acc
    88                                    ; call v_add              ; velocity += acceleration
    89                                  
    90                                    ; mov bx,ship.acc
    91                                    ; mov cx,0
    92                                    ; call v_mult             ; acceleration = 0
    93                                  
    94                                    ; mov bx,ship.pos
    95                                    ; mov bp,ship.vel
    96                                    ; call v_add              ; position += velocity
    97                                  
    98                                    ; mov bx,ship.vel
    99                                    ; mov cx,98
   100                                    ; call v_scale            ; velocity *= .98
   101                                  
   102                                    ; mov bx,ship.vel
   103                                    ; mov cx,100
   104                                    ; call v_limit            ; max velocity
   105                                  
   106                                    ; mov bx,ship.vel
   107                                    ; call v_mag_sq
   108                                    ; mov [ship.vel.magSq],ax  ;USED for debug
   109                                  
   110                                  
   111                                  
   112                                  
   113                                  
   114                                    
   115                                    print "FORCES: "
    48 00000B0A 50                  <1>  push ax
    49 00000B0B 53                  <1>  push bx
    50 00000B0C 51                  <1>  push cx
    51 00000B0D 52                  <1>  push dx
    52 00000B0E EB0F                <1>  jmp %%endstr
    53 00000B10 464F524345533A2000  <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000B19 BB[100B]            <1>  mov bx,%%str
    56 00000B1C E8E7F6              <1>  call write_string
    57 00000B1F 5A                  <1>  pop dx
    58 00000B20 59                  <1>  pop cx
    59 00000B21 5B                  <1>  pop bx
    60 00000B22 58                  <1>  pop ax
   116 00000B23 BB[000A]                  mov bx,ship.forces 
   117 00000B26 E81EFC                    call v_println
   118                                  
   119                                    print "FORCE: "
    48 00000B29 50                  <1>  push ax
    49 00000B2A 53                  <1>  push bx
    50 00000B2B 51                  <1>  push cx
    51 00000B2C 52                  <1>  push dx
    52 00000B2D EB0E                <1>  jmp %%endstr
    53 00000B2F 464F5243453A2000    <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000B37 BB[2F0B]            <1>  mov bx,%%str
    56 00000B3A E8C9F6              <1>  call write_string
    57 00000B3D 5A                  <1>  pop dx
    58 00000B3E 59                  <1>  pop cx
    59 00000B3F 5B                  <1>  pop bx
    60 00000B40 58                  <1>  pop ax
   120 00000B41 BB[040A]                  mov bx,ship.force
   121 00000B44 E800FC                    call v_println
   122                                  
   123                                  
   124                                  
   125                                  
   126                                  
   127                                    println "done"
    64                              <1>  print %1
    48 00000B47 50                  <2>  push ax
    49 00000B48 53                  <2>  push bx
    50 00000B49 51                  <2>  push cx
    51 00000B4A 52                  <2>  push dx
    52 00000B4B EB0B                <2>  jmp %%endstr
    53 00000B4D 646F6E6500          <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000B52 BB[4D0B]            <2>  mov bx,%%str
    56 00000B55 E8AEF6              <2>  call write_string
    57 00000B58 5A                  <2>  pop dx
    58 00000B59 59                  <2>  pop cx
    59 00000B5A 5B                  <2>  pop bx
    60 00000B5B 58                  <2>  pop ax
    65 00000B5C E8CDF7              <1>  call new_line
   128 00000B5F F4                        hlt
   129                                  
   130                                  setup:
   131 00000B60 E880FF                    call debug_test
   132 00000B63 F4                        hlt
   133                                  
   134                                  
   135                                  
   136 00000B64 E824FD                    call init_stars
   137 00000B67 31ED                      xor bp,bp
   138 00000B69 EB1F                      jmp draw
   139                                  
   140                                  
   141                                  ; ───────────────────────────────────────────────────────────────────────────
   142                                  
   143                                  addForceFromAngle:  ; input ax = current angle + rel angle
   144 00000B6B B90500                    mov cx,5    ; magnitude
   145                                  
   146                                    ; mov ax,0 ; TMP
   147                                  
   148 00000B6E BB[040A]                  mov bx,ship.force
   149 00000B71 E8EDFB                    call v_from_angle_mag
   150                                  
   151 00000B74 BB[000A]                  mov bx,ship.forces
   152 00000B77 BD[040A]                  mov bp,ship.force
   153 00000B7A E859FC                    call v_add  ; [bx]+=[bp]
   154                                  
   155 00000B7D BB[040A]                  mov bx,ship.force
   156 00000B80 E8ECFB                    call v_clear         ; FORCE wordt hier gebruikt als tmp variabele
   157                                     
   158                                  
   159 00000B83 C3                        ret
   160                                  
   161                                  ; ───────────────────────────────────────────────────────────────────────────
   162                                  
   163                                  draw:
   164 00000B84 0E                        push cs
   165 00000B85 1F                        pop ds   ; make sure DS is set to CS for data lookups like [ship.pos.x]
   166                                  
   167 00000B86 E87CFD                    call update_ship
   168                                  
   169 00000B89 E849FD                    call draw_stars
   170 00000B8C E80FFE                    call draw_ship_static
   171 00000B8F E8E2F7                    call draw_debug_info
   172                                  
   173                                    ; call _wait
   174 00000B92 FF06[180A]                inc word [frame_count]
   175                                  
   176 00000B96 E817F7                    call check_keys
   177 00000B99 7508                      jnz on_key
   178                                  
   179 00000B9B EBE7                      jmp draw          ; this code is only getting called when no key is pressed
   180                                  
   181                                  
   182                                  ; ───────────────────────────────────────────────────────────────────────────
   183                                  
   184                                  
   185                                  on_key:
   186 00000B9D 83F877                    cmp ax,'w'
   187 00000BA0 7417                      je on_key_w
   188 00000BA2 83F861                    cmp ax,'a'
   189 00000BA5 741A                      je on_key_a
   190 00000BA7 83F873                    cmp ax,'s'
   191 00000BAA 742B                      je on_key_s
   192 00000BAC 83F864                    cmp ax,'d'
   193 00000BAF 741B                      je on_key_d
   194                                  .done
   195 00000BB1 EBD1                      jmp draw  ; no ret here because onkey is called by jnz
   196                                  
   197                                  
   198                                  ; ───────────────────────────────────────────────────────────────────────────
   199                                  
   200                                  on_key_w:
   201 00000BB3 A1[080A]                  mov ax,[ship.angle]
   202 00000BB6 E8B2FF                    call addForceFromAngle
   203 00000BB9 EBF6                      jmp on_key.done
   204                                  
   205                                  ; ───────────────────────────────────────────────────────────────────────────
   206                                  
   207                                  on_key_a:
   208 00000BBB A1[080A]                  mov ax,[ship.angle]
   209 00000BBE 83E85A                    sub ax,90
   210 00000BC1 E8A7FF                    call addForceFromAngle
   211 00000BC4 EBEB                      jmp on_key.done
   212                                  
   213                                  ; ───────────────────────────────────────────────────────────────────────────
   214                                  
   215                                  on_key_d:
   216 00000BC6 A1[080A]                  mov ax,[ship.angle]
   217 00000BC9 83C05A                    add ax,90
   218 00000BCC E89CFF                    call addForceFromAngle
   219 00000BCF EBE0                      jmp on_key.done
   220                                  
   221                                  ; ───────────────────────────────────────────────────────────────────────────
   222                                  
   223                                  on_key_s:   ;;;;;;;;;;;;; remmen:  
   224 00000BD1 BB[000A]                  mov bx,ship.forces
   225 00000BD4 E898FB                    call v_clear
   226                                  
   227 00000BD7 BB[F409]                  mov bx,ship.vel
   228 00000BDA B93200                    mov cx,50
   229 00000BDD E8C3FB                    call v_scale
   230                                  
   231 00000BE0 EBCF                      jmp on_key.done
   232                                    ; ───────────────────────────────────────────────────────────────────────────
   233                                  
   234                                  
   235                                  _wait:
   236 00000BE2 B90100                    mov cx,FRAME_DELAY
   237 00000BE5 D40A                      .lp aam
   238 00000BE7 E2FC                      loop .lp
   239 00000BE9 C3                        ret
   240                                  
   241                                  ; ───────────────────────────────────────────────────────────────────────────
   242                                  
   243                                  world2screen:  ; input (ax,bx) = (world.x, world.y)   ; screen (row,col) ; output (bx)
   244                                    ; WORLD:
   245                                    ;   0..73728  (65536) -> col
   246                                    ;   0..51200  (=1024*50) -> row
   247                                    ; SCREEN (ROW,COL):
   248                                    ;   0..49 (row)
   249                                    ;   0..71 (col)
   250 00000BEA 51                        push cx
   251 00000BEB B10A                      mov cl,10
   252 00000BED D3EB                      shr bx,cl   ; //bl=row 0..49
   253 00000BEF D3E8                      shr ax,cl   ; 
   254 00000BF1 FEC9                      dec cl
   255 00000BF3 FEC9                      dec cl      ; cl=8
   256 00000BF5 D3E3                      shl bx,cl   
   257                                    ; mov bh,al   ; //bh=col 0..71
   258                                    ; xchg bh,bl
   259 00000BF7 09C3                      or bx,ax
   260 00000BF9 59                        pop cx
   261 00000BFA C3                        ret
   262                                  
   263                                  ; ───────────────────────────────────────────────────────────────────────────
   264                                  
   265                                  img_first:
   266                                  img_right:
   267 00000BFB <bin 302h>              img7: incbin "data/ship-7.spr" ;right
   268 00000EFD <bin 302h>              img8: incbin "data/ship-8.spr"
   269 000011FF <bin 302h>              img9: incbin "data/ship-9.spr"
   270                                  img_down_right:
   271 00001501 <bin 302h>              img10: incbin "data/ship-10.spr" ;down-right
   272 00001803 <bin 302h>              img11: incbin "data/ship-11.spr"
   273 00001B05 <bin 302h>              img12: incbin "data/ship-12.spr"
   274                                  img_down:
   275 00001E07 <bin 302h>              img13: incbin "data/ship-13.spr" ;down
   276 00002109 <bin 302h>              img14: incbin "data/ship-14.spr"
   277 0000240B <bin 302h>              img15: incbin "data/ship-15.spr"
   278                                  img_down_left:
   279 0000270D <bin 302h>              img16: incbin "data/ship-16.spr" ;down-left
   280 00002A0F <bin 302h>              img17: incbin "data/ship-17.spr"
   281 00002D11 <bin 302h>              img18: incbin "data/ship-18.spr"
   282                                  img_left:
   283 00003013 <bin 302h>              img19: incbin "data/ship-19.spr" ;left
   284 00003315 <bin 302h>              img20: incbin "data/ship-20.spr"
   285 00003617 <bin 302h>              img21: incbin "data/ship-21.spr"
   286                                  img_up_left:
   287 00003919 <bin 302h>              img22: incbin "data/ship-22.spr" ;up-left
   288 00003C1B <bin 302h>              img23: incbin "data/ship-23.spr"
   289 00003F1D <bin 302h>              img24: incbin "data/ship-24.spr"
   290                                  img_up:
   291 0000421F <bin 302h>              img1: incbin "data/ship-1.spr" ;up
   292 00004521 <bin 302h>              img2: incbin "data/ship-2.spr"
   293 00004823 <bin 302h>              img3: incbin "data/ship-3.spr"
   294                                  img_up_right:
   295 00004B25 <bin 302h>              img4: incbin "data/ship-4.spr" ;up-right
   296 00004E27 <bin 302h>              img5: incbin "data/ship-5.spr"
   297 00005129 <bin 302h>              img6: incbin "data/ship-6.spr"
   298                                  
   299                                  
   300                                  ; %assign num $-$$
   301                                  ; %warning total num
   302                                  
   303 0000542B 00<rep 27BD5h>          times (180*1024)-($-$$) db 0
   304                                  
   305                                  
   306                                  
