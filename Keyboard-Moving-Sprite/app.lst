     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 EB54                <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 40          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34 00000002 00                  <1> cursor.x: db 0
    35 00000003 00                  <1> cursor.y: db 0
    36                              <1> key:
    37 00000004 00                  <1>   .code db 0
    38 00000005 00                  <1>   .ctrl db 0
    39                              <1> 
    40                              <1> ; %macro set_cursor_row 1
    41                              <1> ;   mov di,%1 * BYTES_PER_ROW
    42                              <1> ; %endmacro
    43                              <1> 
    44                              <1> %macro set_cursor 2
    45                              <1>   mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    46                              <1>   ; mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    47                              <1> %endmacro
    48                              <1> 
    49                              <1> %macro print 1
    50                              <1>   jmp %%endstr 
    51                              <1>   %%str: db %1,0
    52                              <1>   %%endstr: 
    53                              <1>   mov bx,%%str
    54                              <1>   call write_string
    55                              <1> %endmacro
    56                              <1> 
    57                              <1> %macro register_interrupt 2
    58                              <1>   ;DS shoud be 0
    59                              <1>   mov word [%1*4+0],%2
    60                              <1>   mov word [%1*4+2],cs
    61                              <1> %endmacro
    62                              <1> 
    63                              <1> %macro halt 1
    64                              <1>   push cs
    65                              <1>   pop ds
    66                              <1>   xor di,di
    67                              <1>   mov bx,%%str
    68                              <1>   call write_string
    69                              <1>   hlt
    70                              <1>   %%str: db %1,0
    71                              <1> %endmacro
    72                              <1> 
    73                              <1> int0: halt "int0" ;  - Division by zero"
    73                              <2> int0: 
    64 00000006 0E                  <2>  push cs
    65 00000007 1F                  <2>  pop ds
    66 00000008 31FF                <2>  xor di,di
    67 0000000A BB[1100]            <2>  mov bx,%%str
    68 0000000D E89A01              <2>  call write_string
    69 00000010 F4                  <2>  hlt
    70 00000011 696E743000          <2>  %%str: db %1,0
    74                              <1> int1: halt "int1" ;  - Single step debugging"
    74                              <2> int1: 
    64 00000016 0E                  <2>  push cs
    65 00000017 1F                  <2>  pop ds
    66 00000018 31FF                <2>  xor di,di
    67 0000001A BB[2100]            <2>  mov bx,%%str
    68 0000001D E88A01              <2>  call write_string
    69 00000020 F4                  <2>  hlt
    70 00000021 696E743100          <2>  %%str: db %1,0
    75                              <1> int2: halt "int2" ;  - Non maskable interrupt"
    75                              <2> int2: 
    64 00000026 0E                  <2>  push cs
    65 00000027 1F                  <2>  pop ds
    66 00000028 31FF                <2>  xor di,di
    67 0000002A BB[3100]            <2>  mov bx,%%str
    68 0000002D E87A01              <2>  call write_string
    69 00000030 F4                  <2>  hlt
    70 00000031 696E743200          <2>  %%str: db %1,0
    76                              <1> int3: halt "int3" ;  - For one-byte interrupt"
    76                              <2> int3: 
    64 00000036 0E                  <2>  push cs
    65 00000037 1F                  <2>  pop ds
    66 00000038 31FF                <2>  xor di,di
    67 0000003A BB[4100]            <2>  mov bx,%%str
    68 0000003D E86A01              <2>  call write_string
    69 00000040 F4                  <2>  hlt
    70 00000041 696E743300          <2>  %%str: db %1,0
    77                              <1> int4: halt "int4" ;  - Signed overflow"
    77                              <2> int4: 
    64 00000046 0E                  <2>  push cs
    65 00000047 1F                  <2>  pop ds
    66 00000048 31FF                <2>  xor di,di
    67 0000004A BB[5100]            <2>  mov bx,%%str
    68 0000004D E85A01              <2>  call write_string
    69 00000050 F4                  <2>  hlt
    70 00000051 696E743400          <2>  %%str: db %1,0
    78                              <1> 
    79                              <1> boot:
    80 00000056 FA                  <1>   cli
    81 00000057 FC                  <1>   cld
    82 00000058 E8FE00              <1>   call clear_green          
    83 0000005B B005                <1>   mov al, 5
    84 0000005D E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
    85                              <1> 
    86                              <1>   ; register interrupts
    87 0000005F B80000              <1>   mov ax,0
    88 00000062 8ED8                <1>   mov ds,ax ; segment 0
    89                              <1>   register_interrupt 0, int0
    58                              <2> 
    59 00000064 C7060000[0600]      <2>  mov word [%1*4+0],%2
    60 0000006A 8C0E0200            <2>  mov word [%1*4+2],cs
    90                              <1>   register_interrupt 1, int1
    58                              <2> 
    59 0000006E C7060400[1600]      <2>  mov word [%1*4+0],%2
    60 00000074 8C0E0600            <2>  mov word [%1*4+2],cs
    91                              <1>   register_interrupt 2, int2
    58                              <2> 
    59 00000078 C7060800[2600]      <2>  mov word [%1*4+0],%2
    60 0000007E 8C0E0A00            <2>  mov word [%1*4+2],cs
    92                              <1>   register_interrupt 3, int3
    58                              <2> 
    59 00000082 C7060C00[3600]      <2>  mov word [%1*4+0],%2
    60 00000088 8C0E0E00            <2>  mov word [%1*4+2],cs
    93                              <1>   register_interrupt 4, int4
    58                              <2> 
    59 0000008C C7061000[4600]      <2>  mov word [%1*4+0],%2
    60 00000092 8C0E1200            <2>  mov word [%1*4+2],cs
    94                              <1> 
    95 00000096 CC                  <1> int3
    96                              <1>   
    97 00000097 B000                <1>   mov al,0
    98 00000099 E63A                <1>   out 0x3a,al           ; keyboard \force state/
    99 0000009B E63A                <1>   out 0x3a,al           ; keyboard \force state/
   100 0000009D B0FF                <1>   mov al,0xFF
   101 0000009F E63A                <1>   out 0x3a,al           ; keyboard \reset/
   102 000000A1 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   103 000000A3 B037                <1>   mov al,0x37
   104 000000A5 E63A                <1>   out 0x3a,al           ; keyboard \set command
   105                              <1> 
   106 000000A7 B8001C              <1>   mov ax,GREEN      
   107 000000AA 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   108 000000AC B83800              <1>   mov ax,DST                
   109 000000AF 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   110 000000B1 BF0000              <1>   mov di,0                  ;
   111 000000B4 B200                <1>   mov dl,0                  ; track=0
   112 000000B6 B601                <1>   mov dh,1                  ; sector=1
   113 000000B8 B92800              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   114 000000BB EB0B                <1>   jmp move_head
   115                              <1> 
   116                              <1> ; ───────────────────────────────────────────────────────────────────────────
   117                              <1> 
   118                              <1> next_sector:
   119 000000BD FEC6                <1>   inc dh                    ; sector++
   120 000000BF 80FE0A              <1>   cmp dh,10
   121 000000C2 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   122 000000C4 B601                <1>   mov dh,1
   123 000000C6 FEC2                <1>   inc dl                    ; else track++ ; sector=1
   124                              <1> 
   125                              <1> move_head:
   126 000000C8 88D0                <1>   mov al,dl
   127 000000CA E60E                <1>   out 0Eh,al               ; set track number
   128 000000CC B018                <1>   mov al,18h     
   129 000000CE E608                <1>   out 8,al                 ; seek track, load head
   130 000000D0 B000                <1>   mov al,0
   131 000000D2 E61C                <1>   out 1Ch,al               ; set desired drive/side
   132 000000D4 D40A                <1>   aam
   133                              <1> 
   134                              <1> head_moving:
   135 000000D6 E408                <1>   in al,8
   136 000000D8 A801                <1>   test al,1
   137 000000DA 75FA                <1>   jnz head_moving
   138                              <1> 
   139                              <1> read_sector:
   140 000000DC 88F0                <1>   mov al,dh
   141 000000DE E60C                <1>   out 0Ch,al                ; sector number
   142 000000E0 B702                <1>   mov bh,2                  ; 00000010b
   143 000000E2 B396                <1>   mov bl,96h                ; 10010110b
   144 000000E4 B400                <1>   mov ah,0
   145 000000E6 B080                <1>   mov al,80h
   146 000000E8 E608                <1>   out 8,al                  ; read sector
   147 000000EA D40A<rep 4h>        <1>   times 4 aam               ; wait
   148                              <1> 
   149                              <1> check_status_1:
   150 000000F2 E408                <1>   in al,8                   ; read status
   151 000000F4 D0F8                <1>   sar al,1                  ; status/=2
   152 000000F6 731F                <1>   jnb check_status_3
   153 000000F8 75F8                <1>   jnz check_status_1
   154                              <1> 
   155                              <1> wait_for_data:
   156 000000FA E408                <1>   in al,8                   ; read status
   157 000000FC 20D8                <1>   and al,bl                 ; 96h
   158 000000FE 74FA                <1>   jz wait_for_data
   159                              <1> 
   160                              <1> store_byte_1:
   161 00000100 E40E                <1>   in al,0Eh
   162 00000102 AA                  <1>   stosb
   163                              <1> 
   164                              <1> check_status_2:
   165 00000103 E408                <1>   in al,8                   ; read status
   166 00000105 48                  <1>   dec ax                    ; status--
   167 00000106 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   168 00000108 38F8                <1>   cmp al, bh                ; bh=2
   169 0000010A 750B                <1>   jnz check_status_3        ; if (status==1) 
   170                              <1> 
   171                              <1> store_byte_2:
   172 0000010C E40E                <1>   in al,0Eh  
   173 0000010E AA                  <1>   stosb
   174                              <1> 
   175                              <1> check_status_4:
   176 0000010F E408                <1>   in al,8                   ; read status
   177 00000111 38F8                <1>   cmp al, bh                ; bh=2
   178 00000113 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   179 00000115 EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   180                              <1> 
   181                              <1> ; ───────────────────────────────────────────────────────────────────────────
   182                              <1> 
   183                              <1> check_status_3:
   184 00000117 E408                <1>   in al, 8                  ; read status
   185 00000119 A81C                <1>   test al, 1Ch              ; 00011100
   186 0000011B 7402                <1>   jz while_sectors
   187 0000011D EBBD                <1>   jmp read_sector
   188                              <1> 
   189                              <1> ; ───────────────────────────────────────────────────────────────────────────
   190                              <1> 
   191                              <1> while_sectors:
   192 0000011F E80F00              <1>   call progress_bar
   193 00000122 E299                <1>   loop next_sector
   194                              <1> 
   195                              <1> done_reading:
   196 00000124 0E                  <1>   push cs
   197 00000125 17                  <1>   pop ss
   198 00000126 BC0000              <1>   mov sp,0
   199 00000129 E82D00              <1>   call clear_green
   200 0000012C 0E                  <1>   push cs
   201 0000012D 1F                  <1>   pop ds
   202 0000012E E9CE01              <1>   jmp setup
   203                              <1> 
   204                              <1> ; ───────────────────────────────────────────────────────────────────────────
   205                              <1> 
   206                              <1> progress_bar:
   207                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   208 00000131 52                  <1>   push dx
   209 00000132 53                  <1>   push bx
   210 00000133 31D2                <1>   xor dx,dx
   211 00000135 B81E00              <1>   mov ax,BAR_WIDTH
   212 00000138 BB2800              <1>   mov bx,NUM_SECTORS    
   213 0000013B F7E1                <1>   mul cx
   214 0000013D F7F3                <1>   div bx
   215 0000013F 5B                  <1>   pop bx
   216 00000140 5A                  <1>   pop dx
   217 00000141 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   218 00000143 D1E6                <1>   shl si,1                  ; *=2
   219 00000145 D1E6                <1>   shl si,1                  ; *=2  
   220 00000147 BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   221 0000014A 29F5                <1>   sub bp,si
   222 0000014C 3EC64600FF          <1>   mov byte [ds:bp],-1
   223 00000151 C3                  <1>   ret
   224                              <1> 
   225                              <1> clear_red:
   226 00000152 B800F0              <1>   mov ax,RED
   227 00000155 E81900              <1>   call clear_channel
   228 00000158 C3                  <1>   ret
   229                              <1> 
   230                              <1> clear_green:
   231 00000159 B8001C              <1>   mov ax,GREEN
   232 0000015C E81200              <1>   call clear_channel
   233 0000015F C3                  <1>   ret
   234                              <1> 
   235                              <1> clear_blue:
   236 00000160 B800F4              <1>   mov ax,BLUE
   237 00000163 E80B00              <1>   call clear_channel
   238 00000166 C3                  <1>   ret
   239                              <1> 
   240                              <1> clear_screen:
   241 00000167 E8E8FF              <1>   call clear_red
   242 0000016A E8ECFF              <1>   call clear_green
   243 0000016D E8F0FF              <1>   call clear_blue
   244 00000170 C3                  <1>   ret
   245                              <1> 
   246                              <1> clear_channel:
   247 00000171 8EC0                <1>   mov es,ax
   248 00000173 B9201C              <1>   mov cx,COLS*ROWS*2
   249 00000176 31FF                <1>   xor di,di
   250 00000178 31C0                <1>   xor ax,ax
   251 0000017A F3AB                <1>   rep stosw         ; clear screen
   252 0000017C C3                  <1>   ret
   253                              <1> 
   254                              <1> ; ───────────────────────────────────────────────────────────────────────────
   255                              <1> 
   256                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   257                              <1>   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   258                              <1>   
   259                              <1>   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   260                              <1> 
   261                              <1>   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   262                              <1> 
   263 0000017D 1E                  <1>   push ds
   264 0000017E 06                  <1>   push es
   265                              <1> 
   266 0000017F 50                  <1>   push ax
   267 00000180 50                  <1>   push ax
   268 00000181 B8001C              <1>   mov ax,GREEN
   269 00000184 8EC0                <1>   mov es,ax
   270 00000186 B800FF              <1>   mov ax,FONT
   271 00000189 8ED8                <1>   mov ds,ax
   272 0000018B 58                  <1>   pop ax
   273 0000018C B408                <1>   mov ah,8
   274 0000018E F6E4                <1>   mul ah        ; al*=ah
   275 00000190 89C6                <1>   mov si,ax
   276 00000192 A5                  <1>   movsw
   277 00000193 A5                  <1>   movsw
   278 00000194 81C71C01            <1>   add di,0x11c
   279 00000198 A5                  <1>   movsw
   280 00000199 A5                  <1>   movsw
   281 0000019A 81EF2001            <1>   sub di,0x120
   282 0000019E 81FF4038            <1>   cmp di,14400   ; dit later oplossen met cursor positie
   283 000001A2 7202                <1>   jb .return
   284 000001A4 31FF                <1>   xor di,di      ; move to left top. change later to scroll
   285                              <1> .return
   286 000001A6 58                  <1>   pop ax
   287                              <1> 
   288 000001A7 07                  <1>   pop es
   289 000001A8 1F                  <1>   pop ds
   290 000001A9 C3                  <1>   ret
   291                              <1> 
   292                              <1> ; ───────────────────────────────────────────────────────────────────────────
   293                              <1> 
   294                              <1> write_string:
   295 000001AA 2E8A07              <1>   mov al,[cs:bx]
   296 000001AD 43                  <1>   inc bx
   297 000001AE 08C0                <1>   or al,al
   298 000001B0 7405                <1>   jz .return
   299 000001B2 E8C8FF              <1>   call write_char
   300 000001B5 EBF3                <1>   jmp short write_string
   301                              <1> .return
   302 000001B7 C3                  <1>   ret
   303                              <1> 
   304                              <1> ; ───────────────────────────────────────────────────────────────────────────
   305                              <1> 
   306                              <1> write_binary_byte:    ; input AL
   307 000001B8 50                  <1>   push ax
   308 000001B9 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   309 000001BB B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   310                              <1> .lp:
   311 000001BE D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   312 000001C0 B80000              <1>   mov ax, 0           ; AH leegmaken
   313 000001C3 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   314 000001C5 51                  <1>   push cx             ; CX opslaan
   315 000001C6 E8B4FF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   316 000001C9 59                  <1>   pop cx              ; CX herstellen
   317 000001CA E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   318 000001CC 58                  <1>   pop ax
   319 000001CD C3                  <1>   ret
   320                              <1> 
   321                              <1> ; ───────────────────────────────────────────────────────────────────────────
   322                              <1> 
   323                              <1> write_binary_word:    ; input AX
   324 000001CE 50                  <1>   push ax
   325 000001CF 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   326 000001D0 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   327 000001D2 B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   328                              <1> .lp:
   329 000001D5 D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   330 000001D7 B80000              <1>   mov ax, 0          ; AH leegmaken
   331 000001DA 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   332 000001DC 51                  <1>   push cx            ; CX opslaan
   333 000001DD E89DFF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   334 000001E0 59                  <1>   pop cx             ; CX herstellen
   335 000001E1 E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   336 000001E3 5A                  <1>   pop dx             ; DX herstellen
   337 000001E4 58                  <1>   pop ax
   338 000001E5 C3                  <1>   ret
   339                              <1> 
   340                              <1> ; ───────────────────────────────────────────────────────────────────────────
   341                              <1> 
   342                              <1> write_number_word:
   343 000001E6 50                  <1>     push ax
   344 000001E7 52                  <1>     push dx
   345 000001E8 31D2                <1>     xor dx,dx
   346 000001EA 52                  <1>     push dx ;high byte is zero
   347 000001EB 31D2                <1> .clp xor dx,dx
   348 000001ED 2EF736[0902]        <1>     cs div word [.base]
   349 000001F2 92                  <1>     xchg ax,dx
   350 000001F3 05300E              <1>     add ax,0xe30
   351 000001F6 50                  <1>     push ax
   352 000001F7 92                  <1>     xchg ax,dx
   353 000001F8 09C0                <1>     or ax,ax
   354 000001FA 75EF                <1>     jnz .clp
   355 000001FC 58                  <1> .dlp pop ax
   356 000001FD 08E4                <1>     or ah,ah
   357 000001FF 7405                <1>     jz .done
   358 00000201 E879FF              <1>     call write_char
   359 00000204 EBF6                <1>     jmp short .dlp
   360 00000206 5A                  <1> .done pop dx
   361 00000207 58                  <1>     pop ax
   362 00000208 C3                  <1>     ret
   363 00000209 0A00                <1> .base dw 10
   364                              <1> 
   365                              <1> ; ───────────────────────────────────────────────────────────────────────────
   366                              <1> 
   367                              <1> write_signed_number_word:    
   368 0000020B 09C0                <1>     or ax,ax
   369 0000020D 790A                <1>     jns .write_return        ; if >0 write and return
   370 0000020F 50                  <1>     push ax
   371 00000210 B82D00              <1>     mov ax,'-'
   372 00000213 E867FF              <1>     call write_char
   373 00000216 58                  <1>     pop ax
   374 00000217 F7D8                <1>     neg ax                   ; destroys ax when negative
   375                              <1> .write_return:
   376 00000219 E8CAFF              <1>     call write_number_word
   377 0000021C C3                  <1>     ret
   378                              <1> 
   379                              <1> ; ───────────────────────────────────────────────────────────────────────────
   380                              <1> 
   381                              <1> check_keys:
   382 0000021D E43A                <1>   in al,0x3a        ; get keyboard status
   383 0000021F 88C4                <1>   mov ah,al
   384 00000221 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   385 00000223 2EA2[0500]          <1>   mov [cs:key.ctrl],al
   386 00000227 F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   387 0000022A 7410                <1>   jz .return
   388 0000022C E438                <1>   in al,0x38        ; get data byte from keyboard  
   389 0000022E 2EA2[0400]          <1>   mov [cs:key.code],al
   390 00000232 B037                <1>   mov al,0x37
   391 00000234 E63A                <1>   out 0x3a,al       ; drop key?  
   392 00000236 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   393 00000238 2EA1[0400]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   394 0000023C C3                  <1> .return ret
   395                              <1> 
   396                              <1> 
   397                              <1> 
   398                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   399                              <1> ;   ret
   400                              <1> 
   401                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   402                              <1> 
   403                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   404                              <1> ; much faster and simpler on the grid than off the grid
   405                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   406                              <1> 
   407                              <1> 
   408                              <1> ; wide font by stretching the font horizontally using bitshift
   409                              <1> 
   410                              <1> 
   411                              <1> ; fill_white:
   412                              <1> ;   mov ax,0xffff
   413                              <1> ;   call fill_red
   414                              <1> ;   call fill_green
   415                              <1> ;   call fill_blue
   416                              <1> ;   ret
   417                              <1> 
   418                              <1> ; fill_pink:
   419                              <1> ;   mov ax,0xffff
   420                              <1> ;   call fill_red
   421                              <1> ;   mov ah,0b01010101
   422                              <1> ;   mov al,0b10101010
   423                              <1> ;   call fill_green
   424                              <1> ;   call fill_blue
   425                              <1> ;   ret
   426                              <1> 
   427                              <1> ; fill_pink2:
   428                              <1> ;   mov ax,0xffff
   429                              <1> ;   call fill_red
   430                              <1> ;   mov ah,0b11001100
   431                              <1> ;   mov al,0b00110011
   432                              <1> ;   call fill_green
   433                              <1> ;   call fill_blue
   434                              <1> ;   ret
   435                              <1> 
   436                              <1> ; fill_pink3:
   437                              <1> ;   mov ax,0xffff
   438                              <1> ;   call fill_red
   439                              <1> ;   mov ah,0b00010001
   440                              <1> ;   mov al,0b01000100
   441                              <1> ;   call fill_green
   442                              <1> ;   call fill_blue
   443                              <1> ;   ret
   444                              <1> 
   445                              <1> ; fill_pink4:
   446                              <1> ;   mov ax,0xffff
   447                              <1> ;   call fill_red
   448                              <1> ;   mov ah,0b11110111
   449                              <1> ;   mov al,0b01111111
   450                              <1> ;   call fill_green
   451                              <1> ;   call fill_blue
   452                              <1> ;   ret
   453                              <1> 
   454                              <1> ; fill_red:
   455                              <1> ;   mov bx,RED
   456                              <1> ;   call fill_channel
   457                              <1> ;   ret
   458                              <1> ; fill_green:
   459                              <1> ;   mov bx,GREEN
   460                              <1> ;   call fill_channel
   461                              <1> ;   ret
   462                              <1> ; fill_blue:
   463                              <1> ;   mov bx,BLUE
   464                              <1> ;   call fill_channel
   465                              <1> ;   ret
   466                              <1> 
   467                              <1> ; fill_channel: ;ax=pattern
   468                              <1> ;   mov es,bx
   469                              <1> ;   mov cx,COLS*ROWS*2
   470                              <1> ;   xor di,di
   471                              <1> ;   rep stosw
   472                              <1> ;   ret
   473                              <1> 
   474                              <1> ; ───────────────────────────────────────────────────────────────────────────
   475                              <1> 
   476                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   477                              <1> ;   push bx
   478                              <1> ;   push di
   479                              <1> ;   mov es,ax
   480                              <1> ;   xor cx,cx
   481                              <1> ;   mov cl,bh        ; rows (bl)
   482                              <1> ; .rows_loop:
   483                              <1> ;   push cx
   484                              <1> ;   xor cx,cx
   485                              <1> ;   mov cl,bl        ; cols (bh)
   486                              <1> ; .cols_loop:
   487                              <1> ;   mov ax,0
   488                              <1> ;   stosw
   489                              <1> ;   stosw
   490                              <1> ;   loop .cols_loop
   491                              <1> ;   add di,COLS*4    ; one row down
   492                              <1> ;   mov ah,0
   493                              <1> ;   mov al,bl
   494                              <1> ;   times 2 shl ax,1
   495                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   496                              <1> ;   pop cx
   497                              <1> ;   loop .rows_loop
   498                              <1> ;   pop di
   499                              <1> ;   pop bx
   500                              <1> ;   ret
   501                              <1> 
   502                              <1> ; ───────────────────────────────────────────────────────────────────────────
   503                              <1> 
   504                              <1> ; fill_rect_black: 
   505                              <1> ;   mov ax,RED
   506                              <1> ;   call clear_area
   507                              <1> ;   mov ax,GREEN
   508                              <1> ;   call clear_area
   509                              <1> ;   mov ax,BLUE
   510                              <1> ;   call clear_area
   511                              <1> ;   ret
   512                              <1> 
   513                              <1> ; ───────────────────────────────────────────────────────────────────────────
   514                              <1> 
   515                              <1> draw_spr:
   516 0000023D 8B1C                <1>   mov bx,[si]
   517 0000023F 46<rep 2h>          <1>   times 2 inc si
   518                              <1> draw_pic:
   519 00000241 B800F0              <1>   mov ax, RED
   520 00000244 E80D00              <1>   call draw_channel
   521 00000247 B8001C              <1>   mov ax, GREEN
   522 0000024A E80700              <1>   call draw_channel
   523 0000024D B800F4              <1>   mov ax, BLUE
   524 00000250 E80100              <1>   call draw_channel
   525 00000253 C3                  <1>   ret
   526                              <1> 
   527                              <1> ; ───────────────────────────────────────────────────────────────────────────
   528                              <1> 
   529                              <1> draw_channel:
   530 00000254 57                  <1>   push di
   531 00000255 8EC0                <1>   mov es,ax
   532 00000257 31C9                <1>   xor cx,cx
   533 00000259 88F9                <1>   mov cl,bh        ; rows (bl)
   534                              <1> .rows_loop:
   535 0000025B 51                  <1>   push cx
   536 0000025C 31C9                <1>   xor cx,cx
   537 0000025E 88D9                <1>   mov cl,bl        ; cols (bh)
   538                              <1> .cols_loop:
   539 00000260 A5                  <1>   movsw
   540 00000261 A5                  <1>   movsw
   541 00000262 E2FC                <1>   loop .cols_loop
   542 00000264 81C72001            <1>   add di,COLS*4    ; one row down
   543 00000268 B400                <1>   mov ah,0
   544 0000026A 88D8                <1>   mov al,bl
   545 0000026C D1E0<rep 2h>        <1>   times 2 shl ax,1
   546 00000270 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   547 00000272 59                  <1>   pop cx
   548 00000273 E2E6                <1>   loop .rows_loop
   549 00000275 5F                  <1>   pop di
   550 00000276 C3                  <1>   ret
   551                              <1> 
   552                              <1> ; ───────────────────────────────────────────────────────────────────────────
   553                              <1> 
   554                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   555 00000277 B89000              <1>   mov ax,144      ; 2*72 cols
   556 0000027A F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   557 0000027C D1E0                <1>   shl ax,1        ; verdubbel AX
   558 0000027E 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   559 00000280 D0E3                <1>   shl bl,1        ; bl*=2
   560 00000282 D0E3                <1>   shl bl,1        ; bl*=2
   561 00000284 B700                <1>   mov bh,0
   562 00000286 01DF                <1>   add di,bx       ; di+=bl
   563 00000288 C3                  <1>   ret
   564                              <1> ; ───────────────────────────────────────────────────────────────────────────
   565                              <1> 
   566                              <1> 
   567                              <1> ; set_cursor:
   568                              <1> ; cursor_next_char
   569                              <1> 
   570                              <1> 
   571                              <1> 
   572                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   573                              <1> 
     2                                  %include "atan.asm"
     1                              <1> atan: ; cx=z, return value in ax, bx destroyed, cx destroyed, dx destroyed
     2 00000289 59                  <1>   pop cx  ; get z from the stack
     3                              <1> 
     4 0000028A 83F96F              <1>   cmp cx,111
     5 0000028D 7732                <1>   ja .if_z_gt_scale  ; if (z>111)
     6                              <1> 
     7 0000028F 83F991              <1>   cmp cx,-111        ; if (z<-111) 
     8 00000292 7241                <1>   jb .if_z_lt_minus_scale
     9                              <1> 
    10                              <1>   ;else
    11 00000294 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    12 00000296 F7E8                <1>   imul ax              ; ax *= ax  (z*z)
    13 00000298 BB4D01              <1>   mov bx,333
    14 0000029B 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    15 0000029D F7FB                <1>   idiv bx             ; ax /= 333   Taylor-benadering
    16 0000029F 89C3                <1>   mov bx,ax
    17 000002A1 B86F00              <1>   mov ax,111
    18 000002A4 29D8                <1>   sub ax,bx          ; ax-=111
    19 000002A6 BBB400              <1>   mov bx,180
    20 000002A9 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    21 000002AB F7EB                <1>   imul bx             ; ax*=180
    22 000002AD 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    23 000002AF F7E9                <1>   imul cx             ; ax*=z
    24 000002B1 BB6F00              <1>   mov bx,111
    25 000002B4 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    26 000002B6 F7FB                <1>   idiv bx             ; ax/=111
    27 000002B8 BB3A01              <1>   mov bx,314
    28 000002BB 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    29 000002BD F7FB                <1>   idiv bx             ; ax/=314
    30 000002BF EB26                <1>   jmp .return
    31                              <1> 
    32                              <1> .if_z_gt_scale:
    33 000002C1 B82130              <1>   mov ax, 12321       ; 12321 = 111*111 (squared scale)
    34 000002C4 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    35 000002C6 F7F9                <1>   idiv cx             ; ax/=z
    36 000002C8 50                  <1>   push ax   ; put on the stack for recursion
    37 000002C9 E8BDFF              <1>   call atan          ; recursion
    38 000002CC 89C3                <1>   mov bx,ax
    39 000002CE B85A00              <1>   mov ax,90
    40 000002D1 29D8                <1>   sub ax,bx
    41 000002D3 EB12                <1>   jmp .return
    42                              <1> 
    43                              <1> .if_z_lt_minus_scale:
    44 000002D5 B82130              <1>   mov ax, 12321      ; 12321 = 111*111 (squared scale)
    45 000002D8 31D2                <1>   xor dx,dx           ; dx=0 (prevent overflow) 
    46 000002DA F7F9                <1>   idiv cx             ; ax/=z
    47 000002DC 50                  <1>   push ax   ; put on the stack for recursion
    48 000002DD E8A9FF              <1>   call atan          ; recursion
    49 000002E0 89C3                <1>   mov bx,ax
    50 000002E2 B8A6FF              <1>   mov ax,-90
    51 000002E5 29D8                <1>   sub ax,bx
    52                              <1> 
    53                              <1> .return:
    54 000002E7 C3                  <1>   ret
    55                              <1> 
    56                              <1> 
    57                              <1> ; int atan2(int y, int x) {
    58                              <1> ;   if (x!=0) {
    59                              <1> ;     ax = y;
    60                              <1> ;     ax *= 111;
    61                              <1> ;     ax /= x;
    62                              <1> ;     ax = atan(ax);
    63                              <1> ;   }
    64                              <1> ;   if (x < 0 && y >= 0) ax+=180;
    65                              <1> ;   else if (x < 0 && y < 0) ax-=180;
    66                              <1> ;   else if (x == 0 && y > 0) ax=90;
    67                              <1> ;   else if (x == 0 && y < 0) ax=-90;
    68                              <1> ;   return ax;
    69                              <1> ; }
    70                              <1> 
    71                              <1> 
    72                              <1> ; ───────────────────────────────────────────────────────────────────────────
     3                                  
     4                                  ship:
     5                                   .pos:
     6 000002E8 0090                     .pos.x: dw 73728/2
     7 000002EA D06B                     .pos.y: dw 51200/2 + 2000
     8                                   .vel: 
     9 000002EC F6FF                     .vel.x: dw -10
    10 000002EE 0000                     .vel.y: dw 0
    11 000002F0 0000                     .vel.flags: dw 0
    12                                   .acc:
    13 000002F2 0000                     .acc.x: dw 0
    14 000002F4 0000                     .acc.y: dw 0
    15                                   .forces:
    16 000002F6 0000                     .forces.x: dw 0
    17 000002F8 0000                     .forces.y: dw 0
    18 000002FA 0000                     .angle: dw 0
    19 000002FC 0000                     .prev_di: dw 0
    20                                  
    21 000002FE 02                      color: db Color.G
    22                                  
    23                                  ; ───────────────────────────────────────────────────────────────────────────
    24                                  
    25                                  setup:
    26                                  
    27                                    set_cursor 2,5
    45 000002FF BF9404              <1>  mov di,%1 * BYTES_PER_ROW + %2 * 4
    46                              <1> 
    28                                    ; print "atan(426)="
    29                                  
    30                                    ; mov cx,426
    31                                    ; call atan
    32                                  
    33                                    ; mov ax,426
    34                                    ; push ax             ; put z on the stack
    35                                    ; call atan
    36                                    
    37 00000302 B82130                    mov ax, 12321       ; 12321 = 111*111 (squared scale)
    38                                    ; xor dx,dx           ; dx=0 (prevent overflow) 
    39                                    ; idiv cx             ; ax/=z
    40 00000305 E8DEFE                    call write_number_word
    41                                  
    42 00000308 F4                        hlt
    43                                  
    44                                  
    45                                    ; xor bp,bp
    46                                    ; jmp draw
    47                                  
    48                                  ; ───────────────────────────────────────────────────────────────────────────
    49                                  
    50                                  ; vec_mult:   ; cx scalar, ax=x, bx=y
    51                                    
    52                                  FRICTION equ 94
    53                                  
    54                                  update_ship:
    55                                    
    56                                    ; x+=vx
    57 00000309 A1[E802]                  mov ax,[ship.pos.x]       ; 0..73728  (65536)
    58 0000030C 0306[EC02]                add ax,[ship.vel.x]
    59 00000310 A3[E802]                  mov [ship.pos.x],ax
    60                                  
    61                                    ; y+=vy
    62 00000313 A1[EA02]                  mov ax,[ship.pos.y]       ; 0..51200  (=1024*50)
    63 00000316 0306[EE02]                add ax,[ship.vel.y]
    64 0000031A A3[EA02]                  mov [ship.pos.y],ax
    65                                  
    66                                    ; vx*=98%
    67 0000031D A1[EC02]                  mov ax, [ship.vel.x]
    68 00000320 99                        cwd                 ; Convert word to double word (sign-extend AX into DX)
    69 00000321 B95E00                    mov cx, FRICTION
    70 00000324 F7E9                      imul cx             ; Signed multiplication
    71 00000326 B96400                    mov cx, 100
    72 00000329 F7F9                      idiv cx             ; Signed division
    73 0000032B A3[EC02]                  mov [ship.vel.x], ax
    74                                  
    75                                    ; vy*=98%
    76 0000032E A1[EE02]                  mov ax, [ship.vel.y]
    77 00000331 99                        cwd                 ; Convert word to double word (sign-extend AX into DX)
    78 00000332 B95E00                    mov cx, FRICTION
    79 00000335 F7E9                      imul cx             ; Signed multiplication
    80 00000337 B96400                    mov cx, 100
    81 0000033A F7F9                      idiv cx             ; Signed division
    82 0000033C A3[EE02]                  mov [ship.vel.y], ax
    83                                  
    84 0000033F C3                        ret
    85                                  
    86                                  ; ───────────────────────────────────────────────────────────────────────────
    87                                  
    88                                  draw_ship:
    89                                  
    90 00000340 A1[E802]                  mov ax,[ship.pos.x]
    91 00000343 8B1E[EA02]                mov bx,[ship.pos.y]
    92 00000347 E8FC00                    call world2screen
    93 0000034A E82AFF                    call calc_di_from_bx
    94                                  
    95 0000034D 393E[FC02]                cmp [ship.prev_di],di
    96 00000351 742B                      je .return
    97                                  
    98                                    ; call world2screen ; ax and bx are already set by pop bx, pop ax
    99                                    ; call calc_di_from_bx
   100                                  
   101 00000353 8B3E[FC02]                mov di,[ship.prev_di]
   102                                    
   103 00000357 BB0808                    mov bx,0x0808  ; rows,cols
   104                                    ; call fill_rect_black
   105                                  
   106 0000035A A1[E802]                  mov ax,[ship.pos.x]
   107 0000035D 8B1E[EA02]                mov bx,[ship.pos.y]
   108 00000361 E8E200                    call world2screen
   109 00000364 E810FF                    call calc_di_from_bx
   110 00000367 893E[FC02]                mov [ship.prev_di],di
   111                                  
   112                                  
   113 0000036B BE[5307]                  mov si,img_up
   114 0000036E A1[E802]                  mov ax,[ship.pos.x]
   115 00000371 8B1E[EA02]                mov bx,[ship.pos.y]
   116 00000375 E8CE00                    call world2screen ; ax and bx are already set by pop bx, pop ax
   117 00000378 E8FCFE                    call calc_di_from_bx
   118 0000037B E8BFFE                    call draw_spr
   119                                  
   120                                  .return
   121 0000037E C3                        ret
   122                                  
   123                                  ; ───────────────────────────────────────────────────────────────────────────
   124                                  
   125                                  draw:
   126 0000037F 0E                        push cs
   127 00000380 1F                        pop ds   ; make sure DS is set to CS for data lookups like [ship.pos.x]
   128                                  
   129 00000381 E885FF                    call update_ship
   130 00000384 E8B9FF                    call draw_ship
   131                                  
   132 00000387 E8B400                    call _wait
   133                                  
   134 0000038A 45                        inc bp
   135                                  
   136                                    set_cursor 12,45
    45 0000038B BFB41B              <1>  mov di,%1 * BYTES_PER_ROW + %2 * 4
    46                              <1> 
   137                                    print "frame: "
    50 0000038E EB08                <1>  jmp %%endstr
    51 00000390 6672616D653A2000    <1>  %%str: db %1,0
    52                              <1>  %%endstr:
    53 00000398 BB[9003]            <1>  mov bx,%%str
    54 0000039B E80CFE              <1>  call write_string
   138 0000039E 89E8                      mov ax,bp
   139 000003A0 E843FE                    call write_number_word     ; draw frame counter
   140                                    print "  "
    50 000003A3 EB03                <1>  jmp %%endstr
    51 000003A5 202000              <1>  %%str: db %1,0
    52                              <1>  %%endstr:
    53 000003A8 BB[A503]            <1>  mov bx,%%str
    54 000003AB E8FCFD              <1>  call write_string
   141                                  
   142                                    set_cursor 13,45
    45 000003AE BFF41D              <1>  mov di,%1 * BYTES_PER_ROW + %2 * 4
    46                              <1> 
   143                                    print "vx: "
    50 000003B1 EB05                <1>  jmp %%endstr
    51 000003B3 76783A2000          <1>  %%str: db %1,0
    52                              <1>  %%endstr:
    53 000003B8 BB[B303]            <1>  mov bx,%%str
    54 000003BB E8ECFD              <1>  call write_string
   144 000003BE A1[EC02]                  mov ax,[ship.vel.x]  
   145 000003C1 E847FE                    call write_signed_number_word
   146                                    print "  "
    50 000003C4 EB03                <1>  jmp %%endstr
    51 000003C6 202000              <1>  %%str: db %1,0
    52                              <1>  %%endstr:
    53 000003C9 BB[C603]            <1>  mov bx,%%str
    54 000003CC E8DBFD              <1>  call write_string
   147                                  
   148                                    set_cursor 14,45
    45 000003CF BF3420              <1>  mov di,%1 * BYTES_PER_ROW + %2 * 4
    46                              <1> 
   149                                    print "vy: "
    50 000003D2 EB05                <1>  jmp %%endstr
    51 000003D4 76793A2000          <1>  %%str: db %1,0
    52                              <1>  %%endstr:
    53 000003D9 BB[D403]            <1>  mov bx,%%str
    54 000003DC E8CBFD              <1>  call write_string
   150 000003DF A1[EE02]                  mov ax,[ship.vel.y]
   151 000003E2 E826FE                    call write_signed_number_word     ; draw vy
   152                                    print "  "
    50 000003E5 EB03                <1>  jmp %%endstr
    51 000003E7 202000              <1>  %%str: db %1,0
    52                              <1>  %%endstr:
    53 000003EA BB[E703]            <1>  mov bx,%%str
    54 000003ED E8BAFD              <1>  call write_string
   153                                  
   154 000003F0 E82AFE                    call check_keys
   155 000003F3 7502                      jnz on_key
   156                                    ;else
   157 000003F5 EB88                      jmp draw          ; this code is only getting called when no key is pressed
   158                                  
   159                                  ; ───────────────────────────────────────────────────────────────────────────
   160                                  
   161                                  on_key:
   162                                    set_cursor 2,10
    45 000003F7 BFA804              <1>  mov di,%1 * BYTES_PER_ROW + %2 * 4
    46                              <1> 
   163 000003FA A1[0400]                  mov ax,[key]
   164 000003FD E8CEFD                    call write_binary_word
   165 00000400 83F877                    cmp ax,'w'
   166 00000403 7412                      je on_key_w
   167 00000405 83F861                    cmp ax,'a'
   168 00000408 7415                      je on_key_a
   169 0000040A 83F873                    cmp ax,'s'
   170 0000040D 7418                      je on_key_s
   171 0000040F 83F864                    cmp ax,'d'
   172 00000412 741B                      je on_key_d
   173                                  .done
   174 00000414 E968FF                    jmp draw  ; no ret here because onkey is called by jnz
   175                                  
   176                                  
   177                                  STEP equ 500
   178                                  
   179                                  ; ───────────────────────────────────────────────────────────────────────────
   180                                  
   181                                  on_key_w:
   182 00000417 812E[EE02]F401            sub word [ship.vel.y], STEP
   183 0000041D EBF5                      jmp on_key.done
   184                                  
   185                                  ; ───────────────────────────────────────────────────────────────────────────
   186                                  
   187                                  on_key_a:
   188 0000041F 812E[EC02]F401            sub word [ship.vel.x], STEP
   189 00000425 EBED                      jmp on_key.done
   190                                  
   191                                  ; ───────────────────────────────────────────────────────────────────────────
   192                                  
   193                                  on_key_s:
   194 00000427 8106[EE02]F401            add word [ship.vel.y], STEP
   195 0000042D EBE5                      jmp on_key.done
   196                                  
   197                                  ; ───────────────────────────────────────────────────────────────────────────
   198                                  
   199                                  on_key_d:
   200 0000042F 8106[EC02]F401            add word [ship.vel.x], STEP
   201 00000435 EBDD                      jmp on_key.done
   202                                  
   203                                  ; ───────────────────────────────────────────────────────────────────────────
   204                                  
   205                                  print_msg:
   206                                    set_cursor 1,10
    45 00000437 BF6802              <1>  mov di,%1 * BYTES_PER_ROW + %2 * 4
    46                              <1> 
   207 0000043A E86DFD                    call write_string
   208 0000043D C3                        ret
   209                                  
   210                                  ; ───────────────────────────────────────────────────────────────────────────
   211                                  
   212                                  _wait:
   213                                    DELAY EQU 250
   214 0000043E B9FA00                    mov cx,DELAY
   215 00000441 D40A                      .lp aam
   216 00000443 E2FC                      loop .lp
   217 00000445 C3                        ret
   218                                  
   219                                  ; ───────────────────────────────────────────────────────────────────────────
   220                                  
   221                                  world2screen:  ; input (ax,bx) = (world.x, world.y)   ; screen (row,col)
   222                                    ; WORLD:
   223                                    ;   0..73728  (65536) -> col
   224                                    ;   0..51200  (=1024*50) -> row
   225                                    ; SCREEN (ROW,COL):
   226                                    ;   0..49 (row)
   227                                    ;   0..71 (col)
   228 00000446 B10A                      mov cl,10
   229 00000448 D3EB                      shr bx,cl   ; //bl=row 0..49
   230 0000044A D3E8                      shr ax,cl   ; 
   231 0000044C 88C7                      mov bh,al   ; //bh=col 0..71
   232 0000044E 86DF                      xchg bh,bl
   233 00000450 C3                        ret
   234                                  
   235                                  ; ───────────────────────────────────────────────────────────────────────────
   236                                  
   237                                  ; FIXME
   238 00000451 <bin 302h>              img_NONE: incbin "data/ship-24.spr"
   239                                  
   240                                  
   241                                  img_up:
   242 00000753 <bin 302h>              img1: incbin "data/ship-1.spr" ;up
   243 00000A55 <bin 302h>              img2: incbin "data/ship-2.spr"
   244 00000D57 <bin 302h>              img3: incbin "data/ship-3.spr"
   245                                  img_up_right:
   246 00001059 <bin 302h>              img4: incbin "data/ship-4.spr" ;up-right
   247 0000135B <bin 302h>              img5: incbin "data/ship-5.spr"
   248 0000165D <bin 302h>              img6: incbin "data/ship-6.spr"
   249                                  img_right:
   250 0000195F <bin 302h>              img7: incbin "data/ship-7.spr" ;right
   251 00001C61 <bin 302h>              img8: incbin "data/ship-8.spr"
   252 00001F63 <bin 302h>              img9: incbin "data/ship-9.spr"
   253                                  img_down_right:
   254 00002265 <bin 302h>              img10: incbin "data/ship-10.spr" ;down-right
   255 00002567 <bin 302h>              img11: incbin "data/ship-11.spr"
   256 00002869 <bin 302h>              img12: incbin "data/ship-12.spr"
   257                                  img_down:
   258 00002B6B <bin 302h>              img13: incbin "data/ship-13.spr" ;down
   259 00002E6D <bin 302h>              img14: incbin "data/ship-14.spr"
   260 0000316F <bin 302h>              img15: incbin "data/ship-15.spr"
   261                                  img_down_left:
   262 00003471 <bin 302h>              img16: incbin "data/ship-16.spr" ;down-left
   263 00003773 <bin 302h>              img17: incbin "data/ship-17.spr"
   264 00003A75 <bin 302h>              img18: incbin "data/ship-18.spr"
   265                                  img_left:
   266 00003D77 <bin 302h>              img19: incbin "data/ship-19.spr" ;left
   267 00004079 <bin 302h>              img20: incbin "data/ship-20.spr"
   268 0000437B <bin 302h>              img21: incbin "data/ship-21.spr"
   269                                  img_up_left:
   270 0000467D <bin 302h>              img22: incbin "data/ship-22.spr" ;up-left
   271 0000497F <bin 302h>              img23: incbin "data/ship-23.spr"
   272 00004C81 <bin 302h>              img24: incbin "data/ship-24.spr"
   273                                  
   274                                  
   275 00004F83 00<rep 2807Dh>          times (180*1024)-($-$$) db 0
   276                                  
   277                                  
   278                                  
