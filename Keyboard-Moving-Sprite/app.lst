     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 E9C700              <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 80          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34                              <1> cursor:
    35 00000003 00                  <1> .col: db 0
    36 00000004 00                  <1> .row: db 0
    37                              <1> 
    38                              <1> key:
    39 00000005 00                  <1>   .code db 0
    40 00000006 00                  <1>   .ctrl db 0
    41                              <1> 
    42                              <1> %macro set_cursor 2
    43                              <1>   ; mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    44                              <1>   mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    45                              <1> %endmacro
    46                              <1> 
    47                              <1> %macro print 1
    48                              <1>   push ax
    49                              <1>   push bx
    50                              <1>   push cx
    51                              <1>   push dx
    52                              <1>   jmp %%endstr 
    53                              <1>   %%str: db %1,0
    54                              <1>   %%endstr: 
    55                              <1>   mov bx,%%str
    56                              <1>   call write_string
    57                              <1>   pop dx
    58                              <1>   pop cx
    59                              <1>   pop bx
    60                              <1>   pop ax
    61                              <1> %endmacro
    62                              <1> 
    63                              <1> %macro println 1
    64                              <1>   print %1
    65                              <1>   call new_line
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro print_ax 0
    69                              <1>   call write_signed_number_word
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro print_ax_unsigned 0
    73                              <1>   call write_number_word
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro print_ax_hex 0
    77                              <1>   call write_ax_hex
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro print_ax_bin 0
    81                              <1>   call write_binary_word
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> ; ------------
    85                              <1> ; println
    86                              <1> 
    87                              <1> %macro println_ax 0
    88                              <1>   print_ax
    89                              <1>   call write_5spaces_newline
    90                              <1> %endmacro
    91                              <1> 
    92                              <1> %macro println_ax_unsigned 0
    93                              <1>   print_ax_unsigned
    94                              <1>   call write_5spaces_newline
    95                              <1> %endmacro
    96                              <1> 
    97                              <1> %macro println_ax_hex 0
    98                              <1>   print_ax_hex
    99                              <1>   call write_5spaces_newline
   100                              <1> %endmacro
   101                              <1> 
   102                              <1> %macro println_ax_bin 0
   103                              <1>   print_ax_bin
   104                              <1>   call write_5spaces_newline
   105                              <1> %endmacro
   106                              <1> 
   107                              <1> write_5spaces_newline:
   108 00000007 50                  <1>   push ax
   109 00000008 B82020              <1>   mov ax,"  "
   110 0000000B E80B00              <1>   call write_2chars
   111 0000000E E80800              <1>   call write_2chars
   112 00000011 E8B401              <1>   call write_char
   113 00000014 E8CD02              <1>   call new_line
   114 00000017 58                  <1>   pop ax
   115 00000018 C3                  <1>   ret
   116                              <1> 
   117                              <1> write_2chars:
   118 00000019 E8AC01              <1>   call write_char
   119 0000001C 86C4                <1>   xchg ah,al
   120 0000001E E8A701              <1>   call write_char
   121 00000021 C3                  <1>   ret
   122                              <1> 
   123                              <1> %macro register_interrupt 1
   124                              <1>   mov ax,%1
   125                              <1>   stosw
   126                              <1>   mov ax,cs
   127                              <1>   stosw
   128                              <1> %endmacro
   129                              <1> 
   130                              <1> ; int0: hlt
   131                              <1> ; int1: hlt
   132                              <1> ; int2: hlt
   133                              <1> ; int3: hlt
   134                              <1> ; int4: hlt
   135                              <1> 
   136                              <1> int0:; int0: Division by zero
   137 00000022 FC                  <1>   cld
   138 00000023 B800F4              <1>   mov ax,BLUE
   139 00000026 8EC0                <1>   mov es,ax
   140 00000028 31FF                <1>   xor di,di
   141 0000002A B9201C              <1>   mov cx,7200
   142 0000002D B8FFFF              <1>   mov ax,-1
   143 00000030 F3AB                <1>   rep stosw
   144                              <1>   set_cursor 1,1
    43                              <2> 
    44 00000032 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   145                              <1>   print "Division by zero"
    48 00000035 50                  <2>  push ax
    49 00000036 53                  <2>  push bx
    50 00000037 51                  <2>  push cx
    51 00000038 52                  <2>  push dx
    52 00000039 EB11                <2>  jmp %%endstr
    53 0000003B 4469766973696F6E20- <2>  %%str: db %1,0
    53 00000044 6279207A65726F00    <2>
    54                              <2>  %%endstr:
    55 0000004C BB[3B00]            <2>  mov bx,%%str
    56 0000004F E8B101              <2>  call write_string
    57 00000052 5A                  <2>  pop dx
    58 00000053 59                  <2>  pop cx
    59 00000054 5B                  <2>  pop bx
    60 00000055 58                  <2>  pop ax
   146                              <1>   set_cursor 3,1
    43                              <2> 
    44 00000056 BF8004              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   147 00000059 58                  <1>   pop ax
   148                              <1>   print "IP="
    48 0000005A 50                  <2>  push ax
    49 0000005B 53                  <2>  push bx
    50 0000005C 51                  <2>  push cx
    51 0000005D 52                  <2>  push dx
    52 0000005E EB04                <2>  jmp %%endstr
    53 00000060 49503D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000064 BB[6000]            <2>  mov bx,%%str
    56 00000067 E89901              <2>  call write_string
    57 0000006A 5A                  <2>  pop dx
    58 0000006B 59                  <2>  pop cx
    59 0000006C 5B                  <2>  pop bx
    60 0000006D 58                  <2>  pop ax
   149                              <1>   println_ax_hex
    98                              <2>  print_ax_hex
    77 0000006E E89002              <3>  call write_ax_hex
    99 00000071 E893FF              <2>  call write_5spaces_newline
   150 00000074 E86D02              <1>   call new_line
   151                              <1>   print "CS="
    48 00000077 50                  <2>  push ax
    49 00000078 53                  <2>  push bx
    50 00000079 51                  <2>  push cx
    51 0000007A 52                  <2>  push dx
    52 0000007B EB04                <2>  jmp %%endstr
    53 0000007D 43533D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000081 BB[7D00]            <2>  mov bx,%%str
    56 00000084 E87C01              <2>  call write_string
    57 00000087 5A                  <2>  pop dx
    58 00000088 59                  <2>  pop cx
    59 00000089 5B                  <2>  pop bx
    60 0000008A 58                  <2>  pop ax
   152 0000008B 58                  <1>   pop ax
   153                              <1>   println_ax_hex
    98                              <2>  print_ax_hex
    77 0000008C E87202              <3>  call write_ax_hex
    99 0000008F E875FF              <2>  call write_5spaces_newline
   154 00000092 E84F02              <1>   call new_line
   155                              <1>   print "FLAGS="
    48 00000095 50                  <2>  push ax
    49 00000096 53                  <2>  push bx
    50 00000097 51                  <2>  push cx
    51 00000098 52                  <2>  push dx
    52 00000099 EB07                <2>  jmp %%endstr
    53 0000009B 464C4147533D00      <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000000A2 BB[9B00]            <2>  mov bx,%%str
    56 000000A5 E85B01              <2>  call write_string
    57 000000A8 5A                  <2>  pop dx
    58 000000A9 59                  <2>  pop cx
    59 000000AA 5B                  <2>  pop bx
    60 000000AB 58                  <2>  pop ax
   156 000000AC 58                  <1>   pop ax
   157 000000AD E87701              <1>   call write_binary_word
   158 000000B0 F4                  <1>   hlt
   159                              <1> 
   160                              <1> int1:; int1: Single step debugging
   161 000000B1 B001                <1>   mov al,1
   162 000000B3 EB0C                <1>   jmp int_msg
   163                              <1> int2:; int2: Non maskable interrupt
   164 000000B5 B002                <1>   mov al,2
   165 000000B7 EB08                <1>   jmp int_msg
   166                              <1> int3:; int3: For one-byte interrupt
   167 000000B9 B003                <1>   mov al,3
   168 000000BB EB04                <1>   jmp int_msg
   169                              <1>   ; push ax
   170                              <1>   ; push bx
   171                              <1>   ; push cx
   172                              <1>   ; push dx
   173                              <1>   ; push si
   174                              <1>   ; push di
   175                              <1>   ; push bp
   176                              <1>   ; push ds
   177                              <1>   ; push es
   178                              <1> 
   179                              <1>   ; ; mov di,10*4
   180                              <1>   ; ; set_cursor 5,5
   181                              <1>   ; xor di,di
   182                              <1>   ; print "int3:"
   183                              <1>   ; ; mov ax,cx
   184                              <1>   ; ; call write_number_word
   185                              <1> 
   186                              <1>   ; pop es
   187                              <1>   ; pop ds
   188                              <1>   ; pop bp
   189                              <1>   ; pop di
   190                              <1>   ; pop si
   191                              <1>   ; pop dx
   192                              <1>   ; pop cx
   193                              <1>   ; pop bx
   194                              <1>   ; pop ax
   195                              <1>   ; iret
   196                              <1> 
   197                              <1> int4:; int4: Signed overflow
   198 000000BD B004                <1>   mov al,4
   199 000000BF EB00                <1>   jmp int_msg
   200                              <1> int_msg:
   201 000000C1 BFF401              <1>   mov di,500
   202                              <1>   ; xor di,di
   203                              <1>   ; mov ax,di
   204                              <1>   ; mov cx,8*72  
   205                              <1>   ; rep stosw
   206                              <1>   ; xor di,di
   207                              <1>   ; push ax
   208                              <1>   ; print "int: "
   209                              <1>   ; pop ax
   210 000000C4 0430                <1>   add al,'0'
   211 000000C6 E8FF00              <1>   call write_char
   212                              <1>   ; print "      "
   213                              <1>   
   214 000000C9 F4                  <1>   hlt
   215                              <1> 
   216                              <1> boot:
   217 000000CA FA                  <1>   cli
   218 000000CB FC                  <1>   cld
   219 000000CC E8E600              <1>   call clear_green    
   220                              <1> 
   221                              <1>   ; init video      
   222 000000CF B005                <1>   mov al, 5
   223 000000D1 E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
   224                              <1>  
   225                              <1>   ; register interrupts
   226 000000D3 31FF                <1>   xor di,di ; offset 0
   227 000000D5 8EC7                <1>   mov es,di ; segment 0
   228                              <1>   register_interrupt int0
   124 000000D7 B8[2200]            <2>  mov ax,%1
   125 000000DA AB                  <2>  stosw
   126 000000DB 8CC8                <2>  mov ax,cs
   127 000000DD AB                  <2>  stosw
   229                              <1>   register_interrupt int1
   124 000000DE B8[B100]            <2>  mov ax,%1
   125 000000E1 AB                  <2>  stosw
   126 000000E2 8CC8                <2>  mov ax,cs
   127 000000E4 AB                  <2>  stosw
   230                              <1>   register_interrupt int2
   124 000000E5 B8[B500]            <2>  mov ax,%1
   125 000000E8 AB                  <2>  stosw
   126 000000E9 8CC8                <2>  mov ax,cs
   127 000000EB AB                  <2>  stosw
   231                              <1>   register_interrupt int3
   124 000000EC B8[B900]            <2>  mov ax,%1
   125 000000EF AB                  <2>  stosw
   126 000000F0 8CC8                <2>  mov ax,cs
   127 000000F2 AB                  <2>  stosw
   232                              <1>   register_interrupt int4
   124 000000F3 B8[BD00]            <2>  mov ax,%1
   125 000000F6 AB                  <2>  stosw
   126 000000F7 8CC8                <2>  mov ax,cs
   127 000000F9 AB                  <2>  stosw
   233                              <1> 
   234                              <1> 
   235                              <1>   ; init other hardware
   236 000000FA B000                <1>   mov al,0
   237 000000FC E63A                <1>   out 0x3a,al           ; keyboard \force state/
   238 000000FE E63A                <1>   out 0x3a,al           ; keyboard \force state/
   239 00000100 B0FF                <1>   mov al,0xFF
   240 00000102 E63A                <1>   out 0x3a,al           ; keyboard \reset/
   241 00000104 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   242 00000106 B037                <1>   mov al,0x37
   243 00000108 E63A                <1>   out 0x3a,al           ; keyboard \set command
   244                              <1> 
   245 0000010A B8001C              <1>   mov ax,GREEN      
   246 0000010D 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   247 0000010F B83800              <1>   mov ax,DST                
   248 00000112 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   249 00000114 BF0000              <1>   mov di,0                  ;
   250 00000117 B200                <1>   mov dl,0                  ; track=0
   251 00000119 B601                <1>   mov dh,1                  ; sector=1
   252 0000011B B95000              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   253 0000011E EB0B                <1>   jmp move_head
   254                              <1> 
   255                              <1> ; ───────────────────────────────────────────────────────────────────────────
   256                              <1> 
   257                              <1> next_sector:
   258 00000120 FEC6                <1>   inc dh                    ; sector++
   259 00000122 80FE0A              <1>   cmp dh,10
   260 00000125 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   261 00000127 B601                <1>   mov dh,1
   262 00000129 FEC2                <1>   inc dl                    ; else track++ ; sector=1
   263                              <1> 
   264                              <1> move_head:
   265 0000012B 88D0                <1>   mov al,dl
   266 0000012D E60E                <1>   out 0Eh,al               ; set track number
   267 0000012F B018                <1>   mov al,18h     
   268 00000131 E608                <1>   out 8,al                 ; seek track, load head
   269 00000133 B000                <1>   mov al,0
   270 00000135 E61C                <1>   out 1Ch,al               ; set desired drive/side
   271 00000137 D40A                <1>   aam
   272                              <1> 
   273                              <1> head_moving:
   274 00000139 E408                <1>   in al,8
   275 0000013B A801                <1>   test al,1
   276 0000013D 75FA                <1>   jnz head_moving
   277                              <1> 
   278                              <1> read_sector:
   279 0000013F 88F0                <1>   mov al,dh
   280 00000141 E60C                <1>   out 0Ch,al                ; sector number
   281 00000143 B702                <1>   mov bh,2                  ; 00000010b
   282 00000145 B396                <1>   mov bl,96h                ; 10010110b
   283 00000147 B400                <1>   mov ah,0
   284 00000149 B080                <1>   mov al,80h
   285 0000014B E608                <1>   out 8,al                  ; read sector
   286 0000014D D40A<rep 4h>        <1>   times 4 aam               ; wait
   287                              <1> 
   288                              <1> check_status_1:
   289 00000155 E408                <1>   in al,8                   ; read status
   290 00000157 D0F8                <1>   sar al,1                  ; status/=2
   291 00000159 731F                <1>   jnb check_status_3
   292 0000015B 75F8                <1>   jnz check_status_1
   293                              <1> 
   294                              <1> wait_for_data:
   295 0000015D E408                <1>   in al,8                   ; read status
   296 0000015F 20D8                <1>   and al,bl                 ; 96h
   297 00000161 74FA                <1>   jz wait_for_data
   298                              <1> 
   299                              <1> store_byte_1:
   300 00000163 E40E                <1>   in al,0Eh
   301 00000165 AA                  <1>   stosb
   302                              <1> 
   303                              <1> check_status_2:
   304 00000166 E408                <1>   in al,8                   ; read status
   305 00000168 48                  <1>   dec ax                    ; status--
   306 00000169 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   307 0000016B 38F8                <1>   cmp al, bh                ; bh=2
   308 0000016D 750B                <1>   jnz check_status_3        ; if (status==1) 
   309                              <1> 
   310                              <1> store_byte_2:
   311 0000016F E40E                <1>   in al,0Eh  
   312 00000171 AA                  <1>   stosb
   313                              <1> 
   314                              <1> check_status_4:
   315 00000172 E408                <1>   in al,8                   ; read status
   316 00000174 38F8                <1>   cmp al, bh                ; bh=2
   317 00000176 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   318 00000178 EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   319                              <1> 
   320                              <1> ; ───────────────────────────────────────────────────────────────────────────
   321                              <1> 
   322                              <1> check_status_3:
   323 0000017A E408                <1>   in al, 8                  ; read status
   324 0000017C A81C                <1>   test al, 1Ch              ; 00011100
   325 0000017E 7402                <1>   jz while_sectors
   326 00000180 EBBD                <1>   jmp read_sector
   327                              <1> 
   328                              <1> ; ───────────────────────────────────────────────────────────────────────────
   329                              <1> 
   330                              <1> while_sectors:
   331 00000182 E80F00              <1>   call progress_bar
   332 00000185 E299                <1>   loop next_sector
   333                              <1> 
   334                              <1> done_reading:
   335 00000187 0E                  <1>   push cs
   336 00000188 17                  <1>   pop ss
   337 00000189 BC0000              <1>   mov sp,0
   338 0000018C E82600              <1>   call clear_green
   339 0000018F 0E                  <1>   push cs
   340 00000190 1F                  <1>   pop ds
   341 00000191 E95704              <1>   jmp setup
   342                              <1> 
   343                              <1> ; ───────────────────────────────────────────────────────────────────────────
   344                              <1> 
   345                              <1> progress_bar:
   346                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   347 00000194 52                  <1>   push dx
   348 00000195 53                  <1>   push bx
   349 00000196 31D2                <1>   xor dx,dx
   350 00000198 B81E00              <1>   mov ax,BAR_WIDTH
   351 0000019B BB5000              <1>   mov bx,NUM_SECTORS    
   352 0000019E F7E1                <1>   mul cx
   353 000001A0 F7F3                <1>   div bx
   354 000001A2 5B                  <1>   pop bx
   355 000001A3 5A                  <1>   pop dx
   356 000001A4 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   357 000001A6 D1E6                <1>   shl si,1                  ; *=2
   358 000001A8 D1E6                <1>   shl si,1                  ; *=2  
   359 000001AA BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   360 000001AD 29F5                <1>   sub bp,si
   361 000001AF 3EC64600FF          <1>   mov byte [ds:bp],-1
   362 000001B4 C3                  <1>   ret
   363                              <1> 
   364                              <1> ; clear_red:
   365                              <1> ;   mov ax,RED
   366                              <1> ;   call clear_channel
   367                              <1> ;   ret
   368                              <1> 
   369                              <1> clear_green:
   370 000001B5 B8001C              <1>   mov ax,GREEN
   371 000001B8 E80100              <1>   call clear_channel
   372 000001BB C3                  <1>   ret
   373                              <1> 
   374                              <1> ; clear_blue:
   375                              <1> ;   mov ax,BLUE
   376                              <1> ;   call clear_channel
   377                              <1> ;   ret
   378                              <1> 
   379                              <1> ; clear_screen:
   380                              <1> ;   call clear_red
   381                              <1> ;   call clear_green
   382                              <1> ;   call clear_blue
   383                              <1> ;   ret
   384                              <1> 
   385                              <1> clear_channel:
   386 000001BC 8EC0                <1>   mov es,ax
   387 000001BE B9201C              <1>   mov cx,COLS*ROWS*2
   388 000001C1 31FF                <1>   xor di,di
   389 000001C3 31C0                <1>   xor ax,ax
   390 000001C5 F3AB                <1>   rep stosw         ; clear screen
   391 000001C7 C3                  <1>   ret
   392                              <1> 
   393                              <1> ; ───────────────────────────────────────────────────────────────────────────
   394                              <1> 
   395                              <1> ; write_char:   ; ds=FONT, es=GREEN, al=charcode
   396                              <1> ;   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   397                              <1> ;   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   398                              <1> ;   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   399                              <1> 
   400                              <1> ;   push ds
   401                              <1> ;   push es
   402                              <1> ;   push ax
   403                              <1> ;   push bx
   404                              <1> ;   push cx
   405                              <1> 
   406                              <1> ;   push ax
   407                              <1> ;   mov ax,GREEN
   408                              <1> ;   mov es,ax
   409                              <1> ;   mov ax,FONT
   410                              <1> ;   mov ds,ax
   411                              <1> ;   pop ax
   412                              <1> 
   413                              <1> ;   ; mov ax,65*8
   414                              <1> ;   ; mov al,'x'
   415                              <1> ;   mov ah,8
   416                              <1> ;   mul ah        ; ax=al*ah
   417                              <1> 
   418                              <1> ;   mov si,ax
   419                              <1> ;   movsw
   420                              <1> ;   movsw
   421                              <1> ;   add di,0x11c
   422                              <1> ;   movsw
   423                              <1> ;   movsw
   424                              <1> ;   mov bx,288
   425                              <1> ;   sub di,bx
   426                              <1>   
   427                              <1> ;   ; pop ax
   428                              <1> ;   ; pop es
   429                              <1> ;   ; pop ds
   430                              <1> ;   ; ret
   431                              <1> 
   432                              <1> 
   433                              <1> ;   ; row snap
   434                              <1> ;   xor dx,dx
   435                              <1> ;   mov ax,di
   436                              <1> ;   div bx
   437                              <1> ;   cmp dx,0
   438                              <1> ;   jne .return
   439                              <1> ;   add di,bx
   440                              <1> 
   441                              <1> 
   442                              <1> ;   ; wrap to top
   443                              <1> ;   cmp di,14400   ; dit later oplossen met cursor positie
   444                              <1> ;   jb .return
   445                              <1> ;   ; xor di,di      ; move to left top. change later to scroll
   446                              <1> 
   447                              <1> ;   ; TODO: call scroll_down
   448                              <1> ;   ; std
   449                              <1> ;   ; push di
   450                              <1> ;   ; push cx
   451                              <1> ;   ; mov cx,4*72*24
   452                              <1> ;   ; mov ax,0
   453                              <1> ;   ; rep stosw
   454                              <1> ;   ; pop cx
   455                              <1> ;   ; pop di
   456                              <1> ;   ; cld
   457                              <1> 
   458                              <1> ;   ; DONE: clear last line
   459                              <1> ;   sub di,bx
   460                              <1> ;   sub di,bx
   461                              <1> ;   push di
   462                              <1> ;   push cx
   463                              <1> ;   mov cx,COLS*ROWS*2
   464                              <1> ;   xor ax,ax
   465                              <1> ;   rep stosw         ; clear screen
   466                              <1> ;   pop cx
   467                              <1> ;   pop di
   468                              <1> 
   469                              <1> ; .return
   470                              <1> ;   push bx
   471                              <1> ;   push cx
   472                              <1> ;   pop ax
   473                              <1> ;   pop es
   474                              <1> ;   pop ds
   475                              <1> ;   ret
   476                              <1> 
   477                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   478                              <1> 
   479                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   480 000001C8 52                  <1>   push dx
   481 000001C9 1E                  <1>   push ds
   482 000001CA 06                  <1>   push es
   483 000001CB 50                  <1>   push ax
   484 000001CC 53                  <1>   push bx
   485 000001CD 31D2                <1>   xor dx,dx
   486 000001CF 50                  <1>   push ax  ; voor character pop
   487 000001D0 B8001C              <1>   mov ax,GREEN
   488 000001D3 8EC0                <1>   mov es,ax
   489 000001D5 B800FF              <1>   mov ax,FONT
   490 000001D8 8ED8                <1>   mov ds,ax
   491 000001DA 58                  <1>   pop ax
   492 000001DB B408                <1>   mov ah,8
   493 000001DD F6E4                <1>   mul ah        ; al*=ah
   494 000001DF 89C6                <1>   mov si,ax  
   495                              <1> 
   496 000001E1 A5                  <1>   movsw
   497 000001E2 A5                  <1>   movsw
   498 000001E3 81C71C01            <1>   add di,0x11c
   499 000001E7 A5                  <1>   movsw
   500 000001E8 A5                  <1>   movsw
   501 000001E9 81EF2001            <1>   sub di,0x120
   502                              <1> 
   503                              <1> 
   504                              <1>   ; cmp di,14400   ; dit later oplossen met cursor positie
   505                              <1>   ; jb .return
   506                              <1>   ; xor di,di      ; move to left top. change later to scroll
   507                              <1> 
   508                              <1>   ; row snap
   509 000001ED BB2001              <1>   mov bx,288   ; /////////// dit gaf problemen waarsch omdat bx niet gepushed werd
   510 000001F0 31D2                <1>   xor dx,dx
   511 000001F2 89F8                <1>   mov ax,di
   512 000001F4 F7F3                <1>   div bx       ; ///dit ook als BX 0 is
   513 000001F6 83FA00              <1>   cmp dx,0
   514 000001F9 7502                <1>   jne .return
   515 000001FB 01DF                <1>   add di,bx
   516                              <1> 
   517                              <1> .return
   518 000001FD 5B                  <1>   pop bx
   519 000001FE 58                  <1>   pop ax
   520 000001FF 07                  <1>   pop es
   521 00000200 1F                  <1>   pop ds
   522 00000201 5A                  <1>   pop dx
   523 00000202 C3                  <1>   ret
   524                              <1> 
   525                              <1> write_string:
   526 00000203 2E8A07              <1>   mov al,[cs:bx]
   527 00000206 43                  <1>   inc bx
   528 00000207 08C0                <1>   or al,al
   529 00000209 7405                <1>   jz .return
   530 0000020B E8BAFF              <1>   call write_char
   531 0000020E EBF3                <1>   jmp short write_string
   532                              <1> .return
   533 00000210 C3                  <1>   ret
   534                              <1> 
   535                              <1> ; ───────────────────────────────────────────────────────────────────────────
   536                              <1> 
   537                              <1> write_binary_byte:    ; input AL
   538 00000211 50                  <1>   push ax
   539 00000212 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   540 00000214 B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   541                              <1> .lp:
   542 00000217 D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   543 00000219 B80000              <1>   mov ax, 0           ; AH leegmaken
   544 0000021C 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   545 0000021E 51                  <1>   push cx             ; CX opslaan
   546 0000021F E8A6FF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   547 00000222 59                  <1>   pop cx              ; CX herstellen
   548 00000223 E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   549 00000225 58                  <1>   pop ax
   550 00000226 C3                  <1>   ret
   551                              <1> 
   552                              <1> ; ───────────────────────────────────────────────────────────────────────────
   553                              <1> 
   554                              <1> write_binary_word:    ; input AX
   555 00000227 50                  <1>   push ax
   556 00000228 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   557 00000229 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   558 0000022B B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   559                              <1> .lp:
   560 0000022E D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   561 00000230 B80000              <1>   mov ax, 0          ; AH leegmaken
   562 00000233 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   563 00000235 51                  <1>   push cx            ; CX opslaan
   564 00000236 E88FFF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   565 00000239 59                  <1>   pop cx             ; CX herstellen
   566 0000023A E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   567 0000023C 5A                  <1>   pop dx             ; DX herstellen
   568 0000023D 58                  <1>   pop ax
   569 0000023E C3                  <1>   ret
   570                              <1> 
   571                              <1> 
   572                              <1> ; ───────────────────────────────────────────────────────────────────────────
   573                              <1> 
   574                              <1> write_number_word:
   575 0000023F 50                  <1>     push ax
   576 00000240 52                  <1>     push dx
   577 00000241 31D2                <1>     xor dx,dx
   578 00000243 52                  <1>     push dx ;high byte is zero
   579 00000244 31D2                <1> .clp xor dx,dx
   580 00000246 2EF736[6202]        <1>     cs div word [.base]
   581 0000024B 92                  <1>     xchg ax,dx
   582 0000024C 05300E              <1>     add ax,0xe30
   583 0000024F 50                  <1>     push ax
   584 00000250 92                  <1>     xchg ax,dx
   585 00000251 09C0                <1>     or ax,ax
   586 00000253 75EF                <1>     jnz .clp
   587 00000255 58                  <1> .dlp pop ax
   588 00000256 08E4                <1>     or ah,ah
   589 00000258 7405                <1>     jz .done
   590 0000025A E86BFF              <1>     call write_char
   591 0000025D EBF6                <1>     jmp short .dlp
   592 0000025F 5A                  <1> .done pop dx
   593 00000260 58                  <1>     pop ax
   594 00000261 C3                  <1>     ret
   595 00000262 0A00                <1> .base dw 10
   596                              <1> 
   597                              <1> ; ───────────────────────────────────────────────────────────────────────────
   598                              <1> 
   599                              <1> 
   600                              <1> ; ───────────────────────────────────────────────────────────────────────────
   601                              <1> 
   602                              <1> write_signed_number_word:  
   603 00000264 50                  <1>     push ax
   604 00000265 09C0                <1>     or ax,ax
   605 00000267 790A                <1>     jns .write_return        ; if >0 write and return
   606 00000269 50                  <1>     push ax
   607 0000026A B82D00              <1>     mov ax,'-'
   608 0000026D E858FF              <1>     call write_char
   609 00000270 58                  <1>     pop ax
   610 00000271 F7D8                <1>     neg ax                   ; destroys ax when negative
   611                              <1> .write_return:
   612 00000273 E8C9FF              <1>     call write_number_word
   613 00000276 58                  <1>     pop ax
   614 00000277 C3                  <1>     ret
   615                              <1> 
   616                              <1> ; ───────────────────────────────────────────────────────────────────────────
   617                              <1> 
   618                              <1> check_keys:
   619 00000278 E43A                <1>   in al,0x3a        ; get keyboard status
   620 0000027A 88C4                <1>   mov ah,al
   621 0000027C 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   622 0000027E 2EA2[0600]          <1>   mov [cs:key.ctrl],al
   623 00000282 F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   624 00000285 7410                <1>   jz .return
   625 00000287 E438                <1>   in al,0x38        ; get data byte from keyboard  
   626 00000289 2EA2[0500]          <1>   mov [cs:key.code],al
   627 0000028D B037                <1>   mov al,0x37
   628 0000028F E63A                <1>   out 0x3a,al       ; drop key?  
   629 00000291 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   630 00000293 2EA1[0500]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   631 00000297 C3                  <1> .return ret
   632                              <1> 
   633                              <1> 
   634                              <1> 
   635                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   636                              <1> ;   ret
   637                              <1> 
   638                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   639                              <1> 
   640                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   641                              <1> ; much faster and simpler on the grid than off the grid
   642                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   643                              <1> 
   644                              <1> 
   645                              <1> ; wide font by stretching the font horizontally using bitshift
   646                              <1> 
   647                              <1> 
   648                              <1> ; fill_white:
   649                              <1> ;   mov ax,0xffff
   650                              <1> ;   call fill_red
   651                              <1> ;   call fill_green
   652                              <1> ;   call fill_blue
   653                              <1> ;   ret
   654                              <1> 
   655                              <1> ; fill_pink:
   656                              <1> ;   mov ax,0xffff
   657                              <1> ;   call fill_red
   658                              <1> ;   mov ah,0b01010101
   659                              <1> ;   mov al,0b10101010
   660                              <1> ;   call fill_green
   661                              <1> ;   call fill_blue
   662                              <1> ;   ret
   663                              <1> 
   664                              <1> ; fill_pink2:
   665                              <1> ;   mov ax,0xffff
   666                              <1> ;   call fill_red
   667                              <1> ;   mov ah,0b11001100
   668                              <1> ;   mov al,0b00110011
   669                              <1> ;   call fill_green
   670                              <1> ;   call fill_blue
   671                              <1> ;   ret
   672                              <1> 
   673                              <1> ; fill_pink3:
   674                              <1> ;   mov ax,0xffff
   675                              <1> ;   call fill_red
   676                              <1> ;   mov ah,0b00010001
   677                              <1> ;   mov al,0b01000100
   678                              <1> ;   call fill_green
   679                              <1> ;   call fill_blue
   680                              <1> ;   ret
   681                              <1> 
   682                              <1> ; fill_pink4:
   683                              <1> ;   mov ax,0xffff
   684                              <1> ;   call fill_red
   685                              <1> ;   mov ah,0b11110111
   686                              <1> ;   mov al,0b01111111
   687                              <1> ;   call fill_green
   688                              <1> ;   call fill_blue
   689                              <1> ;   ret
   690                              <1> 
   691                              <1> ; fill_red:
   692                              <1> ;   mov bx,RED
   693                              <1> ;   call fill_channel
   694                              <1> ;   ret
   695                              <1> ; fill_green:
   696                              <1> ;   mov bx,GREEN
   697                              <1> ;   call fill_channel
   698                              <1> ;   ret
   699                              <1> ; fill_blue:
   700                              <1> ;   mov bx,BLUE
   701                              <1> ;   call fill_channel
   702                              <1> ;   ret
   703                              <1> 
   704                              <1> ; fill_channel: ;ax=pattern
   705                              <1> ;   mov es,bx
   706                              <1> ;   mov cx,COLS*ROWS*2
   707                              <1> ;   xor di,di
   708                              <1> ;   rep stosw
   709                              <1> ;   ret
   710                              <1> 
   711                              <1> ; ───────────────────────────────────────────────────────────────────────────
   712                              <1> 
   713                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   714                              <1> ;   push bx
   715                              <1> ;   push di
   716                              <1> ;   mov es,ax
   717                              <1> ;   xor cx,cx
   718                              <1> ;   mov cl,bh        ; rows (bl)
   719                              <1> ; .rows_loop:
   720                              <1> ;   push cx
   721                              <1> ;   xor cx,cx
   722                              <1> ;   mov cl,bl        ; cols (bh)
   723                              <1> ; .cols_loop:
   724                              <1> ;   mov ax,0
   725                              <1> ;   stosw
   726                              <1> ;   stosw
   727                              <1> ;   loop .cols_loop
   728                              <1> ;   add di,COLS*4    ; one row down
   729                              <1> ;   mov ah,0
   730                              <1> ;   mov al,bl
   731                              <1> ;   times 2 shl ax,1
   732                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   733                              <1> ;   pop cx
   734                              <1> ;   loop .rows_loop
   735                              <1> ;   pop di
   736                              <1> ;   pop bx
   737                              <1> ;   ret
   738                              <1> 
   739                              <1> ; ───────────────────────────────────────────────────────────────────────────
   740                              <1> 
   741                              <1> ; fill_rect_black: 
   742                              <1> ;   mov ax,RED
   743                              <1> ;   call clear_area
   744                              <1> ;   mov ax,GREEN
   745                              <1> ;   call clear_area
   746                              <1> ;   mov ax,BLUE
   747                              <1> ;   call clear_area
   748                              <1> ;   ret
   749                              <1> 
   750                              <1> ; ───────────────────────────────────────────────────────────────────────────
   751                              <1> 
   752                              <1> draw_spr:
   753 00000298 8B1C                <1>   mov bx,[si]
   754 0000029A 46<rep 2h>          <1>   times 2 inc si
   755                              <1> draw_pic:
   756 0000029C B800F0              <1>   mov ax, RED
   757 0000029F E80D00              <1>   call draw_channel
   758 000002A2 B8001C              <1>   mov ax, GREEN
   759 000002A5 E80700              <1>   call draw_channel
   760 000002A8 B800F4              <1>   mov ax, BLUE
   761 000002AB E80100              <1>   call draw_channel
   762 000002AE C3                  <1>   ret
   763                              <1> 
   764                              <1> ; ───────────────────────────────────────────────────────────────────────────
   765                              <1> 
   766                              <1> draw_channel:
   767 000002AF 57                  <1>   push di
   768 000002B0 8EC0                <1>   mov es,ax
   769 000002B2 31C9                <1>   xor cx,cx
   770 000002B4 88F9                <1>   mov cl,bh        ; rows (bl)
   771                              <1> .rows_loop:
   772 000002B6 51                  <1>   push cx
   773 000002B7 31C9                <1>   xor cx,cx
   774 000002B9 88D9                <1>   mov cl,bl        ; cols (bh)
   775                              <1> .cols_loop:
   776 000002BB A5                  <1>   movsw
   777 000002BC A5                  <1>   movsw
   778 000002BD E2FC                <1>   loop .cols_loop
   779 000002BF 81C72001            <1>   add di,COLS*4    ; one row down
   780 000002C3 B400                <1>   mov ah,0
   781 000002C5 88D8                <1>   mov al,bl
   782 000002C7 D1E0<rep 2h>        <1>   times 2 shl ax,1
   783 000002CB 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   784 000002CD 59                  <1>   pop cx
   785 000002CE E2E6                <1>   loop .rows_loop
   786 000002D0 5F                  <1>   pop di
   787 000002D1 C3                  <1>   ret
   788                              <1> 
   789                              <1> ; ───────────────────────────────────────────────────────────────────────────
   790                              <1> 
   791                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   792 000002D2 B89000              <1>   mov ax,144      ; 2*72 cols
   793 000002D5 F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   794 000002D7 D1E0                <1>   shl ax,1        ; verdubbel AX
   795 000002D9 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   796 000002DB D0E3                <1>   shl bl,1        ; bl*=2
   797 000002DD D0E3                <1>   shl bl,1        ; bl*=2
   798 000002DF B700                <1>   mov bh,0
   799 000002E1 01DF                <1>   add di,bx       ; di+=bl
   800 000002E3 C3                  <1>   ret
   801                              <1> 
   802                              <1> ; ───────────────────────────────────────────────────────────────────────────
   803                              <1> 
   804                              <1> new_line:         ; find the value of DI at start of the next line
   805 000002E4 50                  <1>   push ax
   806 000002E5 53                  <1>   push bx
   807 000002E6 52                  <1>   push dx
   808 000002E7 BB2001              <1>   mov bx,288
   809 000002EA 31D2                <1>   xor dx,dx
   810 000002EC 89F8                <1>   mov ax,di
   811 000002EE F7F3                <1>   div bx
   812 000002F0 31D2                <1>   xor dx,dx       ; cwd?
   813 000002F2 BB2001              <1>   mov bx,288      ; bx was still 288?
   814 000002F5 40                  <1>   inc ax
   815 000002F6 F7E3                <1>   mul bx
   816 000002F8 052001              <1>   add ax,288      ; use bx?
   817 000002FB 89C7                <1>   mov di,ax
   818 000002FD 5A                  <1>   pop dx
   819 000002FE 5B                  <1>   pop bx
   820 000002FF 58                  <1>   pop ax
   821 00000300 C3                  <1>   ret
   822                              <1> 
   823                              <1> ; ───────────────────────────────────────────────────────────────────────────
   824                              <1> 
   825                              <1> write_ax_hex:
   826 00000301 50                  <1>   push ax
   827 00000302 52                  <1>   push dx
   828 00000303 31D2                <1>   xor dx,dx
   829 00000305 52                  <1>   push dx ;high byte is zero
   830 00000306 31D2                <1> .clp xor dx,dx
   831 00000308 2EF736[2A03]        <1>   cs div word [.base]
   832 0000030D 92                  <1>   xchg ax,dx
   833 0000030E 3C0A                <1>   cmp al,10
   834 00000310 7202                <1>   jb .l1     ; 0-9
   835 00000312 0407                <1>   add al,7   ; A-F
   836 00000314 05300E              <1> .l1 add ax,0xe30
   837 00000317 50                  <1>   push ax
   838 00000318 92                  <1>   xchg ax,dx
   839 00000319 09C0                <1>   or ax,ax
   840 0000031B 75E9                <1>   jnz .clp
   841 0000031D 58                  <1> .dlp pop ax
   842 0000031E 08E4                <1>   or ah,ah
   843 00000320 7405                <1>   jz .done
   844 00000322 E8A3FE              <1>   call write_char
   845 00000325 EBF6                <1>   jmp short .dlp
   846 00000327 5A                  <1> .done pop dx
   847 00000328 58                  <1>   pop ax
   848 00000329 C3                  <1>   ret
   849 0000032A 1000                <1> .base dw 16
   850                              <1> 
   851                              <1> ; calc_di_from_cursor:  ; input cursor, output di
   852                              <1> ;   mov ax,[cursor] 
   853                              <1> ;   sub ax,0x0101   ; cursor is 1 based
   854                              <1> ;   xchg ax,bx      ; bx=ax
   855                              <1> ;   mov ax,144      ; 2*72 cols
   856                              <1> ;   mul bh          ; bh*=144 resultaat in AX
   857                              <1> ;   shl ax,1        ; verdubbel AX
   858                              <1> ;   shl ax,1        ; verdubbel AX
   859                              <1> ;   mov di,ax       ; di=ax (=bh*288)
   860                              <1> ;   shl bl,1        ; bl*=2
   861                              <1> ;   shl bl,1        ; bl*=2
   862                              <1> ;   mov bh,0
   863                              <1> ;   add di,bx       ; di+=bl
   864                              <1> ;   ret
   865                              <1> 
   866                              <1> 
   867                              <1> 
   868                              <1> 
   869                              <1> ; als je cursor gebruikt is dit missch niet nodig.
   870                              <1> ; row_snap:  ; this code detects if DI is in between rows. When DI goes to the next half row it converts it to a whole row.
   871                              <1> ;   push ax
   872                              <1> ;   push bx
   873                              <1> ;   push dx
   874                              <1> ;   mov bx,288
   875                              <1> ;   mov ax,di
   876                              <1> ;   cwd ; xor dx,dx
   877                              <1> ;   div bx
   878                              <1> ;   jnp .done  ; if ax%288==0 
   879                              <1> ;   add di,bx
   880                              <1> ;   .done
   881                              <1> ;   ; add di,dx
   882                              <1> ;   pop dx
   883                              <1> ;   pop bx
   884                              <1> ;   pop ax
   885                              <1> ;   ret
   886                              <1> 
   887                              <1> 
   888                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   889                              <1> 
   890                              <1> ; calc_di_from_cursor_index:  ; index is cursor index from 0 tot 72*25
   891                              <1> ;   push ax
   892                              <1> ;   push bx
   893                              <1> ;   push dx
   894                              <1> ;   xor dx,dx
   895                              <1> ;   mov ax,[cursor.index]
   896                              <1> ;   mov bx,72
   897                              <1> ;   div bx       ; ax=rows
   898                              <1> ;   push dx      ; dx=cols
   899                              <1> ;   xor dx,dx    ; clear dx for multiplication
   900                              <1> ;   mov bx,576
   901                              <1> ;   mul bx       ; ax contains DI position for row
   902                              <1> ;   mov di,ax
   903                              <1> ;   pop ax       ; ax now contains cols
   904                              <1> ;   shl ax,1     ; *=2
   905                              <1> ;   shl ax,1     ; *=2
   906                              <1> ;   add di,ax
   907                              <1> ;   pop dx
   908                              <1> ;   pop bx
   909                              <1> ;   pop ax
   910                              <1> ;   ret
   911                              <1> 
   912                              <1> ; ───────────────────────────────────────────────────────────────────────────
   913                              <1> 
   914                              <1> 
   915                              <1> ; set_cursor:
   916                              <1> ; cursor_next_char
   917                              <1> 
   918                              <1> 
   919                              <1> 
   920                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   921                              <1> 
     2                                  %include "vector.asm"
     1                              <1> %include "math.asm"
     1                              <2> 
     2                              <2> sin: ; ax in degrees
     3 0000032C 51                  <2>   push cx
     4 0000032D B96400              <2>   mov cx,100
     5 00000330 98                  <2>   cbw
     6 00000331 F7E9                <2>   imul cx
     7 00000333 83C02D              <2>   add ax,45
     8 00000336 B90900              <2>   mov cx,9
     9 00000339 98                  <2>   cbw
    10 0000033A F7F9                <2>   idiv cx
    11 0000033C 59                  <2>   pop cx
    12                              <2> 
    13                              <2> cos: ; ax in degrees
    14 0000033D 51                  <2>   push cx;
    15 0000033E 89C1                <2>   mov cx,ax
    16 00000340 B85A00              <2>   mov ax,90
    17 00000343 29C8                <2>   sub ax,cx
    18 00000345 B96400              <2>   mov cx,100
    19 00000348 98                  <2>   cbw
    20 00000349 F7E9                <2>   imul cx
    21 0000034B 83C02D              <2>   add ax,45
    22 0000034E B90900              <2>   mov cx,9
    23 00000351 98                  <2>   cbw
    24 00000352 F7F9                <2>   idiv cx
    25 00000354 59                  <2>   pop cx
    26                              <2> 
    27                              <2> atan2: ; input bx=y, ax=x
    28 00000355 83F800              <2>   cmp ax,0
    29 00000358 750F                <2>   jnz .x_not_0
    30 0000035A 83FB00              <2>   cmp bx,0
    31 0000035D 7C05                <2>   jl .y_lte_0
    32 0000035F B85A00              <2>   mov ax,90
    33 00000362 EB2E                <2>   jmp .ret
    34                              <2> 
    35                              <2> .y_lte_0:
    36 00000364 B8A6FF              <2>   mov ax,-90
    37 00000367 EB29                <2>   jmp .ret
    38                              <2> 
    39                              <2> .x_not_0:
    40 00000369 50                  <2>   push ax
    41 0000036A 50                  <2>   push ax   ; keep a copy of x
    42 0000036B 89D8                <2>   mov ax,bx
    43 0000036D B96F00              <2>   mov cx,111
    44 00000370 99                  <2>   cwd       ; dx=0
    45 00000371 F7E9                <2>   imul cx
    46 00000373 59                  <2>   pop cx;   ; restore x
    47                              <2> 
    48                              <2> 
    49                              <2> 
    50                              <2>   ; mov word [debug.ax], ax
    51                              <2>   ; mov word [debug.bx], bx
    52                              <2>   ; mov word [debug.cx], cx
    53                              <2>   ; mov word [debug.dx], dx
    54                              <2> 
    55                              <2> ;   set_cursor 10,1
    56                              <2> ;   print "AX="
    57                              <2> ;   call write_number_word
    58                              <2> ;   print "   "
    59                              <2> 
    60                              <2> ; ; 13441
    61                              <2> 
    62                              <2> ;   call new_line  
    63                              <2> ;   print "CX="
    64                              <2> ;   mov ax,cx
    65                              <2> ;   call write_number_word
    66                              <2> ;   print "   "
    67                              <2> 
    68                              <2>   ; cmp cx,0
    69                              <2>   ; je .error_x_0
    70 00000374 99                  <2>   cwd
    71                              <2> 
    72 00000375 F7F9                <2>   idiv cx   ; ax/=x
    73 00000377 99                  <2>   cwd
    74 00000378 E85200              <2>   call atan
    75 0000037B 59                  <2>   pop cx;   ; restore x
    76 0000037C 83F900              <2>   cmp cx,0
    77 0000037F 7C02                <2>   jl .x_lt_0
    78 00000381 EB0F                <2>   jmp .ret
    79                              <2> 
    80                              <2> .x_lt_0:
    81 00000383 83FB00              <2>   cmp bx,0
    82 00000386 7D05                <2>   jge .y_gte_0
    83 00000388 2DB400              <2>   sub ax,180
    84 0000038B EB05                <2>   jmp .ret
    85                              <2> 
    86                              <2> .y_gte_0:
    87 0000038D 05B400              <2>   add ax,180
    88 00000390 EB00                <2>   jmp .ret
    89                              <2> 
    90                              <2> .ret:
    91 00000392 83F800              <2>   cmp ax,0
    92 00000395 7C01                <2>   jl .add360
    93 00000397 C3                  <2>   ret
    94                              <2> .add360:
    95 00000398 056801              <2>   add ax,360
    96 0000039B C3                  <2>   ret
    97                              <2> .error_x_0
    98                              <2>   set_cursor 1,1
    43                              <3> 
    44 0000039C BF0000              <3>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
    99                              <2>   print "Division Error in atan2: x=0"
    48 0000039F 50                  <3>  push ax
    49 000003A0 53                  <3>  push bx
    50 000003A1 51                  <3>  push cx
    51 000003A2 52                  <3>  push dx
    52 000003A3 EB1D                <3>  jmp %%endstr
    53 000003A5 4469766973696F6E20- <3>  %%str: db %1,0
    53 000003AE 4572726F7220696E20- <3>
    53 000003B7 6174616E323A20783D- <3>
    53 000003C0 3000                <3>
    54                              <3>  %%endstr:
    55 000003C2 BB[A503]            <3>  mov bx,%%str
    56 000003C5 E83BFE              <3>  call write_string
    57 000003C8 5A                  <3>  pop dx
    58 000003C9 59                  <3>  pop cx
    59 000003CA 5B                  <3>  pop bx
    60 000003CB 58                  <3>  pop ax
   100 000003CC F4                  <2>   hlt
   101                              <2> 
   102                              <2> ; ───────────────────────────────────────────────────────────────────────────
   103                              <2> 
   104                              <2> atan: ; cx=z, return value in ax, bx destroyed, cx destroyed, dx destroyed
   105 000003CD 89C1                <2>   mov cx,ax           ; z
   106 000003CF 99                  <2>   cwd
   107 000003D0 83F96F              <2>   cmp cx,111
   108 000003D3 7F29                <2>   jg .z_gt_scale      ; if (z>111)
   109 000003D5 83F991              <2>   cmp cx,-111         ; if (z<-111) 
   110 000003D8 7C34                <2>   jl .z_lt_minus_scale
   111 000003DA 99                  <2>   cwd
   112 000003DB F7E8                <2>   imul ax             ; ax *= ax  (z*z)
   113 000003DD BB4D01              <2>   mov bx,333     
   114 000003E0 F7FB                <2>   idiv bx             ; ax /= 333   Taylor-benadering
   115 000003E2 99                  <2>   cwd
   116 000003E3 89C3                <2>   mov bx,ax
   117 000003E5 B86F00              <2>   mov ax,111
   118 000003E8 29D8                <2>   sub ax,bx           ; ax-=111  
   119 000003EA BBB400              <2>   mov bx,180
   120 000003ED F7EB                <2>   imul bx             ; ax*=180 
   121 000003EF F7E9                <2>   imul cx             ; ax*=z
   122 000003F1 BB6F00              <2>   mov bx,111
   123 000003F4 F7FB                <2>   idiv bx             ; ax/=111
   124 000003F6 BB3A01              <2>   mov bx,314
   125 000003F9 99                  <2>   cwd
   126 000003FA F7FB                <2>   idiv bx             ; ax/=314
   127 000003FC 99                  <2>   cwd
   128 000003FD C3                  <2>   ret
   129                              <2> 
   130                              <2> .z_gt_scale:
   131 000003FE B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
   132 00000401 F7F9                <2>   idiv cx             ; ax/=z
   133 00000403 E8C7FF              <2>   call atan           ; recursion
   134 00000406 89C3                <2>   mov bx,ax
   135 00000408 B85A00              <2>   mov ax,90
   136 0000040B 29D8                <2>   sub ax,bx
   137 0000040D C3                  <2>   ret
   138                              <2> 
   139                              <2> .z_lt_minus_scale:
   140 0000040E B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
   141 00000411 F7F9                <2>   idiv cx             ; ax/=z
   142 00000413 E8B7FF              <2>   call atan           ; recursion
   143 00000416 89C3                <2>   mov bx,ax
   144 00000418 B8A6FF              <2>   mov ax,-90
   145 0000041B 29D8                <2>   sub ax,bx
   146 0000041D C3                  <2>   ret
   147                              <2> 
   148                              <2> %macro _atan2 2
   149                              <2>   mov ax,%1
   150                              <2>   mov bx,%2
   151                              <2>   call __atan2
   152                              <2> %endmacro
   153                              <2> 
   154                              <2> __atan2:
   155 0000041E 50                  <2>   push ax
   156 0000041F 53                  <2>   push bx
   157                              <2>   print "atan2(x="
    48 00000420 50                  <3>  push ax
    49 00000421 53                  <3>  push bx
    50 00000422 51                  <3>  push cx
    51 00000423 52                  <3>  push dx
    52 00000424 EB09                <3>  jmp %%endstr
    53 00000426 6174616E3228783D00  <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 0000042F BB[2604]            <3>  mov bx,%%str
    56 00000432 E8CEFD              <3>  call write_string
    57 00000435 5A                  <3>  pop dx
    58 00000436 59                  <3>  pop cx
    59 00000437 5B                  <3>  pop bx
    60 00000438 58                  <3>  pop ax
   158 00000439 E828FE              <2>   call write_signed_number_word
   159                              <2>   print ",y="
    48 0000043C 50                  <3>  push ax
    49 0000043D 53                  <3>  push bx
    50 0000043E 51                  <3>  push cx
    51 0000043F 52                  <3>  push dx
    52 00000440 EB04                <3>  jmp %%endstr
    53 00000442 2C793D00            <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 00000446 BB[4204]            <3>  mov bx,%%str
    56 00000449 E8B7FD              <3>  call write_string
    57 0000044C 5A                  <3>  pop dx
    58 0000044D 59                  <3>  pop cx
    59 0000044E 5B                  <3>  pop bx
    60 0000044F 58                  <3>  pop ax
   160 00000450 58                  <2>   pop ax
   161 00000451 53                  <2>   push bx
   162 00000452 E80FFE              <2>   call write_signed_number_word
   163                              <2>   print ")="
    48 00000455 50                  <3>  push ax
    49 00000456 53                  <3>  push bx
    50 00000457 51                  <3>  push cx
    51 00000458 52                  <3>  push dx
    52 00000459 EB03                <3>  jmp %%endstr
    53 0000045B 293D00              <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 0000045E BB[5B04]            <3>  mov bx,%%str
    56 00000461 E89FFD              <3>  call write_string
    57 00000464 5A                  <3>  pop dx
    58 00000465 59                  <3>  pop cx
    59 00000466 5B                  <3>  pop bx
    60 00000467 58                  <3>  pop ax
   164 00000468 5B                  <2>   pop bx
   165 00000469 58                  <2>   pop ax
   166 0000046A E8E8FE              <2>   call atan2
   167 0000046D E8F4FD              <2>   call write_signed_number_word
   168 00000470 B020                <2>   mov al,' '
   169 00000472 E853FD              <2>   call write_char
   170 00000475 E86CFE              <2>   call new_line
   171 00000478 C3                  <2>   ret
   172                              <2> 
   173                              <2> 
     2                              <1> 
     3                              <1> v_mult:  ; bx contains address of 4 bytes vector  such as 'ship.vel', cx contains scaler such as 94 (*=.94)
     4 00000479 8B07                <1>   mov ax,[bx]   ; x
     5 0000047B 99                  <1>   cwd
     6 0000047C F7E9                <1>   imul cx
     7 0000047E 8907                <1>   mov [bx],ax
     8                              <1> 
     9 00000480 8B4702              <1>   mov ax,[bx+2] ; y
    10 00000483 99                  <1>   cwd
    11 00000484 F7E9                <1>   imul cx
    12 00000486 894702              <1>   mov [bx+2],ax
    13 00000489 C3                  <1>   ret
    14                              <1> 
    15                              <1> v_div:  ;bx=address, cx=scaler
    16 0000048A 8B07                <1>   mov ax,[bx]   ; x
    17 0000048C 99                  <1>   cwd
    18 0000048D F7F9                <1>   idiv cx
    19 0000048F 8907                <1>   mov [bx],ax
    20                              <1>   
    21 00000491 8B4702              <1>   mov ax,[bx+2] ; y
    22 00000494 99                  <1>   cwd
    23 00000495 F7F9                <1>   idiv cx
    24 00000497 894702              <1>   mov [bx+2],ax
    25 0000049A C3                  <1>   ret
    26                              <1> 
    27                              <1> v_scale:  ; cx=scaler (x100)
    28 0000049B 8B07                <1>   mov ax, [bx]   ; x
    29 0000049D 99                  <1>   cwd
    30 0000049E F7E9                <1>   imul cx
    31 000004A0 51                  <1>   push cx
    32 000004A1 B96400              <1>   mov cx,100
    33 000004A4 F7F9                <1>   idiv cx
    34 000004A6 59                  <1>   pop cx
    35 000004A7 8907                <1>   mov [bx], ax
    36                              <1> 
    37 000004A9 8B4702              <1>   mov ax, [bx+2]   ; y
    38 000004AC 99                  <1>   cwd
    39 000004AD F7E9                <1>   imul cx
    40 000004AF 51                  <1>   push cx
    41 000004B0 B96400              <1>   mov cx,100
    42 000004B3 F7F9                <1>   idiv cx
    43 000004B5 59                  <1>   pop cx
    44 000004B6 894702              <1>   mov [bx+2], ax
    45 000004B9 C3                  <1>   ret
    46                              <1> 
    47                              <1> v_copy:    ; input bx=target,bp=source: copy vec bp into vec bx
    48 000004BA 8B4600              <1>   mov ax,[bp]
    49 000004BD 8907                <1>   mov [bx],ax
    50 000004BF 8B4602              <1>   mov ax,[bp+2]
    51 000004C2 894702              <1>   mov [bx+2],ax
    52 000004C5 C3                  <1>   ret
    53                              <1> 
    54                              <1> v_add: ; bx contains address of 4 bytes vector such as 'ship.pos', bp contains address of other 4 bytes vector
    55 000004C6 8B07                <1>   mov ax,[bx]
    56 000004C8 034600              <1>   add ax,[bp]     ; bx.x += bp.x
    57 000004CB 8907                <1>   mov [bx],ax
    58 000004CD 8B4702              <1>   mov ax,[bx+2]
    59 000004D0 034602              <1>   add ax,[bp+2]   ; bx.y += bp.y
    60 000004D3 894702              <1>   mov [bx+2],ax
    61 000004D6 C3                  <1>   ret
    62                              <1> 
    63                              <1> v_sub:
    64 000004D7 8B07                <1>   mov ax,[bx]
    65 000004D9 2B4600              <1>   sub ax,[bp]     ; bx.x -= bp.x
    66 000004DC 8907                <1>   mov [bx],ax
    67 000004DE 8B4702              <1>   mov ax,[bx+2]
    68 000004E1 2B4602              <1>   sub ax,[bp+2]   ; bx.y -= bp.y
    69 000004E4 894702              <1>   mov [bx+2],ax
    70 000004E7 C3                  <1>   ret
    71                              <1> 
    72                              <1> v_heading: ; bx contains address of 4 bytes vector
    73 000004E8 8B07                <1>   mov ax,[bx]
    74 000004EA 8B5F02              <1>   mov bx,[bx+2]
    75 000004ED E865FE              <1>   call atan2
    76 000004F0 C3                  <1>   ret
    77                              <1> 
    78                              <1> v_from_angle: ; input: ax=angle, bx=mag, output: ax=x, bx=y
    79 000004F1 B96801              <1>   mov cx,360
    80 000004F4 01C8                <1>   add ax,cx
    81 000004F6 99                  <1>   cwd         ; dx=0
    82 000004F7 F7F9                <1>   idiv cx
    83 000004F9 92                  <1>   xchg ax,dx  ; ax now contains angle wrapped to 360
    84 000004FA B95A00              <1>   mov cx,90
    85 000004FD 99                  <1>   cwd         ; dx=0
    86 000004FE F7F9                <1>   idiv cx      ; dx now contains angle%90 (angle within quadrant)
    87 00000500 50                  <1>   push ax     ; save quadrant 0,1,2,3 on the stack
    88 00000501 89D0                <1>   mov ax,dx   ; ax now contains angle within quadrant
    89 00000503 52                  <1>   push dx     ; save copy of the angle within quadrant for later use
    90 00000504 E825FE              <1>   call sin
    91 00000507 99                  <1>   cwd         ; dx=0
    92 00000508 F7EB                <1>   imul bx      ; ax = sin(ax)*mag
    93 0000050A 89D9                <1>   mov cx,bx   ; cx = mag
    94 0000050C 89C3                <1>   mov bx,ax   ; save ax into bx
    95 0000050E 58                  <1>   pop ax      ; restore angle within quadrant
    96 0000050F E82BFE              <1>   call cos
    97 00000512 99                  <1>   cwd         ; dx=0
    98 00000513 F7E9                <1>   imul cx      ; ax*=mag
    99 00000515 89C2                <1>   mov dx,ax   ; dx = cos()*mag
   100 00000517 59                  <1>   pop cx      ; cx = quadrant 
   101 00000518 83F900              <1>   cmp cx,0
   102 0000051B 741F                <1>   je .q0
   103 0000051D 83F901              <1>   cmp cx,1
   104 00000520 7413                <1>   je .q1
   105 00000522 83F902              <1>   cmp cx,2
   106 00000525 7407                <1>   je .q2
   107                              <1> .q3: ;else
   108 00000527 89D8                <1>   mov ax,bx
   109 00000529 89D3                <1>   mov bx,dx
   110 0000052B F7DB                <1>   neg bx 
   111 0000052D C3                  <1>   ret
   112                              <1> .q2:
   113 0000052E 89D0                <1>   mov ax,dx
   114 00000530 F7D8                <1>   neg ax
   115 00000532 F7DB                <1>   neg bx
   116 00000534 C3                  <1>   ret
   117                              <1> .q1:
   118 00000535 89D8                <1>   mov ax,bx
   119 00000537 F7D8                <1>   neg ax
   120 00000539 89D3                <1>   mov bx,dx
   121 0000053B C3                  <1>   ret
   122                              <1> .q0:
   123 0000053C 89D0                <1>   mov ax,dx
   124 0000053E C3                  <1>   ret
   125                              <1> 
   126                              <1> v_limit: ; [bx] input vector, cx=max_length. updates [bx]
   127 0000053F 89C8                <1>   mov ax,cx              ; ax=cx=max_length
   128                              <1> 
   129 00000541 99                  <1>   cwd
   130 00000542 F7E8                <1>   imul ax                ; ax*=ax
   131 00000544 A3[8805]            <1>   mov [.maxSq],ax
   132                              <1> 
   133 00000547 E84200              <1>   call v_mag_sq          ; ax now contains squared CUR length of [bx]
   134 0000054A A3[8A05]            <1>   mov [.lenSq],ax
   135                              <1> 
   136                              <1> 
   137                              <1>   set_cursor 10,30
    43                              <2> 
    44 0000054D BFB414              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   138 00000550 A1[8805]            <1>   mov ax,[.maxSq]
   139                              <1>   println_ax
    88                              <2>  print_ax
    69 00000553 E80EFD              <3>  call write_signed_number_word
    89 00000556 E8AEFA              <2>  call write_5spaces_newline
   140                              <1> 
   141                              <1>   set_cursor 11,30
    43                              <2> 
    44 00000559 BFF416              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   142 0000055C A1[8A05]            <1>   mov ax,[.lenSq]
   143                              <1>   println_ax
    88                              <2>  print_ax
    69 0000055F E802FD              <3>  call write_signed_number_word
    89 00000562 E8A2FA              <2>  call write_5spaces_newline
   144                              <1> 
   145 00000565 3B06[8805]          <1>   cmp word ax,[.maxSq]
   146 00000569 7E1C                <1>   jle .done              ; no work needed
   147                              <1> 
   148 0000056B 8B07                <1>   mov ax,[bx]            ; x
   149 0000056D 99                  <1>   cwd
   150 0000056E F72E[8805]          <1>   imul word [.maxSq]     ; x*=maxSq
   151 00000572 F73E[8A05]          <1>   idiv word [.lenSq]     ; x/=lenSq
   152 00000576 8907                <1>   mov word [bx],ax
   153                              <1> 
   154 00000578 8B4702              <1>   mov ax,[bx+2]          ; y
   155 0000057B 99                  <1>   cwd
   156 0000057C F72E[8805]          <1>   imul word [.maxSq]     ; y*=maxSq
   157 00000580 F73E[8A05]          <1>   idiv word [.lenSq]     ; y/=lenSq
   158 00000584 894702              <1>   mov word [bx+2],ax
   159                              <1> .done
   160 00000587 C3                  <1>   ret
   161 00000588 0000                <1> .maxSq: dw 0
   162 0000058A 0000                <1> .lenSq: dw 0
   163                              <1> 
   164                              <1> 
   165                              <1> v_mag_sq:   ; bx contains address of 4 bytes vector, destroys cx, returns ax
   166 0000058C 8B07                <1>   mov ax,[bx]
   167 0000058E 99                  <1>   cwd
   168 0000058F F7E8                <1>   imul ax
   169 00000591 89C1                <1>   mov cx,ax   ; use cx for tmp copy of x*x
   170 00000593 8B4702              <1>   mov ax,[bx+2]
   171 00000596 99                  <1>   cwd
   172 00000597 F7E8                <1>   imul ax
   173 00000599 01C8                <1>   add ax,cx
   174 0000059B C3                  <1>   ret
   175                              <1> 
   176                              <1> 
   177                              <1> 
   178                              <1> 
   179                              <1> 
   180                              <1> 
     3                                  
     4                                  ship:
     5                                   .pos:
     6 0000059C 0090                     .pos.x: dw 73728/2              ; 0..73728  (65536)
     7 0000059E F03C                     .pos.y: dw 51200/2 - 10000      ; 0..51200  (=1024*50)
     8                                   .vel: 
     9 000005A0 0000                     .vel.x: dw 0
    10 000005A2 0000                     .vel.y: dw 0
    11 000005A4 0000                     .vel.flags: dw 0
    12 000005A6 0000                     .vel.magSq: dw 0
    13                                   .acc:
    14 000005A8 0000                     .acc.x: dw 0
    15 000005AA 0000                     .acc.y: dw 0
    16                                   .forces:             ; accumulated forces over time
    17 000005AC 0000                     .forces.x: dw 0
    18 000005AE 0000                     .forces.y: dw 0
    19                                   .force:              ; force for this frame derived from accumulated forces
    20 000005B0 0000                     .force.x: dw 0
    21 000005B2 0000                     .force.y: dw 0
    22 000005B4 0000                     .angle: dw 0
    23 000005B6 0000                     .sprite_index: dw 0
    24 000005B8 [FE08]                   .img_addr: dw img_first
    25 000005BA 0000                     .prev_di: dw 0
    26                                  
    27                                  debug:
    28 000005BC 0000                      .ax: dw 0
    29 000005BE 0000                      .bx: dw 0
    30 000005C0 0000                      .cx: dw 0
    31 000005C2 0000                      .dx: dw 0
    32                                  
    33                                  star:
    34 000005C4 0090                     .x: dw 73728/2                ; 0..73728  (65536)
    35 000005C6 0064                     .y: dw 51200/2                ; 0..51200  (=1024*50)
    36                                  
    37 000005C8 0000                    frame_count: dw 0
    38 000005CA 02                      color: db Color.G
    39                                  FRICTION equ 94
    40                                  STEP equ 50
    41                                  FRAME_DELAY EQU 250
    42                                  
    43                                  debug_test:
    44 000005CB C706[AC05]8813            mov word [ship.forces.x], 5000
    45 000005D1 C706[AE05]D007            mov word [ship.forces.y], 2000
    46 000005D7 B96400                    mov cx,100
    47                                  .lp
    48 000005DA 51                        push cx
    49 000005DB BB[AC05]                  mov bx,ship.forces
    50 000005DE B95A00                    mov cx,90
    51 000005E1 E8B7FE                    call v_scale            ; forces *= .9
    52 000005E4 59                        pop cx
    53 000005E5 E8E300                    call draw_debug_info
    54 000005E8 E2F0                      loop .lp
    55 000005EA F4                        hlt
    56                                  
    57                                  setup:
    58                                    ; call debug_test
    59 000005EB 31ED                      xor bp,bp
    60 000005ED EB00                      jmp draw
    61                                  
    62                                  ; ───────────────────────────────────────────────────────────────────────────
    63                                  
    64                                  draw:
    65 000005EF 0E                        push cs
    66 000005F0 1F                        pop ds   ; make sure DS is set to CS for data lookups like [ship.pos.x]
    67                                  
    68 000005F1 E81700                    call update_ship
    69 000005F4 E88E00                    call draw_ship
    70 000005F7 E8D100                    call draw_debug_info
    71                                  
    72 000005FA E8EE02                    call _wait
    73 000005FD FF06[C805]                inc word [frame_count]
    74                                  
    75 00000601 E874FC                    call check_keys
    76 00000604 7403E97802                jnz on_key
    77                                  
    78 00000609 EBE4                      jmp draw          ; this code is only getting called when no key is pressed
    79                                  
    80                                  ; ───────────────────────────────────────────────────────────────────────────
    81                                  
    82                                  update_ship:
    83 0000060B BB[B005]                  mov bx,ship.force
    84 0000060E BD[AC05]                  mov bp,ship.forces
    85 00000611 E8A6FE                    call v_copy             ; force = forces.copy()
    86                                  
    87 00000614 BB[B005]                  mov bx,ship.force
    88 00000617 B91900                    mov cx,25
    89 0000061A E822FF                    call v_limit            ; force.limit(25)
    90                                  
    91 0000061D BB[AC05]                  mov bx,ship.forces
    92 00000620 BD[B005]                  mov bp,ship.force
    93 00000623 E8B1FE                    call v_sub              ; forces -= force
    94                                  
    95 00000626 BB[AC05]                  mov bx,ship.forces
    96 00000629 B96300                    mov cx,99
    97 0000062C E86CFE                    call v_scale            ; forces *= .9
    98                                  
    99 0000062F BB[A805]                  mov bx,ship.acc
   100 00000632 BD[B005]                  mov bp,ship.force
   101 00000635 E88EFE                    call v_add              ; acceleration += forces
   102                                  
   103 00000638 BB[A005]                  mov bx,ship.vel
   104 0000063B BD[A805]                  mov bp,ship.acc
   105 0000063E E885FE                    call v_add              ; velocity += acceleration
   106                                  
   107 00000641 BB[A805]                  mov bx,ship.acc
   108 00000644 B90000                    mov cx,0
   109 00000647 E82FFE                    call v_mult             ; acceleration = 0
   110                                  
   111 0000064A BB[9C05]                  mov bx,ship.pos
   112 0000064D BD[A005]                  mov bp,ship.vel
   113 00000650 E873FE                    call v_add              ; position += velocity
   114                                  
   115 00000653 BB[A005]                  mov bx,ship.vel
   116 00000656 B96200                    mov cx,98
   117 00000659 E83FFE                    call v_scale            ; velocity *= .98
   118                                  
   119                                    ; mov bx,ship.vel
   120                                    ; mov cx,50
   121                                    ; call v_limit            ; max velocity
   122                                  
   123 0000065C BB[A005]                  mov bx,ship.vel
   124 0000065F E82AFF                    call v_mag_sq
   125 00000662 A3[A605]                  mov [ship.vel.magSq],ax
   126                                  
   127 00000665 BB[A005]                  mov bx,ship.vel
   128 00000668 E87DFE                    call v_heading   
   129 0000066B A3[B405]                  mov [ship.angle],ax     ; angle = heading(velocity)
   130                                  
   131 0000066E 31D2                      xor dx,dx
   132 00000670 BB0F00                    mov bx,15
   133 00000673 F7FB                      idiv bx                 ; sprite_index = angle/15 (range 0..23)
   134 00000675 A3[B605]                  mov [ship.sprite_index],ax   
   135 00000678 BB0203                    mov bx,770
   136 0000067B F7E3                      mul bx                  ; img_addr = (668+2 bytes per image * sprite_index)
   137 0000067D 05[FE08]                  add ax,img_first        ; img_addr += img_first (offset)
   138 00000680 A3[B805]                  mov [ship.img_addr],ax
   139                                  
   140 00000683 C3                        ret
   141                                  
   142                                  
   143                                  ; ───────────────────────────────────────────────────────────────────────────
   144                                  
   145                                  draw_stars:
   146 00000684 C3                        ret
   147                                  
   148                                  ; ───────────────────────────────────────────────────────────────────────────
   149                                  
   150                                  draw_ship:
   151 00000685 E8FCFF                    call draw_stars
   152                                  
   153 00000688 A1[9C05]                  mov ax,[ship.pos.x]
   154 0000068B 8B1E[9E05]                mov bx,[ship.pos.y]
   155 0000068F E86102                    call world2screen
   156 00000692 E83DFC                    call calc_di_from_bx
   157                                  
   158 00000695 393E[BA05]                cmp [ship.prev_di],di  
   159                                    ; je .return             ; no screen update needed >>>  DISABLED because ship on fixed position
   160                                  
   161 00000699 8B3E[BA05]                mov di,[ship.prev_di]
   162                                  
   163 0000069D A1[9C05]                  mov ax,[ship.pos.x]
   164 000006A0 8B1E[9E05]                mov bx,[ship.pos.y]
   165 000006A4 E84C02                    call world2screen
   166 000006A7 E828FC                    call calc_di_from_bx
   167 000006AA 83FF00                    cmp di,0
   168 000006AD 7F03                      jg .ok
   169 000006AF BF0000                    mov di,0
   170                                  .ok
   171 000006B2 893E[BA05]                mov [ship.prev_di],di
   172                                  
   173 000006B6 8B36[B805]                mov si,[ship.img_addr]
   174 000006BA A1[9C05]                  mov ax,[ship.pos.x]
   175 000006BD 8B1E[9E05]                mov bx,[ship.pos.y]
   176 000006C1 E82F02                    call world2screen ; ax and bx are already set by pop bx, pop ax
   177 000006C4 E80BFC                    call calc_di_from_bx
   178 000006C7 E8CEFB                    call draw_spr
   179                                  
   180                                  .return
   181 000006CA C3                        ret
   182                                  
   183                                  ; ───────────────────────────────────────────────────────────────────────────
   184                                  
   185                                  draw_debug_info:
   186                                    
   187                                    set_cursor 1,1
    43                              <1> 
    44 000006CB BF0000              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   188                                  
   189                                    print "key: "
    48 000006CE 50                  <1>  push ax
    49 000006CF 53                  <1>  push bx
    50 000006D0 51                  <1>  push cx
    51 000006D1 52                  <1>  push dx
    52 000006D2 EB06                <1>  jmp %%endstr
    53 000006D4 6B65793A2000        <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 000006DA BB[D406]            <1>  mov bx,%%str
    56 000006DD E823FB              <1>  call write_string
    57 000006E0 5A                  <1>  pop dx
    58 000006E1 59                  <1>  pop cx
    59 000006E2 5B                  <1>  pop bx
    60 000006E3 58                  <1>  pop ax
   190 000006E4 A1[0500]                  mov ax,[key]
   191                                    println_ax_bin
   103                              <1>  print_ax_bin
    81 000006E7 E83DFB              <2>  call write_binary_word
   104 000006EA E81AF9              <1>  call write_5spaces_newline
   192                                  
   193                                    print "frame: "
    48 000006ED 50                  <1>  push ax
    49 000006EE 53                  <1>  push bx
    50 000006EF 51                  <1>  push cx
    51 000006F0 52                  <1>  push dx
    52 000006F1 EB08                <1>  jmp %%endstr
    53 000006F3 6672616D653A2000    <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 000006FB BB[F306]            <1>  mov bx,%%str
    56 000006FE E802FB              <1>  call write_string
    57 00000701 5A                  <1>  pop dx
    58 00000702 59                  <1>  pop cx
    59 00000703 5B                  <1>  pop bx
    60 00000704 58                  <1>  pop ax
   194 00000705 A1[C805]                  mov ax,[frame_count]
   195                                    println_ax
    88                              <1>  print_ax
    69 00000708 E859FB              <2>  call write_signed_number_word
    89 0000070B E8F9F8              <1>  call write_5spaces_newline
   196                                  
   197                                    print "vx: "
    48 0000070E 50                  <1>  push ax
    49 0000070F 53                  <1>  push bx
    50 00000710 51                  <1>  push cx
    51 00000711 52                  <1>  push dx
    52 00000712 EB05                <1>  jmp %%endstr
    53 00000714 76783A2000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000719 BB[1407]            <1>  mov bx,%%str
    56 0000071C E8E4FA              <1>  call write_string
    57 0000071F 5A                  <1>  pop dx
    58 00000720 59                  <1>  pop cx
    59 00000721 5B                  <1>  pop bx
    60 00000722 58                  <1>  pop ax
   198 00000723 A1[A005]                  mov ax,[ship.vel.x]  
   199                                    println_ax
    88                              <1>  print_ax
    69 00000726 E83BFB              <2>  call write_signed_number_word
    89 00000729 E8DBF8              <1>  call write_5spaces_newline
   200                                  
   201                                    print "vy: "
    48 0000072C 50                  <1>  push ax
    49 0000072D 53                  <1>  push bx
    50 0000072E 51                  <1>  push cx
    51 0000072F 52                  <1>  push dx
    52 00000730 EB05                <1>  jmp %%endstr
    53 00000732 76793A2000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000737 BB[3207]            <1>  mov bx,%%str
    56 0000073A E8C6FA              <1>  call write_string
    57 0000073D 5A                  <1>  pop dx
    58 0000073E 59                  <1>  pop cx
    59 0000073F 5B                  <1>  pop bx
    60 00000740 58                  <1>  pop ax
   202 00000741 A1[A205]                  mov ax,[ship.vel.y]
   203                                    println_ax
    88                              <1>  print_ax
    69 00000744 E81DFB              <2>  call write_signed_number_word
    89 00000747 E8BDF8              <1>  call write_5spaces_newline
   204                                  
   205                                    print "vel.magSq: "
    48 0000074A 50                  <1>  push ax
    49 0000074B 53                  <1>  push bx
    50 0000074C 51                  <1>  push cx
    51 0000074D 52                  <1>  push dx
    52 0000074E EB0C                <1>  jmp %%endstr
    53 00000750 76656C2E6D61675371- <1>  %%str: db %1,0
    53 00000759 3A2000              <1>
    54                              <1>  %%endstr:
    55 0000075C BB[5007]            <1>  mov bx,%%str
    56 0000075F E8A1FA              <1>  call write_string
    57 00000762 5A                  <1>  pop dx
    58 00000763 59                  <1>  pop cx
    59 00000764 5B                  <1>  pop bx
    60 00000765 58                  <1>  pop ax
   206 00000766 A1[A605]                  mov ax,[ship.vel.magSq]
   207                                    println_ax_unsigned
    93                              <1>  print_ax_unsigned
    73 00000769 E8D3FA              <2>  call write_number_word
    94 0000076C E898F8              <1>  call write_5spaces_newline
   208                                  
   209                                    print "angle: "
    48 0000076F 50                  <1>  push ax
    49 00000770 53                  <1>  push bx
    50 00000771 51                  <1>  push cx
    51 00000772 52                  <1>  push dx
    52 00000773 EB08                <1>  jmp %%endstr
    53 00000775 616E676C653A2000    <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 0000077D BB[7507]            <1>  mov bx,%%str
    56 00000780 E880FA              <1>  call write_string
    57 00000783 5A                  <1>  pop dx
    58 00000784 59                  <1>  pop cx
    59 00000785 5B                  <1>  pop bx
    60 00000786 58                  <1>  pop ax
   210 00000787 A1[B405]                  mov ax,[ship.angle] 
   211                                    println_ax
    88                              <1>  print_ax
    69 0000078A E8D7FA              <2>  call write_signed_number_word
    89 0000078D E877F8              <1>  call write_5spaces_newline
   212                                  
   213                                    print "index: "
    48 00000790 50                  <1>  push ax
    49 00000791 53                  <1>  push bx
    50 00000792 51                  <1>  push cx
    51 00000793 52                  <1>  push dx
    52 00000794 EB08                <1>  jmp %%endstr
    53 00000796 696E6465783A2000    <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 0000079E BB[9607]            <1>  mov bx,%%str
    56 000007A1 E85FFA              <1>  call write_string
    57 000007A4 5A                  <1>  pop dx
    58 000007A5 59                  <1>  pop cx
    59 000007A6 5B                  <1>  pop bx
    60 000007A7 58                  <1>  pop ax
   214 000007A8 A1[B605]                  mov ax,[ship.sprite_index]
   215                                    println_ax
    88                              <1>  print_ax
    69 000007AB E8B6FA              <2>  call write_signed_number_word
    89 000007AE E856F8              <1>  call write_5spaces_newline
   216                                  
   217                                    print "img addr: "
    48 000007B1 50                  <1>  push ax
    49 000007B2 53                  <1>  push bx
    50 000007B3 51                  <1>  push cx
    51 000007B4 52                  <1>  push dx
    52 000007B5 EB0B                <1>  jmp %%endstr
    53 000007B7 696D6720616464723A- <1>  %%str: db %1,0
    53 000007C0 2000                <1>
    54                              <1>  %%endstr:
    55 000007C2 BB[B707]            <1>  mov bx,%%str
    56 000007C5 E83BFA              <1>  call write_string
    57 000007C8 5A                  <1>  pop dx
    58 000007C9 59                  <1>  pop cx
    59 000007CA 5B                  <1>  pop bx
    60 000007CB 58                  <1>  pop ax
   218 000007CC A1[B805]                  mov ax,[ship.img_addr]
   219                                    println_ax_hex
    98                              <1>  print_ax_hex
    77 000007CF E82FFB              <2>  call write_ax_hex
    99 000007D2 E832F8              <1>  call write_5spaces_newline
   220                                  
   221                                    print "force.x: "
    48 000007D5 50                  <1>  push ax
    49 000007D6 53                  <1>  push bx
    50 000007D7 51                  <1>  push cx
    51 000007D8 52                  <1>  push dx
    52 000007D9 EB0A                <1>  jmp %%endstr
    53 000007DB 666F7263652E783A20- <1>  %%str: db %1,0
    53 000007E4 00                  <1>
    54                              <1>  %%endstr:
    55 000007E5 BB[DB07]            <1>  mov bx,%%str
    56 000007E8 E818FA              <1>  call write_string
    57 000007EB 5A                  <1>  pop dx
    58 000007EC 59                  <1>  pop cx
    59 000007ED 5B                  <1>  pop bx
    60 000007EE 58                  <1>  pop ax
   222 000007EF A1[B005]                  mov ax,[ship.force.x]
   223                                    println_ax
    88                              <1>  print_ax
    69 000007F2 E86FFA              <2>  call write_signed_number_word
    89 000007F5 E80FF8              <1>  call write_5spaces_newline
   224                                  
   225                                    print "force.y: "
    48 000007F8 50                  <1>  push ax
    49 000007F9 53                  <1>  push bx
    50 000007FA 51                  <1>  push cx
    51 000007FB 52                  <1>  push dx
    52 000007FC EB0A                <1>  jmp %%endstr
    53 000007FE 666F7263652E793A20- <1>  %%str: db %1,0
    53 00000807 00                  <1>
    54                              <1>  %%endstr:
    55 00000808 BB[FE07]            <1>  mov bx,%%str
    56 0000080B E8F5F9              <1>  call write_string
    57 0000080E 5A                  <1>  pop dx
    58 0000080F 59                  <1>  pop cx
    59 00000810 5B                  <1>  pop bx
    60 00000811 58                  <1>  pop ax
   226 00000812 A1[B205]                  mov ax,[ship.force.y]
   227                                    println_ax
    88                              <1>  print_ax
    69 00000815 E84CFA              <2>  call write_signed_number_word
    89 00000818 E8ECF7              <1>  call write_5spaces_newline
   228                                  
   229                                    print "forces.x: "
    48 0000081B 50                  <1>  push ax
    49 0000081C 53                  <1>  push bx
    50 0000081D 51                  <1>  push cx
    51 0000081E 52                  <1>  push dx
    52 0000081F EB0B                <1>  jmp %%endstr
    53 00000821 666F726365732E783A- <1>  %%str: db %1,0
    53 0000082A 2000                <1>
    54                              <1>  %%endstr:
    55 0000082C BB[2108]            <1>  mov bx,%%str
    56 0000082F E8D1F9              <1>  call write_string
    57 00000832 5A                  <1>  pop dx
    58 00000833 59                  <1>  pop cx
    59 00000834 5B                  <1>  pop bx
    60 00000835 58                  <1>  pop ax
   230 00000836 A1[AC05]                  mov ax,[ship.forces.x]
   231                                    println_ax
    88                              <1>  print_ax
    69 00000839 E828FA              <2>  call write_signed_number_word
    89 0000083C E8C8F7              <1>  call write_5spaces_newline
   232                                  
   233                                    print "forces.y: "
    48 0000083F 50                  <1>  push ax
    49 00000840 53                  <1>  push bx
    50 00000841 51                  <1>  push cx
    51 00000842 52                  <1>  push dx
    52 00000843 EB0B                <1>  jmp %%endstr
    53 00000845 666F726365732E793A- <1>  %%str: db %1,0
    53 0000084E 2000                <1>
    54                              <1>  %%endstr:
    55 00000850 BB[4508]            <1>  mov bx,%%str
    56 00000853 E8ADF9              <1>  call write_string
    57 00000856 5A                  <1>  pop dx
    58 00000857 59                  <1>  pop cx
    59 00000858 5B                  <1>  pop bx
    60 00000859 58                  <1>  pop ax
   234 0000085A A1[AE05]                  mov ax,[ship.forces.y]
   235                                    println_ax
    88                              <1>  print_ax
    69 0000085D E804FA              <2>  call write_signed_number_word
    89 00000860 E8A4F7              <1>  call write_5spaces_newline
   236                                  
   237                                    print "DI: "
    48 00000863 50                  <1>  push ax
    49 00000864 53                  <1>  push bx
    50 00000865 51                  <1>  push cx
    51 00000866 52                  <1>  push dx
    52 00000867 EB05                <1>  jmp %%endstr
    53 00000869 44493A2000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 0000086E BB[6908]            <1>  mov bx,%%str
    56 00000871 E88FF9              <1>  call write_string
    57 00000874 5A                  <1>  pop dx
    58 00000875 59                  <1>  pop cx
    59 00000876 5B                  <1>  pop bx
    60 00000877 58                  <1>  pop ax
   238 00000878 89F8                      mov ax,di
   239                                    println_ax_hex
    98                              <1>  print_ax_hex
    77 0000087A E884FA              <2>  call write_ax_hex
    99 0000087D E887F7              <1>  call write_5spaces_newline
   240                                  
   241                                    ; print "AX: "
   242                                    ; mov ax,[debug.ax]
   243                                    ; println_ax_hex
   244                                  
   245                                    ; print "BX: "
   246                                    ; mov ax,[debug.bx]
   247                                    ; println_ax_hex
   248                                  
   249                                    ; print "CX: "
   250                                    ; mov ax,[debug.cx]
   251                                    ; println_ax_hex
   252                                  
   253                                    ; print "DX: "
   254                                    ; mov ax,[debug.dx]
   255                                    ; println_ax_hex
   256                                  
   257 00000880 C3                        ret
   258                                  
   259                                  ; ───────────────────────────────────────────────────────────────────────────
   260                                  
   261                                  
   262                                  on_key:
   263 00000881 83F877                    cmp ax,'w'
   264 00000884 7412                      je on_key_w
   265 00000886 83F861                    cmp ax,'a'
   266 00000889 7420                      je on_key_a
   267 0000088B 83F873                    cmp ax,'s'
   268 0000088E 7447                      je on_key_s
   269 00000890 83F864                    cmp ax,'d'
   270 00000893 742C                      je on_key_d
   271                                  .done
   272 00000895 E957FD                    jmp draw  ; no ret here because onkey is called by jnz
   273                                  
   274                                  ; ───────────────────────────────────────────────────────────────────────────
   275                                  
   276                                  on_key_w:
   277                                    ; add word [ship.forces.y], -STEP
   278                                  
   279 00000898 A1[B405]                  mov ax,[ship.angle]
   280 0000089B BB0100                    mov bx,1    ; magnitude
   281 0000089E E850FC                    call v_from_angle
   282 000008A1 0106[AC05]                add word [ship.forces.x], ax
   283 000008A5 011E[AE05]                add word [ship.forces.y], bx
   284                                  
   285 000008A9 EBEA                      jmp on_key.done
   286                                  
   287                                  ; ───────────────────────────────────────────────────────────────────────────
   288                                  
   289                                  on_key_a:
   290                                    ; add word [ship.forces.x], -STEP
   291                                  
   292 000008AB A1[B405]                  mov ax,[ship.angle]
   293 000008AE 83C0D3                    add ax,-45   ; angle
   294 000008B1 BB0100                    mov bx,1    ; magnitude
   295 000008B4 E83AFC                    call v_from_angle
   296 000008B7 0106[AC05]                add word [ship.forces.x], ax
   297 000008BB 011E[AE05]                add word [ship.forces.y], bx
   298                                  
   299 000008BF EBD4                      jmp on_key.done
   300                                  
   301                                  ; ───────────────────────────────────────────────────────────────────────────
   302                                  
   303                                  on_key_d:
   304                                    ; add word [ship.forces.x], STEP
   305                                  
   306 000008C1 A1[B405]                  mov ax,[ship.angle]
   307 000008C4 83C02D                    add ax,45   ; angle
   308 000008C7 BB0100                    mov bx,1    ; magnitude
   309 000008CA E824FC                    call v_from_angle
   310 000008CD 0106[AC05]                add word [ship.forces.x], ax
   311 000008D1 011E[AE05]                add word [ship.forces.y], bx
   312                                  
   313 000008D5 EBBE                      jmp on_key.done
   314                                  
   315                                  ; ───────────────────────────────────────────────────────────────────────────
   316                                  
   317                                  on_key_s:
   318                                    ; add word [ship.forces.y], STEP
   319                                  
   320                                    ;;;;;;;;;;;;; remmen:
   321                                  
   322 000008D7 BB[AC05]                  mov bx,ship.forces
   323 000008DA B90000                    mov cx,0
   324 000008DD E899FB                    call v_mult
   325                                  
   326 000008E0 BB[A005]                  mov bx,ship.vel
   327 000008E3 B93200                    mov cx,50
   328 000008E6 E8B2FB                    call v_scale
   329                                  
   330 000008E9 EBAA                      jmp on_key.done
   331                                    ; ───────────────────────────────────────────────────────────────────────────
   332                                  
   333                                  
   334                                  _wait:
   335 000008EB B9FA00                    mov cx,FRAME_DELAY
   336 000008EE D40A                      .lp aam
   337 000008F0 E2FC                      loop .lp
   338 000008F2 C3                        ret
   339                                  
   340                                  ; ───────────────────────────────────────────────────────────────────────────
   341                                  
   342                                  world2screen:  ; input (ax,bx) = (world.x, world.y)   ; screen (row,col)
   343                                    ; WORLD:
   344                                    ;   0..73728  (65536) -> col
   345                                    ;   0..51200  (=1024*50) -> row
   346                                    ; SCREEN (ROW,COL):
   347                                    ;   0..49 (row)
   348                                    ;   0..71 (col)
   349 000008F3 B10A                      mov cl,10
   350 000008F5 D3EB                      shr bx,cl   ; //bl=row 0..49
   351 000008F7 D3E8                      shr ax,cl   ; 
   352 000008F9 88C7                      mov bh,al   ; //bh=col 0..71
   353 000008FB 86DF                      xchg bh,bl
   354 000008FD C3                        ret
   355                                  
   356                                  ; ───────────────────────────────────────────────────────────────────────────
   357                                  
   358                                  img_first:
   359                                  img_right:
   360 000008FE <bin 302h>              img7: incbin "data/ship-7.spr" ;right
   361 00000C00 <bin 302h>              img8: incbin "data/ship-8.spr"
   362 00000F02 <bin 302h>              img9: incbin "data/ship-9.spr"
   363                                  img_down_right:
   364 00001204 <bin 302h>              img10: incbin "data/ship-10.spr" ;down-right
   365 00001506 <bin 302h>              img11: incbin "data/ship-11.spr"
   366 00001808 <bin 302h>              img12: incbin "data/ship-12.spr"
   367                                  img_down:
   368 00001B0A <bin 302h>              img13: incbin "data/ship-13.spr" ;down
   369 00001E0C <bin 302h>              img14: incbin "data/ship-14.spr"
   370 0000210E <bin 302h>              img15: incbin "data/ship-15.spr"
   371                                  img_down_left:
   372 00002410 <bin 302h>              img16: incbin "data/ship-16.spr" ;down-left
   373 00002712 <bin 302h>              img17: incbin "data/ship-17.spr"
   374 00002A14 <bin 302h>              img18: incbin "data/ship-18.spr"
   375                                  img_left:
   376 00002D16 <bin 302h>              img19: incbin "data/ship-19.spr" ;left
   377 00003018 <bin 302h>              img20: incbin "data/ship-20.spr"
   378 0000331A <bin 302h>              img21: incbin "data/ship-21.spr"
   379                                  img_up_left:
   380 0000361C <bin 302h>              img22: incbin "data/ship-22.spr" ;up-left
   381 0000391E <bin 302h>              img23: incbin "data/ship-23.spr"
   382 00003C20 <bin 302h>              img24: incbin "data/ship-24.spr"
   383                                  img_up:
   384 00003F22 <bin 302h>              img1: incbin "data/ship-1.spr" ;up
   385 00004224 <bin 302h>              img2: incbin "data/ship-2.spr"
   386 00004526 <bin 302h>              img3: incbin "data/ship-3.spr"
   387                                  img_up_right:
   388 00004828 <bin 302h>              img4: incbin "data/ship-4.spr" ;up-right
   389 00004B2A <bin 302h>              img5: incbin "data/ship-5.spr"
   390 00004E2C <bin 302h>              img6: incbin "data/ship-6.spr"
   391                                  
   392                                  
   393                                  ; %assign num $-$$
   394                                  ; %warning total num
   395                                  
   396 0000512E 00<rep 27ED2h>          times (180*1024)-($-$$) db 0
   397                                  
   398                                  
   399                                  
