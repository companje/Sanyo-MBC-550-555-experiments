     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 EB2B                <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 80          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34                              <1> cursor:
    35 00000002 00                  <1> .col: db 0
    36 00000003 00                  <1> .row: db 0
    37                              <1> 
    38                              <1> key:
    39 00000004 00                  <1>   .code db 0
    40 00000005 00                  <1>   .ctrl db 0
    41                              <1> 
    42                              <1> %macro set_cursor 2
    43                              <1>   ; mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    44                              <1>   mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    45                              <1> %endmacro
    46                              <1> 
    47                              <1> %macro print 1
    48                              <1>   push ax
    49                              <1>   push bx
    50                              <1>   push cx
    51                              <1>   push dx
    52                              <1>   jmp %%endstr 
    53                              <1>   %%str: db %1,0
    54                              <1>   %%endstr: 
    55                              <1>   mov bx,%%str
    56                              <1>   call write_string
    57                              <1>   pop dx
    58                              <1>   pop cx
    59                              <1>   pop bx
    60                              <1>   pop ax
    61                              <1> %endmacro
    62                              <1> 
    63                              <1> %macro register_interrupt 1
    64                              <1>   mov ax,%1
    65                              <1>   stosw
    66                              <1>   mov ax,cs
    67                              <1>   stosw
    68                              <1> %endmacro
    69                              <1> 
    70                              <1> ; int0: hlt
    71                              <1> ; int1: hlt
    72                              <1> ; int2: hlt
    73                              <1> ; int3: hlt
    74                              <1> ; int4: hlt
    75                              <1> 
    76                              <1> int0:; int0: Division by zero
    77 00000006 FC                  <1>   cld
    78 00000007 B800F4              <1>   mov ax,BLUE
    79 0000000A 8EC0                <1>   mov es,ax
    80 0000000C 31FF                <1>   xor di,di
    81 0000000E B9201C              <1>   mov cx,7200
    82 00000011 B8FFFF              <1>   mov ax,-1
    83 00000014 F3AB                <1>   rep stosw
    84 00000016 F4                  <1>   hlt
    85                              <1> 
    86                              <1>   ; set_cursor 5,5
    87                              <1>   ; print "Division by zero"
    88                              <1>   ; hlt
    89                              <1> 
    90                              <1> int1:; int1: Single step debugging
    91 00000017 B001                <1>   mov al,1
    92 00000019 EB09                <1>   jmp int_msg
    93                              <1> int2:; int2: Non maskable interrupt
    94 0000001B B002                <1>   mov al,2
    95 0000001D EB05                <1>   jmp int_msg
    96                              <1> int3:; int3: For one-byte interrupt
    97 0000001F F4                  <1>   hlt
    98                              <1>   ; push ax
    99                              <1>   ; push bx
   100                              <1>   ; push cx
   101                              <1>   ; push dx
   102                              <1>   ; push si
   103                              <1>   ; push di
   104                              <1>   ; push bp
   105                              <1>   ; push ds
   106                              <1>   ; push es
   107                              <1> 
   108                              <1>   ; ; mov di,10*4
   109                              <1>   ; ; set_cursor 5,5
   110                              <1>   ; xor di,di
   111                              <1>   ; print "int3:"
   112                              <1>   ; ; mov ax,cx
   113                              <1>   ; ; call write_number_word
   114                              <1> 
   115                              <1>   ; pop es
   116                              <1>   ; pop ds
   117                              <1>   ; pop bp
   118                              <1>   ; pop di
   119                              <1>   ; pop si
   120                              <1>   ; pop dx
   121                              <1>   ; pop cx
   122                              <1>   ; pop bx
   123                              <1>   ; pop ax
   124                              <1>   ; iret
   125                              <1> 
   126                              <1> int4:; int4: Signed overflow
   127 00000020 B004                <1>   mov al,4
   128 00000022 EB00                <1>   jmp int_msg
   129                              <1> int_msg:
   130 00000024 BFF401              <1>   mov di,500
   131                              <1>   ; xor di,di
   132                              <1>   ; mov ax,di
   133                              <1>   ; mov cx,8*72  
   134                              <1>   ; rep stosw
   135                              <1>   ; xor di,di
   136                              <1>   ; push ax
   137                              <1>   ; print "int: "
   138                              <1>   ; pop ax
   139 00000027 0430                <1>   add al,'0'
   140 00000029 E8FF00              <1>   call write_char
   141                              <1>   ; print "      "
   142                              <1>   
   143 0000002C F4                  <1>   hlt
   144                              <1> 
   145                              <1> boot:
   146 0000002D FA                  <1>   cli
   147 0000002E FC                  <1>   cld
   148 0000002F E8E600              <1>   call clear_green    
   149                              <1> 
   150                              <1>   ; init video      
   151 00000032 B005                <1>   mov al, 5
   152 00000034 E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
   153                              <1>  
   154                              <1>   ; register interrupts
   155 00000036 31FF                <1>   xor di,di ; offset 0
   156 00000038 8EC7                <1>   mov es,di ; segment 0
   157                              <1>   register_interrupt int0
    64 0000003A B8[0600]            <2>  mov ax,%1
    65 0000003D AB                  <2>  stosw
    66 0000003E 8CC8                <2>  mov ax,cs
    67 00000040 AB                  <2>  stosw
   158                              <1>   register_interrupt int1
    64 00000041 B8[1700]            <2>  mov ax,%1
    65 00000044 AB                  <2>  stosw
    66 00000045 8CC8                <2>  mov ax,cs
    67 00000047 AB                  <2>  stosw
   159                              <1>   register_interrupt int2
    64 00000048 B8[1B00]            <2>  mov ax,%1
    65 0000004B AB                  <2>  stosw
    66 0000004C 8CC8                <2>  mov ax,cs
    67 0000004E AB                  <2>  stosw
   160                              <1>   register_interrupt int3
    64 0000004F B8[1F00]            <2>  mov ax,%1
    65 00000052 AB                  <2>  stosw
    66 00000053 8CC8                <2>  mov ax,cs
    67 00000055 AB                  <2>  stosw
   161                              <1>   register_interrupt int4
    64 00000056 B8[2000]            <2>  mov ax,%1
    65 00000059 AB                  <2>  stosw
    66 0000005A 8CC8                <2>  mov ax,cs
    67 0000005C AB                  <2>  stosw
   162                              <1> 
   163                              <1> 
   164                              <1>   ; init other hardware
   165 0000005D B000                <1>   mov al,0
   166 0000005F E63A                <1>   out 0x3a,al           ; keyboard \force state/
   167 00000061 E63A                <1>   out 0x3a,al           ; keyboard \force state/
   168 00000063 B0FF                <1>   mov al,0xFF
   169 00000065 E63A                <1>   out 0x3a,al           ; keyboard \reset/
   170 00000067 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   171 00000069 B037                <1>   mov al,0x37
   172 0000006B E63A                <1>   out 0x3a,al           ; keyboard \set command
   173                              <1> 
   174 0000006D B8001C              <1>   mov ax,GREEN      
   175 00000070 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   176 00000072 B83800              <1>   mov ax,DST                
   177 00000075 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   178 00000077 BF0000              <1>   mov di,0                  ;
   179 0000007A B200                <1>   mov dl,0                  ; track=0
   180 0000007C B601                <1>   mov dh,1                  ; sector=1
   181 0000007E B95000              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   182 00000081 EB0B                <1>   jmp move_head
   183                              <1> 
   184                              <1> ; ───────────────────────────────────────────────────────────────────────────
   185                              <1> 
   186                              <1> next_sector:
   187 00000083 FEC6                <1>   inc dh                    ; sector++
   188 00000085 80FE0A              <1>   cmp dh,10
   189 00000088 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   190 0000008A B601                <1>   mov dh,1
   191 0000008C FEC2                <1>   inc dl                    ; else track++ ; sector=1
   192                              <1> 
   193                              <1> move_head:
   194 0000008E 88D0                <1>   mov al,dl
   195 00000090 E60E                <1>   out 0Eh,al               ; set track number
   196 00000092 B018                <1>   mov al,18h     
   197 00000094 E608                <1>   out 8,al                 ; seek track, load head
   198 00000096 B000                <1>   mov al,0
   199 00000098 E61C                <1>   out 1Ch,al               ; set desired drive/side
   200 0000009A D40A                <1>   aam
   201                              <1> 
   202                              <1> head_moving:
   203 0000009C E408                <1>   in al,8
   204 0000009E A801                <1>   test al,1
   205 000000A0 75FA                <1>   jnz head_moving
   206                              <1> 
   207                              <1> read_sector:
   208 000000A2 88F0                <1>   mov al,dh
   209 000000A4 E60C                <1>   out 0Ch,al                ; sector number
   210 000000A6 B702                <1>   mov bh,2                  ; 00000010b
   211 000000A8 B396                <1>   mov bl,96h                ; 10010110b
   212 000000AA B400                <1>   mov ah,0
   213 000000AC B080                <1>   mov al,80h
   214 000000AE E608                <1>   out 8,al                  ; read sector
   215 000000B0 D40A<rep 4h>        <1>   times 4 aam               ; wait
   216                              <1> 
   217                              <1> check_status_1:
   218 000000B8 E408                <1>   in al,8                   ; read status
   219 000000BA D0F8                <1>   sar al,1                  ; status/=2
   220 000000BC 731F                <1>   jnb check_status_3
   221 000000BE 75F8                <1>   jnz check_status_1
   222                              <1> 
   223                              <1> wait_for_data:
   224 000000C0 E408                <1>   in al,8                   ; read status
   225 000000C2 20D8                <1>   and al,bl                 ; 96h
   226 000000C4 74FA                <1>   jz wait_for_data
   227                              <1> 
   228                              <1> store_byte_1:
   229 000000C6 E40E                <1>   in al,0Eh
   230 000000C8 AA                  <1>   stosb
   231                              <1> 
   232                              <1> check_status_2:
   233 000000C9 E408                <1>   in al,8                   ; read status
   234 000000CB 48                  <1>   dec ax                    ; status--
   235 000000CC 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   236 000000CE 38F8                <1>   cmp al, bh                ; bh=2
   237 000000D0 750B                <1>   jnz check_status_3        ; if (status==1) 
   238                              <1> 
   239                              <1> store_byte_2:
   240 000000D2 E40E                <1>   in al,0Eh  
   241 000000D4 AA                  <1>   stosb
   242                              <1> 
   243                              <1> check_status_4:
   244 000000D5 E408                <1>   in al,8                   ; read status
   245 000000D7 38F8                <1>   cmp al, bh                ; bh=2
   246 000000D9 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   247 000000DB EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   248                              <1> 
   249                              <1> ; ───────────────────────────────────────────────────────────────────────────
   250                              <1> 
   251                              <1> check_status_3:
   252 000000DD E408                <1>   in al, 8                  ; read status
   253 000000DF A81C                <1>   test al, 1Ch              ; 00011100
   254 000000E1 7402                <1>   jz while_sectors
   255 000000E3 EBBD                <1>   jmp read_sector
   256                              <1> 
   257                              <1> ; ───────────────────────────────────────────────────────────────────────────
   258                              <1> 
   259                              <1> while_sectors:
   260 000000E5 E80F00              <1>   call progress_bar
   261 000000E8 E299                <1>   loop next_sector
   262                              <1> 
   263                              <1> done_reading:
   264 000000EA 0E                  <1>   push cs
   265 000000EB 17                  <1>   pop ss
   266 000000EC BC0000              <1>   mov sp,0
   267 000000EF E82600              <1>   call clear_green
   268 000000F2 0E                  <1>   push cs
   269 000000F3 1F                  <1>   pop ds
   270 000000F4 E9CD02              <1>   jmp setup
   271                              <1> 
   272                              <1> ; ───────────────────────────────────────────────────────────────────────────
   273                              <1> 
   274                              <1> progress_bar:
   275                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   276 000000F7 52                  <1>   push dx
   277 000000F8 53                  <1>   push bx
   278 000000F9 31D2                <1>   xor dx,dx
   279 000000FB B81E00              <1>   mov ax,BAR_WIDTH
   280 000000FE BB5000              <1>   mov bx,NUM_SECTORS    
   281 00000101 F7E1                <1>   mul cx
   282 00000103 F7F3                <1>   div bx
   283 00000105 5B                  <1>   pop bx
   284 00000106 5A                  <1>   pop dx
   285 00000107 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   286 00000109 D1E6                <1>   shl si,1                  ; *=2
   287 0000010B D1E6                <1>   shl si,1                  ; *=2  
   288 0000010D BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   289 00000110 29F5                <1>   sub bp,si
   290 00000112 3EC64600FF          <1>   mov byte [ds:bp],-1
   291 00000117 C3                  <1>   ret
   292                              <1> 
   293                              <1> ; clear_red:
   294                              <1> ;   mov ax,RED
   295                              <1> ;   call clear_channel
   296                              <1> ;   ret
   297                              <1> 
   298                              <1> clear_green:
   299 00000118 B8001C              <1>   mov ax,GREEN
   300 0000011B E80100              <1>   call clear_channel
   301 0000011E C3                  <1>   ret
   302                              <1> 
   303                              <1> ; clear_blue:
   304                              <1> ;   mov ax,BLUE
   305                              <1> ;   call clear_channel
   306                              <1> ;   ret
   307                              <1> 
   308                              <1> ; clear_screen:
   309                              <1> ;   call clear_red
   310                              <1> ;   call clear_green
   311                              <1> ;   call clear_blue
   312                              <1> ;   ret
   313                              <1> 
   314                              <1> clear_channel:
   315 0000011F 8EC0                <1>   mov es,ax
   316 00000121 B9201C              <1>   mov cx,COLS*ROWS*2
   317 00000124 31FF                <1>   xor di,di
   318 00000126 31C0                <1>   xor ax,ax
   319 00000128 F3AB                <1>   rep stosw         ; clear screen
   320 0000012A C3                  <1>   ret
   321                              <1> 
   322                              <1> ; ───────────────────────────────────────────────────────────────────────────
   323                              <1> 
   324                              <1> ; write_char:   ; ds=FONT, es=GREEN, al=charcode
   325                              <1> ;   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   326                              <1> ;   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   327                              <1> ;   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   328                              <1> 
   329                              <1> ;   push ds
   330                              <1> ;   push es
   331                              <1> ;   push ax
   332                              <1> ;   push bx
   333                              <1> ;   push cx
   334                              <1> 
   335                              <1> ;   push ax
   336                              <1> ;   mov ax,GREEN
   337                              <1> ;   mov es,ax
   338                              <1> ;   mov ax,FONT
   339                              <1> ;   mov ds,ax
   340                              <1> ;   pop ax
   341                              <1> 
   342                              <1> ;   ; mov ax,65*8
   343                              <1> ;   ; mov al,'x'
   344                              <1> ;   mov ah,8
   345                              <1> ;   mul ah        ; ax=al*ah
   346                              <1> 
   347                              <1> ;   mov si,ax
   348                              <1> ;   movsw
   349                              <1> ;   movsw
   350                              <1> ;   add di,0x11c
   351                              <1> ;   movsw
   352                              <1> ;   movsw
   353                              <1> ;   mov bx,288
   354                              <1> ;   sub di,bx
   355                              <1>   
   356                              <1> ;   ; pop ax
   357                              <1> ;   ; pop es
   358                              <1> ;   ; pop ds
   359                              <1> ;   ; ret
   360                              <1> 
   361                              <1> 
   362                              <1> ;   ; row snap
   363                              <1> ;   xor dx,dx
   364                              <1> ;   mov ax,di
   365                              <1> ;   div bx
   366                              <1> ;   cmp dx,0
   367                              <1> ;   jne .return
   368                              <1> ;   add di,bx
   369                              <1> 
   370                              <1> 
   371                              <1> ;   ; wrap to top
   372                              <1> ;   cmp di,14400   ; dit later oplossen met cursor positie
   373                              <1> ;   jb .return
   374                              <1> ;   ; xor di,di      ; move to left top. change later to scroll
   375                              <1> 
   376                              <1> ;   ; TODO: call scroll_down
   377                              <1> ;   ; std
   378                              <1> ;   ; push di
   379                              <1> ;   ; push cx
   380                              <1> ;   ; mov cx,4*72*24
   381                              <1> ;   ; mov ax,0
   382                              <1> ;   ; rep stosw
   383                              <1> ;   ; pop cx
   384                              <1> ;   ; pop di
   385                              <1> ;   ; cld
   386                              <1> 
   387                              <1> ;   ; DONE: clear last line
   388                              <1> ;   sub di,bx
   389                              <1> ;   sub di,bx
   390                              <1> ;   push di
   391                              <1> ;   push cx
   392                              <1> ;   mov cx,COLS*ROWS*2
   393                              <1> ;   xor ax,ax
   394                              <1> ;   rep stosw         ; clear screen
   395                              <1> ;   pop cx
   396                              <1> ;   pop di
   397                              <1> 
   398                              <1> ; .return
   399                              <1> ;   push bx
   400                              <1> ;   push cx
   401                              <1> ;   pop ax
   402                              <1> ;   pop es
   403                              <1> ;   pop ds
   404                              <1> ;   ret
   405                              <1> 
   406                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   407                              <1> 
   408                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   409 0000012B 52                  <1>   push dx
   410 0000012C 1E                  <1>   push ds
   411 0000012D 06                  <1>   push es
   412 0000012E 50                  <1>   push ax
   413 0000012F 53                  <1>   push bx
   414 00000130 31D2                <1>   xor dx,dx
   415 00000132 50                  <1>   push ax  ; voor character pop
   416 00000133 B8001C              <1>   mov ax,GREEN
   417 00000136 8EC0                <1>   mov es,ax
   418 00000138 B800FF              <1>   mov ax,FONT
   419 0000013B 8ED8                <1>   mov ds,ax
   420 0000013D 58                  <1>   pop ax
   421 0000013E B408                <1>   mov ah,8
   422 00000140 F6E4                <1>   mul ah        ; al*=ah
   423 00000142 89C6                <1>   mov si,ax  
   424                              <1> 
   425 00000144 A5                  <1>   movsw
   426 00000145 A5                  <1>   movsw
   427 00000146 81C71C01            <1>   add di,0x11c
   428 0000014A A5                  <1>   movsw
   429 0000014B A5                  <1>   movsw
   430 0000014C 81EF2001            <1>   sub di,0x120
   431                              <1> 
   432                              <1> 
   433                              <1>   ; cmp di,14400   ; dit later oplossen met cursor positie
   434                              <1>   ; jb .return
   435                              <1>   ; xor di,di      ; move to left top. change later to scroll
   436                              <1> 
   437                              <1>   ; row snap
   438 00000150 BB2001              <1>   mov bx,288   ; /////////// dit gaf problemen waarsch omdat bx niet gepushed werd
   439 00000153 31D2                <1>   xor dx,dx
   440 00000155 89F8                <1>   mov ax,di
   441 00000157 F7F3                <1>   div bx       ; ///dit ook als BX 0 is
   442 00000159 83FA00              <1>   cmp dx,0
   443 0000015C 7502                <1>   jne .return
   444 0000015E 01DF                <1>   add di,bx
   445                              <1> 
   446                              <1> .return
   447 00000160 5B                  <1>   pop bx
   448 00000161 58                  <1>   pop ax
   449 00000162 07                  <1>   pop es
   450 00000163 1F                  <1>   pop ds
   451 00000164 5A                  <1>   pop dx
   452 00000165 C3                  <1>   ret
   453                              <1> 
   454                              <1> write_string:
   455 00000166 2E8A07              <1>   mov al,[cs:bx]
   456 00000169 43                  <1>   inc bx
   457 0000016A 08C0                <1>   or al,al
   458 0000016C 7405                <1>   jz .return
   459 0000016E E8BAFF              <1>   call write_char
   460 00000171 EBF3                <1>   jmp short write_string
   461                              <1> .return
   462 00000173 C3                  <1>   ret
   463                              <1> 
   464                              <1> ; ───────────────────────────────────────────────────────────────────────────
   465                              <1> 
   466                              <1> write_binary_byte:    ; input AL
   467 00000174 50                  <1>   push ax
   468 00000175 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   469 00000177 B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   470                              <1> .lp:
   471 0000017A D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   472 0000017C B80000              <1>   mov ax, 0           ; AH leegmaken
   473 0000017F 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   474 00000181 51                  <1>   push cx             ; CX opslaan
   475 00000182 E8A6FF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   476 00000185 59                  <1>   pop cx              ; CX herstellen
   477 00000186 E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   478 00000188 58                  <1>   pop ax
   479 00000189 C3                  <1>   ret
   480                              <1> 
   481                              <1> ; ───────────────────────────────────────────────────────────────────────────
   482                              <1> 
   483                              <1> write_binary_word:    ; input AX
   484 0000018A 50                  <1>   push ax
   485 0000018B 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   486 0000018C 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   487 0000018E B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   488                              <1> .lp:
   489 00000191 D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   490 00000193 B80000              <1>   mov ax, 0          ; AH leegmaken
   491 00000196 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   492 00000198 51                  <1>   push cx            ; CX opslaan
   493 00000199 E88FFF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   494 0000019C 59                  <1>   pop cx             ; CX herstellen
   495 0000019D E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   496 0000019F 5A                  <1>   pop dx             ; DX herstellen
   497 000001A0 58                  <1>   pop ax
   498 000001A1 C3                  <1>   ret
   499                              <1> 
   500                              <1> 
   501                              <1> ; ───────────────────────────────────────────────────────────────────────────
   502                              <1> 
   503                              <1> write_number_word:
   504 000001A2 50                  <1>     push ax
   505 000001A3 52                  <1>     push dx
   506 000001A4 31D2                <1>     xor dx,dx
   507 000001A6 52                  <1>     push dx ;high byte is zero
   508 000001A7 31D2                <1> .clp xor dx,dx
   509 000001A9 2EF736[C501]        <1>     cs div word [.base]
   510 000001AE 92                  <1>     xchg ax,dx
   511 000001AF 05300E              <1>     add ax,0xe30
   512 000001B2 50                  <1>     push ax
   513 000001B3 92                  <1>     xchg ax,dx
   514 000001B4 09C0                <1>     or ax,ax
   515 000001B6 75EF                <1>     jnz .clp
   516 000001B8 58                  <1> .dlp pop ax
   517 000001B9 08E4                <1>     or ah,ah
   518 000001BB 7405                <1>     jz .done
   519 000001BD E86BFF              <1>     call write_char
   520 000001C0 EBF6                <1>     jmp short .dlp
   521 000001C2 5A                  <1> .done pop dx
   522 000001C3 58                  <1>     pop ax
   523 000001C4 C3                  <1>     ret
   524 000001C5 0A00                <1> .base dw 10
   525                              <1> 
   526                              <1> ; ───────────────────────────────────────────────────────────────────────────
   527                              <1> 
   528                              <1> write_signed_number_word:  
   529 000001C7 50                  <1>     push ax
   530 000001C8 09C0                <1>     or ax,ax
   531 000001CA 790A                <1>     jns .write_return        ; if >0 write and return
   532 000001CC 50                  <1>     push ax
   533 000001CD B82D00              <1>     mov ax,'-'
   534 000001D0 E858FF              <1>     call write_char
   535 000001D3 58                  <1>     pop ax
   536 000001D4 F7D8                <1>     neg ax                   ; destroys ax when negative
   537                              <1> .write_return:
   538 000001D6 E8C9FF              <1>     call write_number_word
   539 000001D9 58                  <1>     pop ax
   540 000001DA C3                  <1>     ret
   541                              <1> 
   542                              <1> ; ───────────────────────────────────────────────────────────────────────────
   543                              <1> 
   544                              <1> check_keys:
   545 000001DB E43A                <1>   in al,0x3a        ; get keyboard status
   546 000001DD 88C4                <1>   mov ah,al
   547 000001DF 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   548 000001E1 2EA2[0500]          <1>   mov [cs:key.ctrl],al
   549 000001E5 F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   550 000001E8 7410                <1>   jz .return
   551 000001EA E438                <1>   in al,0x38        ; get data byte from keyboard  
   552 000001EC 2EA2[0400]          <1>   mov [cs:key.code],al
   553 000001F0 B037                <1>   mov al,0x37
   554 000001F2 E63A                <1>   out 0x3a,al       ; drop key?  
   555 000001F4 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   556 000001F6 2EA1[0400]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   557 000001FA C3                  <1> .return ret
   558                              <1> 
   559                              <1> 
   560                              <1> 
   561                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   562                              <1> ;   ret
   563                              <1> 
   564                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   565                              <1> 
   566                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   567                              <1> ; much faster and simpler on the grid than off the grid
   568                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   569                              <1> 
   570                              <1> 
   571                              <1> ; wide font by stretching the font horizontally using bitshift
   572                              <1> 
   573                              <1> 
   574                              <1> ; fill_white:
   575                              <1> ;   mov ax,0xffff
   576                              <1> ;   call fill_red
   577                              <1> ;   call fill_green
   578                              <1> ;   call fill_blue
   579                              <1> ;   ret
   580                              <1> 
   581                              <1> ; fill_pink:
   582                              <1> ;   mov ax,0xffff
   583                              <1> ;   call fill_red
   584                              <1> ;   mov ah,0b01010101
   585                              <1> ;   mov al,0b10101010
   586                              <1> ;   call fill_green
   587                              <1> ;   call fill_blue
   588                              <1> ;   ret
   589                              <1> 
   590                              <1> ; fill_pink2:
   591                              <1> ;   mov ax,0xffff
   592                              <1> ;   call fill_red
   593                              <1> ;   mov ah,0b11001100
   594                              <1> ;   mov al,0b00110011
   595                              <1> ;   call fill_green
   596                              <1> ;   call fill_blue
   597                              <1> ;   ret
   598                              <1> 
   599                              <1> ; fill_pink3:
   600                              <1> ;   mov ax,0xffff
   601                              <1> ;   call fill_red
   602                              <1> ;   mov ah,0b00010001
   603                              <1> ;   mov al,0b01000100
   604                              <1> ;   call fill_green
   605                              <1> ;   call fill_blue
   606                              <1> ;   ret
   607                              <1> 
   608                              <1> ; fill_pink4:
   609                              <1> ;   mov ax,0xffff
   610                              <1> ;   call fill_red
   611                              <1> ;   mov ah,0b11110111
   612                              <1> ;   mov al,0b01111111
   613                              <1> ;   call fill_green
   614                              <1> ;   call fill_blue
   615                              <1> ;   ret
   616                              <1> 
   617                              <1> ; fill_red:
   618                              <1> ;   mov bx,RED
   619                              <1> ;   call fill_channel
   620                              <1> ;   ret
   621                              <1> ; fill_green:
   622                              <1> ;   mov bx,GREEN
   623                              <1> ;   call fill_channel
   624                              <1> ;   ret
   625                              <1> ; fill_blue:
   626                              <1> ;   mov bx,BLUE
   627                              <1> ;   call fill_channel
   628                              <1> ;   ret
   629                              <1> 
   630                              <1> ; fill_channel: ;ax=pattern
   631                              <1> ;   mov es,bx
   632                              <1> ;   mov cx,COLS*ROWS*2
   633                              <1> ;   xor di,di
   634                              <1> ;   rep stosw
   635                              <1> ;   ret
   636                              <1> 
   637                              <1> ; ───────────────────────────────────────────────────────────────────────────
   638                              <1> 
   639                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   640                              <1> ;   push bx
   641                              <1> ;   push di
   642                              <1> ;   mov es,ax
   643                              <1> ;   xor cx,cx
   644                              <1> ;   mov cl,bh        ; rows (bl)
   645                              <1> ; .rows_loop:
   646                              <1> ;   push cx
   647                              <1> ;   xor cx,cx
   648                              <1> ;   mov cl,bl        ; cols (bh)
   649                              <1> ; .cols_loop:
   650                              <1> ;   mov ax,0
   651                              <1> ;   stosw
   652                              <1> ;   stosw
   653                              <1> ;   loop .cols_loop
   654                              <1> ;   add di,COLS*4    ; one row down
   655                              <1> ;   mov ah,0
   656                              <1> ;   mov al,bl
   657                              <1> ;   times 2 shl ax,1
   658                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   659                              <1> ;   pop cx
   660                              <1> ;   loop .rows_loop
   661                              <1> ;   pop di
   662                              <1> ;   pop bx
   663                              <1> ;   ret
   664                              <1> 
   665                              <1> ; ───────────────────────────────────────────────────────────────────────────
   666                              <1> 
   667                              <1> ; fill_rect_black: 
   668                              <1> ;   mov ax,RED
   669                              <1> ;   call clear_area
   670                              <1> ;   mov ax,GREEN
   671                              <1> ;   call clear_area
   672                              <1> ;   mov ax,BLUE
   673                              <1> ;   call clear_area
   674                              <1> ;   ret
   675                              <1> 
   676                              <1> ; ───────────────────────────────────────────────────────────────────────────
   677                              <1> 
   678                              <1> draw_spr:
   679 000001FB 8B1C                <1>   mov bx,[si]
   680 000001FD 46<rep 2h>          <1>   times 2 inc si
   681                              <1> draw_pic:
   682 000001FF B800F0              <1>   mov ax, RED
   683 00000202 E80D00              <1>   call draw_channel
   684 00000205 B8001C              <1>   mov ax, GREEN
   685 00000208 E80700              <1>   call draw_channel
   686 0000020B B800F4              <1>   mov ax, BLUE
   687 0000020E E80100              <1>   call draw_channel
   688 00000211 C3                  <1>   ret
   689                              <1> 
   690                              <1> ; ───────────────────────────────────────────────────────────────────────────
   691                              <1> 
   692                              <1> draw_channel:
   693 00000212 57                  <1>   push di
   694 00000213 8EC0                <1>   mov es,ax
   695 00000215 31C9                <1>   xor cx,cx
   696 00000217 88F9                <1>   mov cl,bh        ; rows (bl)
   697                              <1> .rows_loop:
   698 00000219 51                  <1>   push cx
   699 0000021A 31C9                <1>   xor cx,cx
   700 0000021C 88D9                <1>   mov cl,bl        ; cols (bh)
   701                              <1> .cols_loop:
   702 0000021E A5                  <1>   movsw
   703 0000021F A5                  <1>   movsw
   704 00000220 E2FC                <1>   loop .cols_loop
   705 00000222 81C72001            <1>   add di,COLS*4    ; one row down
   706 00000226 B400                <1>   mov ah,0
   707 00000228 88D8                <1>   mov al,bl
   708 0000022A D1E0<rep 2h>        <1>   times 2 shl ax,1
   709 0000022E 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   710 00000230 59                  <1>   pop cx
   711 00000231 E2E6                <1>   loop .rows_loop
   712 00000233 5F                  <1>   pop di
   713 00000234 C3                  <1>   ret
   714                              <1> 
   715                              <1> ; ───────────────────────────────────────────────────────────────────────────
   716                              <1> 
   717                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   718 00000235 B89000              <1>   mov ax,144      ; 2*72 cols
   719 00000238 F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   720 0000023A D1E0                <1>   shl ax,1        ; verdubbel AX
   721 0000023C 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   722 0000023E D0E3                <1>   shl bl,1        ; bl*=2
   723 00000240 D0E3                <1>   shl bl,1        ; bl*=2
   724 00000242 B700                <1>   mov bh,0
   725 00000244 01DF                <1>   add di,bx       ; di+=bl
   726 00000246 C3                  <1>   ret
   727                              <1> 
   728                              <1> ; ───────────────────────────────────────────────────────────────────────────
   729                              <1> 
   730                              <1> new_line:
   731 00000247 50                  <1>   push ax
   732 00000248 53                  <1>   push bx
   733 00000249 52                  <1>   push dx
   734 0000024A BB2001              <1>   mov bx,288
   735 0000024D 31D2                <1>   xor dx,dx
   736 0000024F 89F8                <1>   mov ax,di
   737 00000251 F7F3                <1>   div bx
   738 00000253 31D2                <1>   xor dx,dx
   739 00000255 BB2001              <1>   mov bx,288
   740 00000258 40                  <1>   inc ax
   741 00000259 F7E3                <1>   mul bx
   742 0000025B 052001              <1>   add ax,288
   743 0000025E 89C7                <1>   mov di,ax
   744 00000260 5A                  <1>   pop dx
   745 00000261 5B                  <1>   pop bx
   746 00000262 58                  <1>   pop ax
   747 00000263 C3                  <1>   ret
   748                              <1> 
   749                              <1> 
   750                              <1> ; calc_di_from_cursor:  ; input cursor, output di
   751                              <1> ;   mov ax,[cursor] 
   752                              <1> ;   sub ax,0x0101   ; cursor is 1 based
   753                              <1> ;   xchg ax,bx      ; bx=ax
   754                              <1> ;   mov ax,144      ; 2*72 cols
   755                              <1> ;   mul bh          ; bh*=144 resultaat in AX
   756                              <1> ;   shl ax,1        ; verdubbel AX
   757                              <1> ;   shl ax,1        ; verdubbel AX
   758                              <1> ;   mov di,ax       ; di=ax (=bh*288)
   759                              <1> ;   shl bl,1        ; bl*=2
   760                              <1> ;   shl bl,1        ; bl*=2
   761                              <1> ;   mov bh,0
   762                              <1> ;   add di,bx       ; di+=bl
   763                              <1> ;   ret
   764                              <1> 
   765                              <1> 
   766                              <1> 
   767                              <1> 
   768                              <1> ; als je cursor gebruikt is dit missch niet nodig.
   769                              <1> ; row_snap:  ; this code detects if DI is in between rows. When DI goes to the next half row it converts it to a whole row.
   770                              <1> ;   push ax
   771                              <1> ;   push bx
   772                              <1> ;   push dx
   773                              <1> ;   mov bx,288
   774                              <1> ;   mov ax,di
   775                              <1> ;   cwd ; xor dx,dx
   776                              <1> ;   div bx
   777                              <1> ;   jnp .done  ; if ax%288==0 
   778                              <1> ;   add di,bx
   779                              <1> ;   .done
   780                              <1> ;   ; add di,dx
   781                              <1> ;   pop dx
   782                              <1> ;   pop bx
   783                              <1> ;   pop ax
   784                              <1> ;   ret
   785                              <1> 
   786                              <1> 
   787                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   788                              <1> 
   789                              <1> ; calc_di_from_cursor_index:  ; index is cursor index from 0 tot 72*25
   790                              <1> ;   push ax
   791                              <1> ;   push bx
   792                              <1> ;   push dx
   793                              <1> ;   xor dx,dx
   794                              <1> ;   mov ax,[cursor.index]
   795                              <1> ;   mov bx,72
   796                              <1> ;   div bx       ; ax=rows
   797                              <1> ;   push dx      ; dx=cols
   798                              <1> ;   xor dx,dx    ; clear dx for multiplication
   799                              <1> ;   mov bx,576
   800                              <1> ;   mul bx       ; ax contains DI position for row
   801                              <1> ;   mov di,ax
   802                              <1> ;   pop ax       ; ax now contains cols
   803                              <1> ;   shl ax,1     ; *=2
   804                              <1> ;   shl ax,1     ; *=2
   805                              <1> ;   add di,ax
   806                              <1> ;   pop dx
   807                              <1> ;   pop bx
   808                              <1> ;   pop ax
   809                              <1> ;   ret
   810                              <1> 
   811                              <1> ; ───────────────────────────────────────────────────────────────────────────
   812                              <1> 
   813                              <1> 
   814                              <1> ; set_cursor:
   815                              <1> ; cursor_next_char
   816                              <1> 
   817                              <1> 
   818                              <1> 
   819                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   820                              <1> 
     2                                  %include "vector.asm"
     1                              <1> %include "atan.asm"
     1                              <2> atan2: ; input bx=y, ax=x
     2 00000264 83F800              <2>   cmp ax,0
     3 00000267 750F                <2>   jnz .x_not_0
     4 00000269 83FB00              <2>   cmp bx,0
     5 0000026C 7C05                <2>   jl .y_lte_0
     6 0000026E B85A00              <2>   mov ax,90
     7 00000271 EB2D                <2>   jmp .ret
     8                              <2> 
     9                              <2> .y_lte_0:
    10 00000273 B8A6FF              <2>   mov ax,-90
    11 00000276 EB28                <2>   jmp .ret
    12                              <2> 
    13                              <2> .x_not_0:
    14 00000278 50                  <2>   push ax
    15 00000279 50                  <2>   push ax   ; keep a copy of x
    16 0000027A 89D8                <2>   mov ax,bx
    17 0000027C B96F00              <2>   mov cx,111
    18 0000027F 99                  <2>   cwd       ; dx=0
    19 00000280 F7E9                <2>   imul cx
    20 00000282 59                  <2>   pop cx;   ; restore x
    21 00000283 F7F9                <2>   idiv cx   ; ax/=x
    22 00000285 99                  <2>   cwd
    23 00000286 E82100              <2>   call atan
    24 00000289 59                  <2>   pop cx;   ; restore x
    25 0000028A 83F900              <2>   cmp cx,0
    26 0000028D 7C02                <2>   jl .x_lt_0
    27 0000028F EB0F                <2>   jmp .ret
    28                              <2> 
    29                              <2> .x_lt_0:
    30 00000291 83FB00              <2>   cmp bx,0
    31 00000294 7D05                <2>   jge .y_gte_0
    32 00000296 2DB400              <2>   sub ax,180
    33 00000299 EB05                <2>   jmp .ret
    34                              <2> 
    35                              <2> .y_gte_0:
    36 0000029B 05B400              <2>   add ax,180
    37 0000029E EB00                <2>   jmp .ret
    38                              <2> 
    39                              <2> .ret:
    40 000002A0 83F800              <2>   cmp ax,0
    41 000002A3 7C01                <2>   jl .add360
    42 000002A5 C3                  <2>   ret
    43                              <2> .add360:
    44 000002A6 056801              <2>   add ax,360
    45 000002A9 C3                  <2>   ret
    46                              <2> 
    47                              <2> ; ───────────────────────────────────────────────────────────────────────────
    48                              <2> 
    49                              <2> atan: ; cx=z, return value in ax, bx destroyed, cx destroyed, dx destroyed
    50 000002AA 89C1                <2>   mov cx,ax           ; z
    51 000002AC 99                  <2>   cwd
    52 000002AD 83F96F              <2>   cmp cx,111
    53 000002B0 7F29                <2>   jg .z_gt_scale      ; if (z>111)
    54 000002B2 83F991              <2>   cmp cx,-111         ; if (z<-111) 
    55 000002B5 7C34                <2>   jl .z_lt_minus_scale
    56 000002B7 99                  <2>   cwd
    57 000002B8 F7E8                <2>   imul ax             ; ax *= ax  (z*z)
    58 000002BA BB4D01              <2>   mov bx,333     
    59 000002BD F7FB                <2>   idiv bx             ; ax /= 333   Taylor-benadering
    60 000002BF 99                  <2>   cwd
    61 000002C0 89C3                <2>   mov bx,ax
    62 000002C2 B86F00              <2>   mov ax,111
    63 000002C5 29D8                <2>   sub ax,bx           ; ax-=111  
    64 000002C7 BBB400              <2>   mov bx,180
    65 000002CA F7EB                <2>   imul bx             ; ax*=180 
    66 000002CC F7E9                <2>   imul cx             ; ax*=z
    67 000002CE BB6F00              <2>   mov bx,111
    68 000002D1 F7FB                <2>   idiv bx             ; ax/=111
    69 000002D3 BB3A01              <2>   mov bx,314
    70 000002D6 99                  <2>   cwd
    71 000002D7 F7FB                <2>   idiv bx             ; ax/=314
    72 000002D9 99                  <2>   cwd
    73 000002DA C3                  <2>   ret
    74                              <2> 
    75                              <2> .z_gt_scale:
    76 000002DB B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
    77 000002DE F7F9                <2>   idiv cx             ; ax/=z
    78 000002E0 E8C7FF              <2>   call atan           ; recursion
    79 000002E3 89C3                <2>   mov bx,ax
    80 000002E5 B85A00              <2>   mov ax,90
    81 000002E8 29D8                <2>   sub ax,bx
    82 000002EA C3                  <2>   ret
    83                              <2> 
    84                              <2> .z_lt_minus_scale:
    85 000002EB B82130              <2>   mov ax,12321        ; 12321 = 111*111 (squared scale)
    86 000002EE F7F9                <2>   idiv cx             ; ax/=z
    87 000002F0 E8B7FF              <2>   call atan           ; recursion
    88 000002F3 89C3                <2>   mov bx,ax
    89 000002F5 B8A6FF              <2>   mov ax,-90
    90 000002F8 29D8                <2>   sub ax,bx
    91 000002FA C3                  <2>   ret
    92                              <2> 
    93                              <2> %macro _atan2 2
    94                              <2>   mov ax,%1
    95                              <2>   mov bx,%2
    96                              <2>   call __atan2
    97                              <2> %endmacro
    98                              <2> 
    99                              <2> __atan2:
   100 000002FB 50                  <2>   push ax
   101 000002FC 53                  <2>   push bx
   102                              <2>   print "atan2(x="
    48 000002FD 50                  <3>  push ax
    49 000002FE 53                  <3>  push bx
    50 000002FF 51                  <3>  push cx
    51 00000300 52                  <3>  push dx
    52 00000301 EB09                <3>  jmp %%endstr
    53 00000303 6174616E3228783D00  <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 0000030C BB[0303]            <3>  mov bx,%%str
    56 0000030F E854FE              <3>  call write_string
    57 00000312 5A                  <3>  pop dx
    58 00000313 59                  <3>  pop cx
    59 00000314 5B                  <3>  pop bx
    60 00000315 58                  <3>  pop ax
   103 00000316 E8AEFE              <2>   call write_signed_number_word
   104                              <2>   print ",y="
    48 00000319 50                  <3>  push ax
    49 0000031A 53                  <3>  push bx
    50 0000031B 51                  <3>  push cx
    51 0000031C 52                  <3>  push dx
    52 0000031D EB04                <3>  jmp %%endstr
    53 0000031F 2C793D00            <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 00000323 BB[1F03]            <3>  mov bx,%%str
    56 00000326 E83DFE              <3>  call write_string
    57 00000329 5A                  <3>  pop dx
    58 0000032A 59                  <3>  pop cx
    59 0000032B 5B                  <3>  pop bx
    60 0000032C 58                  <3>  pop ax
   105 0000032D 58                  <2>   pop ax
   106 0000032E 53                  <2>   push bx
   107 0000032F E895FE              <2>   call write_signed_number_word
   108                              <2>   print ")="
    48 00000332 50                  <3>  push ax
    49 00000333 53                  <3>  push bx
    50 00000334 51                  <3>  push cx
    51 00000335 52                  <3>  push dx
    52 00000336 EB03                <3>  jmp %%endstr
    53 00000338 293D00              <3>  %%str: db %1,0
    54                              <3>  %%endstr:
    55 0000033B BB[3803]            <3>  mov bx,%%str
    56 0000033E E825FE              <3>  call write_string
    57 00000341 5A                  <3>  pop dx
    58 00000342 59                  <3>  pop cx
    59 00000343 5B                  <3>  pop bx
    60 00000344 58                  <3>  pop ax
   109 00000345 5B                  <2>   pop bx
   110 00000346 58                  <2>   pop ax
   111 00000347 E81AFF              <2>   call atan2
   112 0000034A E87AFE              <2>   call write_signed_number_word
   113 0000034D B020                <2>   mov al,' '
   114 0000034F E8D9FD              <2>   call write_char
   115 00000352 E8F2FE              <2>   call new_line
   116 00000355 C3                  <2>   ret
   117                              <2> 
   118                              <2> 
     2                              <1> 
     3                              <1> v_mult:  ; bx contains address of 4 bytes vector  such as 'ship.vel', cx contains scaler such as 94 (*=.94)
     4                              <1>   ; x-axis
     5 00000356 51                  <1>   push cx      ; put extra scaler on the stack for second axis
     6 00000357 8B07                <1>   mov ax,[bx]
     7 00000359 99                  <1>   cwd
     8 0000035A F7E9                <1>   imul cx      ; ax*=94
     9 0000035C B96400              <1>   mov cx, 100
    10 0000035F F7F9                <1>   idiv cx      ; ax/=100
    11 00000361 8907                <1>   mov [bx],ax
    12 00000363 59                  <1>   pop cx       ; restore scaler from stack for second axis
    13                              <1> 
    14                              <1>   ;y-axis
    15 00000364 8B4702              <1>   mov ax,[bx+2]
    16 00000367 99                  <1>   cwd
    17 00000368 F7E9                <1>   imul cx      ; ax*=94
    18 0000036A B96400              <1>   mov cx, 100
    19 0000036D F7F9                <1>   idiv cx      ; ax/=100
    20 0000036F 894702              <1>   mov [bx+2],ax
    21 00000372 C3                  <1>   ret
    22                              <1> 
    23                              <1> v_add: ; bx contains address of 4 bytes vector such as 'ship.pos', bp contains address of other 4 bytes vector
    24                              <1>   ; x+=vx
    25 00000373 8B07                <1>   mov ax,[bx]
    26 00000375 034600              <1>   add ax,[bp]
    27 00000378 8907                <1>   mov [bx],ax
    28                              <1>   ; y+=vy
    29 0000037A 8B4702              <1>   mov ax,[bx+2]
    30 0000037D 034602              <1>   add ax,[bp+2]
    31 00000380 894702              <1>   mov [bx+2],ax
    32 00000383 C3                  <1>   ret
    33                              <1> 
    34                              <1> v_sub:
    35                              <1>   ; ...
    36 00000384 C3                  <1>   ret
    37                              <1> 
    38                              <1> v_heading: ; bx contains address of 4 bytes vector
    39 00000385 8B07                <1>   mov ax,[bx]
    40 00000387 8B5F02              <1>   mov bx,[bx+2]
    41 0000038A E8D7FE              <1>   call atan2
    42 0000038D C3                  <1>   ret
    43                              <1> 
    44                              <1> v_from_angle:
    45                              <1>   ; ....
    46                              <1>   ; angle = (angle + 360) % 360;
    47                              <1> 
    48                              <1>   ;   int q = angle / 90;
    49                              <1>   ;   int r = angle % 90;
    50                              <1> 
    51                              <1>   ;   int c = (100 * (90 - r) + 45) / 9;  //cos
    52                              <1>   ;   int s = (100 * r + 45) / 9;         //sin
    53                              <1> 
    54                              <1>   ;   int x = c;
    55                              <1>   ;   int y = s;
    56                              <1> 
    57                              <1>   ;   if (q==1) {
    58                              <1>   ;     x = -s;
    59                              <1>   ;     y = c;
    60                              <1>   ;   } else if (q==2) {
    61                              <1>   ;     x = -x;
    62                              <1>   ;     y = -y;
    63                              <1>   ;   } else if (q==3) {
    64                              <1>   ;     x = s;
    65                              <1>   ;     y = -c;
    66                              <1>   ;   }
    67                              <1> 
    68                              <1>   ;   return new Vec(x*mag, y*mag);
    69 0000038E C3                  <1>   ret
    70                              <1> 
    71                              <1> v_limit: ; bx contains address of 4 bytes vector, cx contains max_length. updates bx
    72 0000038F 89C8                <1>   mov ax,cx
    73 00000391 F7E1                <1>   mul cx
    74 00000393 91                  <1>   xchg ax,cx   ; cx now contains max*max
    75 00000394 8B07                <1>   mov ax,[bx]
    76 00000396 E80B00              <1>   call v_mag_sq
    77 00000399 39C8                <1>   cmp ax,cx
    78 0000039B 7E06                <1>   jle .ret
    79 0000039D B95F00              <1>   mov cx,95
    80 000003A0 E8B3FF              <1>   call v_mult
    81                              <1>   ; void limit(int max) {
    82                              <1>   ;   while (magSq() > max*max) mult(95);
    83                              <1>   ; }
    84                              <1> .ret:
    85 000003A3 C3                  <1>   ret
    86                              <1> 
    87                              <1> v_mag_sq:   ; bx contains address of 4 bytes vector, returns ax
    88 000003A4 8B07                <1>   mov ax,[bx]
    89 000003A6 F7E0                <1>   mul ax
    90 000003A8 C3                  <1>   ret
    91                              <1> 
    92                              <1> ; Vec copy() {  copy bx vector into bp ?
    93                              <1> ;     return new Vec(x, y);
    94                              <1> ;   }
    95                              <1> 
    96                              <1> 
     3                                  
     4                                  ship:
     5                                   .pos:
     6 000003A9 0090                     .pos.x: dw 73728/2                ; 0..73728  (65536)
     7 000003AB D06B                     .pos.y: dw 51200/2 + 2000         ; 0..51200  (=1024*50)
     8                                   .vel: 
     9 000003AD 6000                     .vel.x: dw 96
    10 000003AF 0000                     .vel.y: dw 0
    11 000003B1 0000                     .vel.flags: dw 0
    12                                   .acc:
    13 000003B3 0000                     .acc.x: dw 0
    14 000003B5 0000                     .acc.y: dw 0
    15                                   .forces:
    16 000003B7 0000                     .forces.x: dw 0
    17 000003B9 0000                     .forces.y: dw 0
    18 000003BB 0000                     .angle: dw 0
    19 000003BD 0000                     .sprite_index: dw 0
    20 000003BF [E608]                   .img_addr: dw img_first
    21 000003C1 0000                     .prev_di: dw 0
    22                                  
    23 000003C3 02                      color: db Color.G
    24                                  FRICTION equ 94
    25                                  STEP equ 500
    26                                  
    27                                  setup:
    28 000003C4 31ED                      xor bp,bp
    29 000003C6 EB6E                      jmp draw
    30                                  
    31                                  ; ───────────────────────────────────────────────────────────────────────────
    32                                  
    33                                  update_ship:
    34 000003C8 BB[AD03]                  mov bx,ship.vel    ; pointer to ship velocity
    35 000003CB B95E00                    mov cx,94
    36 000003CE E885FF                    call v_mult
    37                                  
    38 000003D1 BB[A903]                  mov bx,ship.pos
    39 000003D4 BD[AD03]                  mov bp,ship.vel
    40 000003D7 E899FF                    call v_add
    41                                    
    42 000003DA BB[AD03]                  mov bx,ship.vel
    43 000003DD E8A5FF                    call v_heading   ; returns angle in ax
    44 000003E0 A3[BB03]                  mov [ship.angle],ax
    45                                  
    46                                    ; from angle to ship image frame address
    47 000003E3 31D2                      xor dx,dx
    48 000003E5 BB0F00                    mov bx,15
    49 000003E8 F7FB                      idiv bx
    50 000003EA A3[BD03]                  mov [ship.sprite_index],ax  ; sprite_index = angle/15 = 0..23
    51 000003ED BB0203                    mov bx,770
    52 000003F0 F7E3                      mul bx
    53 000003F2 05[E608]                  add ax,img_first
    54 000003F5 A3[BF03]                  mov [ship.img_addr],ax
    55                                  
    56 000003F8 C3                        ret
    57                                  
    58                                  ; ───────────────────────────────────────────────────────────────────────────
    59                                  
    60                                  draw_ship:
    61 000003F9 A1[A903]                  mov ax,[ship.pos.x]
    62 000003FC 8B1E[AB03]                mov bx,[ship.pos.y]
    63 00000400 E8D601                    call world2screen
    64 00000403 E82FFE                    call calc_di_from_bx
    65                                  
    66 00000406 393E[C103]                cmp [ship.prev_di],di  
    67 0000040A 7429                      je .return             ; no screen update needed
    68                                  
    69 0000040C 8B3E[C103]                mov di,[ship.prev_di]
    70                                    
    71                                    ; mov bx,0x0808  ; rows,cols
    72                                    ; call fill_rect_black
    73                                  
    74 00000410 A1[A903]                  mov ax,[ship.pos.x]
    75 00000413 8B1E[AB03]                mov bx,[ship.pos.y]
    76 00000417 E8BF01                    call world2screen
    77 0000041A E818FE                    call calc_di_from_bx
    78 0000041D 893E[C103]                mov [ship.prev_di],di
    79                                  
    80 00000421 8B36[BF03]                mov si,[ship.img_addr]
    81 00000425 A1[A903]                  mov ax,[ship.pos.x]
    82 00000428 8B1E[AB03]                mov bx,[ship.pos.y]
    83 0000042C E8AA01                    call world2screen ; ax and bx are already set by pop bx, pop ax
    84 0000042F E803FE                    call calc_di_from_bx
    85 00000432 E8C6FD                    call draw_spr
    86                                  
    87                                  .return
    88 00000435 C3                        ret
    89                                  
    90                                  ; ───────────────────────────────────────────────────────────────────────────
    91                                  
    92                                  draw:
    93 00000436 0E                        push cs
    94 00000437 1F                        pop ds   ; make sure DS is set to CS for data lookups like [ship.pos.x]
    95                                  
    96 00000438 E88DFF                    call update_ship
    97 0000043B E8BBFF                    call draw_ship
    98 0000043E E80E00                    call draw_debug_info
    99                                  
   100 00000441 E897FD                    call check_keys
   101 00000444 7403E94101                jnz on_key
   102                                    ;else
   103                                  
   104 00000449 E88501                    call _wait
   105 0000044C 45                        inc bp
   106                                  
   107 0000044D EBE7                      jmp draw          ; this code is only getting called when no key is pressed
   108                                  
   109                                  ; ───────────────────────────────────────────────────────────────────────────
   110                                  
   111                                  draw_debug_info:
   112                                    set_cursor 12,45
    43                              <1> 
    44 0000044F BF7019              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   113                                    print "frame: "
    48 00000452 50                  <1>  push ax
    49 00000453 53                  <1>  push bx
    50 00000454 51                  <1>  push cx
    51 00000455 52                  <1>  push dx
    52 00000456 EB08                <1>  jmp %%endstr
    53 00000458 6672616D653A2000    <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000460 BB[5804]            <1>  mov bx,%%str
    56 00000463 E800FD              <1>  call write_string
    57 00000466 5A                  <1>  pop dx
    58 00000467 59                  <1>  pop cx
    59 00000468 5B                  <1>  pop bx
    60 00000469 58                  <1>  pop ax
   114 0000046A 89E8                      mov ax,bp
   115 0000046C E833FD                    call write_number_word     ; draw frame counter
   116                                    print "  "
    48 0000046F 50                  <1>  push ax
    49 00000470 53                  <1>  push bx
    50 00000471 51                  <1>  push cx
    51 00000472 52                  <1>  push dx
    52 00000473 EB03                <1>  jmp %%endstr
    53 00000475 202000              <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000478 BB[7504]            <1>  mov bx,%%str
    56 0000047B E8E8FC              <1>  call write_string
    57 0000047E 5A                  <1>  pop dx
    58 0000047F 59                  <1>  pop cx
    59 00000480 5B                  <1>  pop bx
    60 00000481 58                  <1>  pop ax
   117                                  
   118                                    set_cursor 13,45
    43                              <1> 
    44 00000482 BFB01B              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   119                                    print "vx: "
    48 00000485 50                  <1>  push ax
    49 00000486 53                  <1>  push bx
    50 00000487 51                  <1>  push cx
    51 00000488 52                  <1>  push dx
    52 00000489 EB05                <1>  jmp %%endstr
    53 0000048B 76783A2000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000490 BB[8B04]            <1>  mov bx,%%str
    56 00000493 E8D0FC              <1>  call write_string
    57 00000496 5A                  <1>  pop dx
    58 00000497 59                  <1>  pop cx
    59 00000498 5B                  <1>  pop bx
    60 00000499 58                  <1>  pop ax
   120 0000049A A1[AD03]                  mov ax,[ship.vel.x]  
   121 0000049D E827FD                    call write_signed_number_word
   122                                    print "  "
    48 000004A0 50                  <1>  push ax
    49 000004A1 53                  <1>  push bx
    50 000004A2 51                  <1>  push cx
    51 000004A3 52                  <1>  push dx
    52 000004A4 EB03                <1>  jmp %%endstr
    53 000004A6 202000              <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 000004A9 BB[A604]            <1>  mov bx,%%str
    56 000004AC E8B7FC              <1>  call write_string
    57 000004AF 5A                  <1>  pop dx
    58 000004B0 59                  <1>  pop cx
    59 000004B1 5B                  <1>  pop bx
    60 000004B2 58                  <1>  pop ax
   123                                  
   124                                    set_cursor 14,45
    43                              <1> 
    44 000004B3 BFF01D              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   125                                    print "vy: "
    48 000004B6 50                  <1>  push ax
    49 000004B7 53                  <1>  push bx
    50 000004B8 51                  <1>  push cx
    51 000004B9 52                  <1>  push dx
    52 000004BA EB05                <1>  jmp %%endstr
    53 000004BC 76793A2000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 000004C1 BB[BC04]            <1>  mov bx,%%str
    56 000004C4 E89FFC              <1>  call write_string
    57 000004C7 5A                  <1>  pop dx
    58 000004C8 59                  <1>  pop cx
    59 000004C9 5B                  <1>  pop bx
    60 000004CA 58                  <1>  pop ax
   126 000004CB A1[AF03]                  mov ax,[ship.vel.y]
   127 000004CE E8F6FC                    call write_signed_number_word     ; draw vy
   128                                    print "  "
    48 000004D1 50                  <1>  push ax
    49 000004D2 53                  <1>  push bx
    50 000004D3 51                  <1>  push cx
    51 000004D4 52                  <1>  push dx
    52 000004D5 EB03                <1>  jmp %%endstr
    53 000004D7 202000              <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 000004DA BB[D704]            <1>  mov bx,%%str
    56 000004DD E886FC              <1>  call write_string
    57 000004E0 5A                  <1>  pop dx
    58 000004E1 59                  <1>  pop cx
    59 000004E2 5B                  <1>  pop bx
    60 000004E3 58                  <1>  pop ax
   129                                  
   130                                    set_cursor 15,45
    43                              <1> 
    44 000004E4 BF3020              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   131                                    print "angle: "
    48 000004E7 50                  <1>  push ax
    49 000004E8 53                  <1>  push bx
    50 000004E9 51                  <1>  push cx
    51 000004EA 52                  <1>  push dx
    52 000004EB EB08                <1>  jmp %%endstr
    53 000004ED 616E676C653A2000    <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 000004F5 BB[ED04]            <1>  mov bx,%%str
    56 000004F8 E86BFC              <1>  call write_string
    57 000004FB 5A                  <1>  pop dx
    58 000004FC 59                  <1>  pop cx
    59 000004FD 5B                  <1>  pop bx
    60 000004FE 58                  <1>  pop ax
   132 000004FF A1[BB03]                  mov ax,[ship.angle]  ; # handig om angle van 0 tot 360 te laten lopen ipv -180...180  
   133 00000502 E8C2FC                    call write_signed_number_word     ; draw frame counter
   134                                    print "    "
    48 00000505 50                  <1>  push ax
    49 00000506 53                  <1>  push bx
    50 00000507 51                  <1>  push cx
    51 00000508 52                  <1>  push dx
    52 00000509 EB05                <1>  jmp %%endstr
    53 0000050B 2020202000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000510 BB[0B05]            <1>  mov bx,%%str
    56 00000513 E850FC              <1>  call write_string
    57 00000516 5A                  <1>  pop dx
    58 00000517 59                  <1>  pop cx
    59 00000518 5B                  <1>  pop bx
    60 00000519 58                  <1>  pop ax
   135                                  
   136                                    set_cursor 16,45
    43                              <1> 
    44 0000051A BF7022              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   137                                    print "index: "
    48 0000051D 50                  <1>  push ax
    49 0000051E 53                  <1>  push bx
    50 0000051F 51                  <1>  push cx
    51 00000520 52                  <1>  push dx
    52 00000521 EB08                <1>  jmp %%endstr
    53 00000523 696E6465783A2000    <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 0000052B BB[2305]            <1>  mov bx,%%str
    56 0000052E E835FC              <1>  call write_string
    57 00000531 5A                  <1>  pop dx
    58 00000532 59                  <1>  pop cx
    59 00000533 5B                  <1>  pop bx
    60 00000534 58                  <1>  pop ax
   138 00000535 A1[BD03]                  mov ax,[ship.sprite_index]  ; # handig om angle van 0 tot 360 te laten lopen ipv -180...180  
   139 00000538 E88CFC                    call write_signed_number_word     ; draw frame counter
   140                                    print "    "
    48 0000053B 50                  <1>  push ax
    49 0000053C 53                  <1>  push bx
    50 0000053D 51                  <1>  push cx
    51 0000053E 52                  <1>  push dx
    52 0000053F EB05                <1>  jmp %%endstr
    53 00000541 2020202000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 00000546 BB[4105]            <1>  mov bx,%%str
    56 00000549 E81AFC              <1>  call write_string
    57 0000054C 5A                  <1>  pop dx
    58 0000054D 59                  <1>  pop cx
    59 0000054E 5B                  <1>  pop bx
    60 0000054F 58                  <1>  pop ax
   141                                  
   142                                    set_cursor 17,45
    43                              <1> 
    44 00000550 BFB024              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   143                                    print "img addr: "
    48 00000553 50                  <1>  push ax
    49 00000554 53                  <1>  push bx
    50 00000555 51                  <1>  push cx
    51 00000556 52                  <1>  push dx
    52 00000557 EB0B                <1>  jmp %%endstr
    53 00000559 696D6720616464723A- <1>  %%str: db %1,0
    53 00000562 2000                <1>
    54                              <1>  %%endstr:
    55 00000564 BB[5905]            <1>  mov bx,%%str
    56 00000567 E8FCFB              <1>  call write_string
    57 0000056A 5A                  <1>  pop dx
    58 0000056B 59                  <1>  pop cx
    59 0000056C 5B                  <1>  pop bx
    60 0000056D 58                  <1>  pop ax
   144 0000056E A1[BF03]                  mov ax,[ship.img_addr]
   145 00000571 E853FC                    call write_signed_number_word     ; draw frame counter
   146                                    print "    "
    48 00000574 50                  <1>  push ax
    49 00000575 53                  <1>  push bx
    50 00000576 51                  <1>  push cx
    51 00000577 52                  <1>  push dx
    52 00000578 EB05                <1>  jmp %%endstr
    53 0000057A 2020202000          <1>  %%str: db %1,0
    54                              <1>  %%endstr:
    55 0000057F BB[7A05]            <1>  mov bx,%%str
    56 00000582 E8E1FB              <1>  call write_string
    57 00000585 5A                  <1>  pop dx
    58 00000586 59                  <1>  pop cx
    59 00000587 5B                  <1>  pop bx
    60 00000588 58                  <1>  pop ax
   147                                  
   148 00000589 C3                        ret
   149                                  
   150                                  ; ───────────────────────────────────────────────────────────────────────────
   151                                  
   152                                  
   153                                  on_key:
   154                                    set_cursor 2,10
    43                              <1> 
    44 0000058A BF6402              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   155 0000058D A1[0400]                  mov ax,[key]
   156 00000590 E8F7FB                    call write_binary_word
   157 00000593 83F877                    cmp ax,'w'
   158 00000596 7412                      je on_key_w
   159 00000598 83F861                    cmp ax,'a'
   160 0000059B 7415                      je on_key_a
   161 0000059D 83F873                    cmp ax,'s'
   162 000005A0 7418                      je on_key_s
   163 000005A2 83F864                    cmp ax,'d'
   164 000005A5 741B                      je on_key_d
   165                                  .done
   166 000005A7 E98CFE                    jmp draw  ; no ret here because onkey is called by jnz
   167                                  
   168                                  ; ───────────────────────────────────────────────────────────────────────────
   169                                  
   170                                  on_key_w:
   171 000005AA 812E[AF03]F401            sub word [ship.vel.y], STEP
   172 000005B0 EBF5                      jmp on_key.done
   173                                  
   174                                  ; ───────────────────────────────────────────────────────────────────────────
   175                                  
   176                                  on_key_a:
   177 000005B2 812E[AD03]F401            sub word [ship.vel.x], STEP
   178 000005B8 EBED                      jmp on_key.done
   179                                  
   180                                  ; ───────────────────────────────────────────────────────────────────────────
   181                                  
   182                                  on_key_s:
   183 000005BA 8106[AF03]F401            add word [ship.vel.y], STEP
   184 000005C0 EBE5                      jmp on_key.done
   185                                  
   186                                  ; ───────────────────────────────────────────────────────────────────────────
   187                                  
   188                                  on_key_d:
   189 000005C2 8106[AD03]F401            add word [ship.vel.x], STEP
   190 000005C8 EBDD                      jmp on_key.done
   191                                  
   192                                  ; ───────────────────────────────────────────────────────────────────────────
   193                                  
   194                                  print_msg:
   195                                    set_cursor 1,10
    43                              <1> 
    44 000005CA BF2400              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   196 000005CD E896FB                    call write_string
   197 000005D0 C3                        ret
   198                                  
   199                                  ; ───────────────────────────────────────────────────────────────────────────
   200                                  
   201                                  _wait:
   202                                    DELAY EQU 250
   203 000005D1 B9FA00                    mov cx,DELAY
   204 000005D4 D40A                      .lp aam
   205 000005D6 E2FC                      loop .lp
   206 000005D8 C3                        ret
   207                                  
   208                                  ; ───────────────────────────────────────────────────────────────────────────
   209                                  
   210                                  world2screen:  ; input (ax,bx) = (world.x, world.y)   ; screen (row,col)
   211                                    ; WORLD:
   212                                    ;   0..73728  (65536) -> col
   213                                    ;   0..51200  (=1024*50) -> row
   214                                    ; SCREEN (ROW,COL):
   215                                    ;   0..49 (row)
   216                                    ;   0..71 (col)
   217 000005D9 B10A                      mov cl,10
   218 000005DB D3EB                      shr bx,cl   ; //bl=row 0..49
   219 000005DD D3E8                      shr ax,cl   ; 
   220 000005DF 88C7                      mov bh,al   ; //bh=col 0..71
   221 000005E1 86DF                      xchg bh,bl
   222 000005E3 C3                        ret
   223                                  
   224                                  ; ───────────────────────────────────────────────────────────────────────────
   225                                  
   226                                  ; FIXME
   227 000005E4 <bin 302h>              img_NONE: incbin "data/ship-24.spr"
   228                                  
   229                                  img_first:
   230                                  img_right:
   231 000008E6 <bin 302h>              img7: incbin "data/ship-7.spr" ;right
   232 00000BE8 <bin 302h>              img8: incbin "data/ship-8.spr"
   233 00000EEA <bin 302h>              img9: incbin "data/ship-9.spr"
   234                                  img_down_right:
   235 000011EC <bin 302h>              img10: incbin "data/ship-10.spr" ;down-right
   236 000014EE <bin 302h>              img11: incbin "data/ship-11.spr"
   237 000017F0 <bin 302h>              img12: incbin "data/ship-12.spr"
   238                                  img_down:
   239 00001AF2 <bin 302h>              img13: incbin "data/ship-13.spr" ;down
   240 00001DF4 <bin 302h>              img14: incbin "data/ship-14.spr"
   241 000020F6 <bin 302h>              img15: incbin "data/ship-15.spr"
   242                                  img_down_left:
   243 000023F8 <bin 302h>              img16: incbin "data/ship-16.spr" ;down-left
   244 000026FA <bin 302h>              img17: incbin "data/ship-17.spr"
   245 000029FC <bin 302h>              img18: incbin "data/ship-18.spr"
   246                                  img_left:
   247 00002CFE <bin 302h>              img19: incbin "data/ship-19.spr" ;left
   248 00003000 <bin 302h>              img20: incbin "data/ship-20.spr"
   249 00003302 <bin 302h>              img21: incbin "data/ship-21.spr"
   250                                  img_up_left:
   251 00003604 <bin 302h>              img22: incbin "data/ship-22.spr" ;up-left
   252 00003906 <bin 302h>              img23: incbin "data/ship-23.spr"
   253 00003C08 <bin 302h>              img24: incbin "data/ship-24.spr"
   254                                  img_up:
   255 00003F0A <bin 302h>              img1: incbin "data/ship-1.spr" ;up
   256 0000420C <bin 302h>              img2: incbin "data/ship-2.spr"
   257 0000450E <bin 302h>              img3: incbin "data/ship-3.spr"
   258                                  img_up_right:
   259 00004810 <bin 302h>              img4: incbin "data/ship-4.spr" ;up-right
   260 00004B12 <bin 302h>              img5: incbin "data/ship-5.spr"
   261 00004E14 <bin 302h>              img6: incbin "data/ship-6.spr"
   262                                  
   263                                  
   264                                  
   265 00005116 00<rep 27EEAh>          times (180*1024)-($-$$) db 0
   266                                  
   267                                  
   268                                  
