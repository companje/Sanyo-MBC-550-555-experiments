     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 EB04                <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 40          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34                              <1> cursor:
    35 00000002 00                  <1> .col: db 0
    36 00000003 00                  <1> .row: db 0
    37                              <1> 
    38                              <1> key:
    39 00000004 00                  <1>   .code db 0
    40 00000005 00                  <1>   .ctrl db 0
    41                              <1> 
    42                              <1> ; cursor.index: dw 0
    43                              <1> 
    44                              <1> ; %macro set_cursor_row 1
    45                              <1> ;   mov di,%1 * BYTES_PER_ROW
    46                              <1> ; %endmacro
    47                              <1> 
    48                              <1> %macro set_cursor 2
    49                              <1>   ; mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    50                              <1>   mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    51                              <1> %endmacro
    52                              <1> 
    53                              <1> %macro print 1
    54                              <1>   jmp %%endstr 
    55                              <1>   %%str: db %1,0
    56                              <1>   %%endstr: 
    57                              <1>   mov bx,%%str
    58                              <1>   call write_string
    59                              <1> %endmacro
    60                              <1> 
    61                              <1> %macro register_interrupt 2
    62                              <1>   ;DS shoud be 0
    63                              <1>   mov word [%1*4+0],%2
    64                              <1>   mov word [%1*4+2],cs
    65                              <1> %endmacro
    66                              <1> 
    67                              <1> ; int0:; int0: Division by zero
    68                              <1> ;   mov al,0
    69                              <1> ;   jmp int_msg
    70                              <1> ; int1:; int1: Single step debugging
    71                              <1> ;   mov al,1
    72                              <1> ;   jmp int_msg
    73                              <1> ; int2:; int2: Non maskable interrupt
    74                              <1> ;   mov al,2
    75                              <1> ;   jmp int_msg
    76                              <1> ; int3:; int3: For one-byte interrupt
    77                              <1> ;   mov al,3
    78                              <1> ;   jmp int_msg
    79                              <1> ; int4:; int4: Signed overflow
    80                              <1> ;   mov al,4
    81                              <1> ;   jmp int_msg
    82                              <1> ; int_msg:
    83                              <1> ;   xor di,di
    84                              <1> ;   push ax
    85                              <1> ;   print "int"
    86                              <1> ;   pop ax
    87                              <1> ;   add al,'0'
    88                              <1> ;   call write_char
    89                              <1> ;   hlt
    90                              <1> 
    91                              <1> boot:
    92 00000006 FA                  <1>   cli
    93 00000007 FC                  <1>   cld
    94 00000008 E8BF00              <1>   call clear_green    
    95                              <1> 
    96                              <1>   ; init video      
    97 0000000B B005                <1>   mov al, 5
    98 0000000D E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
    99                              <1>  
   100                              <1>   ; register interrupts
   101                              <1>   ; mov ax,0
   102                              <1>   ; mov ds,ax ; segment 0
   103                              <1>   ; register_interrupt 0, int0
   104                              <1>   ; register_interrupt 1, int1
   105                              <1>   ; register_interrupt 2, int2
   106                              <1>   ; register_interrupt 3, int3
   107                              <1>   ; register_interrupt 4, int4
   108                              <1> 
   109                              <1>   ; init other hardware
   110 0000000F B000                <1>   mov al,0
   111 00000011 E63A                <1>   out 0x3a,al           ; keyboard \force state/
   112 00000013 E63A                <1>   out 0x3a,al           ; keyboard \force state/
   113 00000015 B0FF                <1>   mov al,0xFF
   114 00000017 E63A                <1>   out 0x3a,al           ; keyboard \reset/
   115 00000019 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   116 0000001B B037                <1>   mov al,0x37
   117 0000001D E63A                <1>   out 0x3a,al           ; keyboard \set command
   118                              <1> 
   119 0000001F B8001C              <1>   mov ax,GREEN      
   120 00000022 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   121 00000024 B83800              <1>   mov ax,DST                
   122 00000027 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   123 00000029 BF0000              <1>   mov di,0                  ;
   124 0000002C B200                <1>   mov dl,0                  ; track=0
   125 0000002E B601                <1>   mov dh,1                  ; sector=1
   126 00000030 B92800              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   127 00000033 EB0B                <1>   jmp move_head
   128                              <1> 
   129                              <1> ; ───────────────────────────────────────────────────────────────────────────
   130                              <1> 
   131                              <1> next_sector:
   132 00000035 FEC6                <1>   inc dh                    ; sector++
   133 00000037 80FE0A              <1>   cmp dh,10
   134 0000003A 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   135 0000003C B601                <1>   mov dh,1
   136 0000003E FEC2                <1>   inc dl                    ; else track++ ; sector=1
   137                              <1> 
   138                              <1> move_head:
   139 00000040 88D0                <1>   mov al,dl
   140 00000042 E60E                <1>   out 0Eh,al               ; set track number
   141 00000044 B018                <1>   mov al,18h     
   142 00000046 E608                <1>   out 8,al                 ; seek track, load head
   143 00000048 B000                <1>   mov al,0
   144 0000004A E61C                <1>   out 1Ch,al               ; set desired drive/side
   145 0000004C D40A                <1>   aam
   146                              <1> 
   147                              <1> head_moving:
   148 0000004E E408                <1>   in al,8
   149 00000050 A801                <1>   test al,1
   150 00000052 75FA                <1>   jnz head_moving
   151                              <1> 
   152                              <1> read_sector:
   153 00000054 88F0                <1>   mov al,dh
   154 00000056 E60C                <1>   out 0Ch,al                ; sector number
   155 00000058 B702                <1>   mov bh,2                  ; 00000010b
   156 0000005A B396                <1>   mov bl,96h                ; 10010110b
   157 0000005C B400                <1>   mov ah,0
   158 0000005E B080                <1>   mov al,80h
   159 00000060 E608                <1>   out 8,al                  ; read sector
   160 00000062 D40A<rep 4h>        <1>   times 4 aam               ; wait
   161                              <1> 
   162                              <1> check_status_1:
   163 0000006A E408                <1>   in al,8                   ; read status
   164 0000006C D0F8                <1>   sar al,1                  ; status/=2
   165 0000006E 731F                <1>   jnb check_status_3
   166 00000070 75F8                <1>   jnz check_status_1
   167                              <1> 
   168                              <1> wait_for_data:
   169 00000072 E408                <1>   in al,8                   ; read status
   170 00000074 20D8                <1>   and al,bl                 ; 96h
   171 00000076 74FA                <1>   jz wait_for_data
   172                              <1> 
   173                              <1> store_byte_1:
   174 00000078 E40E                <1>   in al,0Eh
   175 0000007A AA                  <1>   stosb
   176                              <1> 
   177                              <1> check_status_2:
   178 0000007B E408                <1>   in al,8                   ; read status
   179 0000007D 48                  <1>   dec ax                    ; status--
   180 0000007E 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   181 00000080 38F8                <1>   cmp al, bh                ; bh=2
   182 00000082 750B                <1>   jnz check_status_3        ; if (status==1) 
   183                              <1> 
   184                              <1> store_byte_2:
   185 00000084 E40E                <1>   in al,0Eh  
   186 00000086 AA                  <1>   stosb
   187                              <1> 
   188                              <1> check_status_4:
   189 00000087 E408                <1>   in al,8                   ; read status
   190 00000089 38F8                <1>   cmp al, bh                ; bh=2
   191 0000008B 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   192 0000008D EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   193                              <1> 
   194                              <1> ; ───────────────────────────────────────────────────────────────────────────
   195                              <1> 
   196                              <1> check_status_3:
   197 0000008F E408                <1>   in al, 8                  ; read status
   198 00000091 A81C                <1>   test al, 1Ch              ; 00011100
   199 00000093 7402                <1>   jz while_sectors
   200 00000095 EBBD                <1>   jmp read_sector
   201                              <1> 
   202                              <1> ; ───────────────────────────────────────────────────────────────────────────
   203                              <1> 
   204                              <1> while_sectors:
   205 00000097 E80F00              <1>   call progress_bar
   206 0000009A E299                <1>   loop next_sector
   207                              <1> 
   208                              <1> done_reading:
   209 0000009C 0E                  <1>   push cs
   210 0000009D 17                  <1>   pop ss
   211 0000009E BC0000              <1>   mov sp,0
   212 000000A1 E82600              <1>   call clear_green
   213 000000A4 0E                  <1>   push cs
   214 000000A5 1F                  <1>   pop ds
   215 000000A6 E95C01              <1>   jmp setup
   216                              <1> 
   217                              <1> ; ───────────────────────────────────────────────────────────────────────────
   218                              <1> 
   219                              <1> progress_bar:
   220                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   221 000000A9 52                  <1>   push dx
   222 000000AA 53                  <1>   push bx
   223 000000AB 31D2                <1>   xor dx,dx
   224 000000AD B81E00              <1>   mov ax,BAR_WIDTH
   225 000000B0 BB2800              <1>   mov bx,NUM_SECTORS    
   226 000000B3 F7E1                <1>   mul cx
   227 000000B5 F7F3                <1>   div bx
   228 000000B7 5B                  <1>   pop bx
   229 000000B8 5A                  <1>   pop dx
   230 000000B9 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   231 000000BB D1E6                <1>   shl si,1                  ; *=2
   232 000000BD D1E6                <1>   shl si,1                  ; *=2  
   233 000000BF BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   234 000000C2 29F5                <1>   sub bp,si
   235 000000C4 3EC64600FF          <1>   mov byte [ds:bp],-1
   236 000000C9 C3                  <1>   ret
   237                              <1> 
   238                              <1> ; clear_red:
   239                              <1> ;   mov ax,RED
   240                              <1> ;   call clear_channel
   241                              <1> ;   ret
   242                              <1> 
   243                              <1> clear_green:
   244 000000CA B8001C              <1>   mov ax,GREEN
   245 000000CD E80100              <1>   call clear_channel
   246 000000D0 C3                  <1>   ret
   247                              <1> 
   248                              <1> ; clear_blue:
   249                              <1> ;   mov ax,BLUE
   250                              <1> ;   call clear_channel
   251                              <1> ;   ret
   252                              <1> 
   253                              <1> ; clear_screen:
   254                              <1> ;   call clear_red
   255                              <1> ;   call clear_green
   256                              <1> ;   call clear_blue
   257                              <1> ;   ret
   258                              <1> 
   259                              <1> clear_channel:
   260 000000D1 8EC0                <1>   mov es,ax
   261 000000D3 B9201C              <1>   mov cx,COLS*ROWS*2
   262 000000D6 31FF                <1>   xor di,di
   263 000000D8 31C0                <1>   xor ax,ax
   264 000000DA F3AB                <1>   rep stosw         ; clear screen
   265 000000DC C3                  <1>   ret
   266                              <1> 
   267                              <1> ; ───────────────────────────────────────────────────────────────────────────
   268                              <1> 
   269                              <1> ; write_char:   ; ds=FONT, es=GREEN, al=charcode
   270                              <1> ;   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   271                              <1> ;   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   272                              <1> ;   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   273                              <1> 
   274                              <1> ;   push ds
   275                              <1> ;   push es
   276                              <1> ;   push ax
   277                              <1> ;   push bx
   278                              <1> ;   push cx
   279                              <1> 
   280                              <1> ;   push ax
   281                              <1> ;   mov ax,GREEN
   282                              <1> ;   mov es,ax
   283                              <1> ;   mov ax,FONT
   284                              <1> ;   mov ds,ax
   285                              <1> ;   pop ax
   286                              <1> 
   287                              <1> ;   ; mov ax,65*8
   288                              <1> ;   ; mov al,'x'
   289                              <1> ;   mov ah,8
   290                              <1> ;   mul ah        ; ax=al*ah
   291                              <1> 
   292                              <1> ;   mov si,ax
   293                              <1> ;   movsw
   294                              <1> ;   movsw
   295                              <1> ;   add di,0x11c
   296                              <1> ;   movsw
   297                              <1> ;   movsw
   298                              <1> ;   mov bx,288
   299                              <1> ;   sub di,bx
   300                              <1>   
   301                              <1> ;   ; pop ax
   302                              <1> ;   ; pop es
   303                              <1> ;   ; pop ds
   304                              <1> ;   ; ret
   305                              <1> 
   306                              <1> 
   307                              <1> ;   ; row snap
   308                              <1> ;   xor dx,dx
   309                              <1> ;   mov ax,di
   310                              <1> ;   div bx
   311                              <1> ;   cmp dx,0
   312                              <1> ;   jne .return
   313                              <1> ;   add di,bx
   314                              <1> 
   315                              <1> 
   316                              <1> ;   ; wrap to top
   317                              <1> ;   cmp di,14400   ; dit later oplossen met cursor positie
   318                              <1> ;   jb .return
   319                              <1> ;   ; xor di,di      ; move to left top. change later to scroll
   320                              <1> 
   321                              <1> ;   ; TODO: call scroll_down
   322                              <1> ;   ; std
   323                              <1> ;   ; push di
   324                              <1> ;   ; push cx
   325                              <1> ;   ; mov cx,4*72*24
   326                              <1> ;   ; mov ax,0
   327                              <1> ;   ; rep stosw
   328                              <1> ;   ; pop cx
   329                              <1> ;   ; pop di
   330                              <1> ;   ; cld
   331                              <1> 
   332                              <1> ;   ; DONE: clear last line
   333                              <1> ;   sub di,bx
   334                              <1> ;   sub di,bx
   335                              <1> ;   push di
   336                              <1> ;   push cx
   337                              <1> ;   mov cx,COLS*ROWS*2
   338                              <1> ;   xor ax,ax
   339                              <1> ;   rep stosw         ; clear screen
   340                              <1> ;   pop cx
   341                              <1> ;   pop di
   342                              <1> 
   343                              <1> ; .return
   344                              <1> ;   push bx
   345                              <1> ;   push cx
   346                              <1> ;   pop ax
   347                              <1> ;   pop es
   348                              <1> ;   pop ds
   349                              <1> ;   ret
   350                              <1> 
   351                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   352                              <1> 
   353                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   354 000000DD 1E                  <1>   push ds
   355 000000DE 06                  <1>   push es
   356 000000DF 50                  <1>   push ax
   357 000000E0 50                  <1>   push ax
   358 000000E1 B8001C              <1>   mov ax,GREEN
   359 000000E4 8EC0                <1>   mov es,ax
   360 000000E6 B800FF              <1>   mov ax,FONT
   361 000000E9 8ED8                <1>   mov ds,ax
   362 000000EB 58                  <1>   pop ax
   363 000000EC B408                <1>   mov ah,8
   364 000000EE F6E4                <1>   mul ah        ; al*=ah
   365 000000F0 89C6                <1>   mov si,ax
   366 000000F2 A5                  <1>   movsw
   367 000000F3 A5                  <1>   movsw
   368 000000F4 81C71C01            <1>   add di,0x11c
   369 000000F8 A5                  <1>   movsw
   370 000000F9 A5                  <1>   movsw
   371 000000FA 81EF2001            <1>   sub di,0x120
   372                              <1>   ; cmp di,14400   ; dit later oplossen met cursor positie
   373                              <1>   ; jb .return
   374                              <1>   ; xor di,di      ; move to left top. change later to scroll
   375                              <1> 
   376                              <1> 
   377                              <1>   ; row snap
   378 000000FE 31D2                <1>   xor dx,dx
   379 00000100 89F8                <1>   mov ax,di
   380 00000102 F7F3                <1>   div bx
   381 00000104 83FA00              <1>   cmp dx,0
   382 00000107 7502                <1>   jne .return
   383 00000109 01DF                <1>   add di,bx
   384                              <1>   
   385                              <1> 
   386                              <1> .return
   387 0000010B 58                  <1>   pop ax
   388 0000010C 07                  <1>   pop es
   389 0000010D 1F                  <1>   pop ds
   390 0000010E C3                  <1>   ret
   391                              <1> 
   392                              <1> write_string:
   393 0000010F 2E8A07              <1>   mov al,[cs:bx]
   394 00000112 43                  <1>   inc bx
   395 00000113 08C0                <1>   or al,al
   396 00000115 7405                <1>   jz .return
   397 00000117 E8C3FF              <1>   call write_char
   398 0000011A EBF3                <1>   jmp short write_string
   399                              <1> .return
   400 0000011C C3                  <1>   ret
   401                              <1> 
   402                              <1> ; ───────────────────────────────────────────────────────────────────────────
   403                              <1> 
   404                              <1> write_binary_byte:    ; input AL
   405 0000011D 50                  <1>   push ax
   406 0000011E 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   407 00000120 B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   408                              <1> .lp:
   409 00000123 D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   410 00000125 B80000              <1>   mov ax, 0           ; AH leegmaken
   411 00000128 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   412 0000012A 51                  <1>   push cx             ; CX opslaan
   413 0000012B E8AFFF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   414 0000012E 59                  <1>   pop cx              ; CX herstellen
   415 0000012F E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   416 00000131 58                  <1>   pop ax
   417 00000132 C3                  <1>   ret
   418                              <1> 
   419                              <1> ; ───────────────────────────────────────────────────────────────────────────
   420                              <1> 
   421                              <1> write_binary_word:    ; input AX
   422 00000133 50                  <1>   push ax
   423 00000134 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   424 00000135 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   425 00000137 B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   426                              <1> .lp:
   427 0000013A D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   428 0000013C B80000              <1>   mov ax, 0          ; AH leegmaken
   429 0000013F 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   430 00000141 51                  <1>   push cx            ; CX opslaan
   431 00000142 E898FF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   432 00000145 59                  <1>   pop cx             ; CX herstellen
   433 00000146 E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   434 00000148 5A                  <1>   pop dx             ; DX herstellen
   435 00000149 58                  <1>   pop ax
   436 0000014A C3                  <1>   ret
   437                              <1> 
   438                              <1> ; ───────────────────────────────────────────────────────────────────────────
   439                              <1> 
   440                              <1> write_number_word:
   441 0000014B 50                  <1>     push ax
   442 0000014C 52                  <1>     push dx
   443 0000014D 31D2                <1>     xor dx,dx
   444 0000014F 52                  <1>     push dx ;high byte is zero
   445 00000150 31D2                <1> .clp xor dx,dx
   446 00000152 2EF736[6E01]        <1>     cs div word [.base]
   447 00000157 92                  <1>     xchg ax,dx
   448 00000158 05300E              <1>     add ax,0xe30
   449 0000015B 50                  <1>     push ax
   450 0000015C 92                  <1>     xchg ax,dx
   451 0000015D 09C0                <1>     or ax,ax
   452 0000015F 75EF                <1>     jnz .clp
   453 00000161 58                  <1> .dlp pop ax
   454 00000162 08E4                <1>     or ah,ah
   455 00000164 7405                <1>     jz .done
   456 00000166 E874FF              <1>     call write_char
   457 00000169 EBF6                <1>     jmp short .dlp
   458 0000016B 5A                  <1> .done pop dx
   459 0000016C 58                  <1>     pop ax
   460 0000016D C3                  <1>     ret
   461 0000016E 0A00                <1> .base dw 10
   462                              <1> 
   463                              <1> ; ───────────────────────────────────────────────────────────────────────────
   464                              <1> 
   465                              <1> write_signed_number_word:    
   466 00000170 09C0                <1>     or ax,ax
   467 00000172 790A                <1>     jns .write_return        ; if >0 write and return
   468 00000174 50                  <1>     push ax
   469 00000175 B82D00              <1>     mov ax,'-'
   470 00000178 E862FF              <1>     call write_char
   471 0000017B 58                  <1>     pop ax
   472 0000017C F7D8                <1>     neg ax                   ; destroys ax when negative
   473                              <1> .write_return:
   474 0000017E E8CAFF              <1>     call write_number_word
   475 00000181 C3                  <1>     ret
   476                              <1> 
   477                              <1> ; ───────────────────────────────────────────────────────────────────────────
   478                              <1> 
   479                              <1> check_keys:
   480 00000182 E43A                <1>   in al,0x3a        ; get keyboard status
   481 00000184 88C4                <1>   mov ah,al
   482 00000186 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   483 00000188 2EA2[0500]          <1>   mov [cs:key.ctrl],al
   484 0000018C F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   485 0000018F 7410                <1>   jz .return
   486 00000191 E438                <1>   in al,0x38        ; get data byte from keyboard  
   487 00000193 2EA2[0400]          <1>   mov [cs:key.code],al
   488 00000197 B037                <1>   mov al,0x37
   489 00000199 E63A                <1>   out 0x3a,al       ; drop key?  
   490 0000019B 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   491 0000019D 2EA1[0400]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   492 000001A1 C3                  <1> .return ret
   493                              <1> 
   494                              <1> 
   495                              <1> 
   496                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   497                              <1> ;   ret
   498                              <1> 
   499                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   500                              <1> 
   501                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   502                              <1> ; much faster and simpler on the grid than off the grid
   503                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   504                              <1> 
   505                              <1> 
   506                              <1> ; wide font by stretching the font horizontally using bitshift
   507                              <1> 
   508                              <1> 
   509                              <1> ; fill_white:
   510                              <1> ;   mov ax,0xffff
   511                              <1> ;   call fill_red
   512                              <1> ;   call fill_green
   513                              <1> ;   call fill_blue
   514                              <1> ;   ret
   515                              <1> 
   516                              <1> ; fill_pink:
   517                              <1> ;   mov ax,0xffff
   518                              <1> ;   call fill_red
   519                              <1> ;   mov ah,0b01010101
   520                              <1> ;   mov al,0b10101010
   521                              <1> ;   call fill_green
   522                              <1> ;   call fill_blue
   523                              <1> ;   ret
   524                              <1> 
   525                              <1> ; fill_pink2:
   526                              <1> ;   mov ax,0xffff
   527                              <1> ;   call fill_red
   528                              <1> ;   mov ah,0b11001100
   529                              <1> ;   mov al,0b00110011
   530                              <1> ;   call fill_green
   531                              <1> ;   call fill_blue
   532                              <1> ;   ret
   533                              <1> 
   534                              <1> ; fill_pink3:
   535                              <1> ;   mov ax,0xffff
   536                              <1> ;   call fill_red
   537                              <1> ;   mov ah,0b00010001
   538                              <1> ;   mov al,0b01000100
   539                              <1> ;   call fill_green
   540                              <1> ;   call fill_blue
   541                              <1> ;   ret
   542                              <1> 
   543                              <1> ; fill_pink4:
   544                              <1> ;   mov ax,0xffff
   545                              <1> ;   call fill_red
   546                              <1> ;   mov ah,0b11110111
   547                              <1> ;   mov al,0b01111111
   548                              <1> ;   call fill_green
   549                              <1> ;   call fill_blue
   550                              <1> ;   ret
   551                              <1> 
   552                              <1> ; fill_red:
   553                              <1> ;   mov bx,RED
   554                              <1> ;   call fill_channel
   555                              <1> ;   ret
   556                              <1> ; fill_green:
   557                              <1> ;   mov bx,GREEN
   558                              <1> ;   call fill_channel
   559                              <1> ;   ret
   560                              <1> ; fill_blue:
   561                              <1> ;   mov bx,BLUE
   562                              <1> ;   call fill_channel
   563                              <1> ;   ret
   564                              <1> 
   565                              <1> ; fill_channel: ;ax=pattern
   566                              <1> ;   mov es,bx
   567                              <1> ;   mov cx,COLS*ROWS*2
   568                              <1> ;   xor di,di
   569                              <1> ;   rep stosw
   570                              <1> ;   ret
   571                              <1> 
   572                              <1> ; ───────────────────────────────────────────────────────────────────────────
   573                              <1> 
   574                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   575                              <1> ;   push bx
   576                              <1> ;   push di
   577                              <1> ;   mov es,ax
   578                              <1> ;   xor cx,cx
   579                              <1> ;   mov cl,bh        ; rows (bl)
   580                              <1> ; .rows_loop:
   581                              <1> ;   push cx
   582                              <1> ;   xor cx,cx
   583                              <1> ;   mov cl,bl        ; cols (bh)
   584                              <1> ; .cols_loop:
   585                              <1> ;   mov ax,0
   586                              <1> ;   stosw
   587                              <1> ;   stosw
   588                              <1> ;   loop .cols_loop
   589                              <1> ;   add di,COLS*4    ; one row down
   590                              <1> ;   mov ah,0
   591                              <1> ;   mov al,bl
   592                              <1> ;   times 2 shl ax,1
   593                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   594                              <1> ;   pop cx
   595                              <1> ;   loop .rows_loop
   596                              <1> ;   pop di
   597                              <1> ;   pop bx
   598                              <1> ;   ret
   599                              <1> 
   600                              <1> ; ───────────────────────────────────────────────────────────────────────────
   601                              <1> 
   602                              <1> ; fill_rect_black: 
   603                              <1> ;   mov ax,RED
   604                              <1> ;   call clear_area
   605                              <1> ;   mov ax,GREEN
   606                              <1> ;   call clear_area
   607                              <1> ;   mov ax,BLUE
   608                              <1> ;   call clear_area
   609                              <1> ;   ret
   610                              <1> 
   611                              <1> ; ───────────────────────────────────────────────────────────────────────────
   612                              <1> 
   613                              <1> draw_spr:
   614 000001A2 8B1C                <1>   mov bx,[si]
   615 000001A4 46<rep 2h>          <1>   times 2 inc si
   616                              <1> draw_pic:
   617 000001A6 B800F0              <1>   mov ax, RED
   618 000001A9 E80D00              <1>   call draw_channel
   619 000001AC B8001C              <1>   mov ax, GREEN
   620 000001AF E80700              <1>   call draw_channel
   621 000001B2 B800F4              <1>   mov ax, BLUE
   622 000001B5 E80100              <1>   call draw_channel
   623 000001B8 C3                  <1>   ret
   624                              <1> 
   625                              <1> ; ───────────────────────────────────────────────────────────────────────────
   626                              <1> 
   627                              <1> draw_channel:
   628 000001B9 57                  <1>   push di
   629 000001BA 8EC0                <1>   mov es,ax
   630 000001BC 31C9                <1>   xor cx,cx
   631 000001BE 88F9                <1>   mov cl,bh        ; rows (bl)
   632                              <1> .rows_loop:
   633 000001C0 51                  <1>   push cx
   634 000001C1 31C9                <1>   xor cx,cx
   635 000001C3 88D9                <1>   mov cl,bl        ; cols (bh)
   636                              <1> .cols_loop:
   637 000001C5 A5                  <1>   movsw
   638 000001C6 A5                  <1>   movsw
   639 000001C7 E2FC                <1>   loop .cols_loop
   640 000001C9 81C72001            <1>   add di,COLS*4    ; one row down
   641 000001CD B400                <1>   mov ah,0
   642 000001CF 88D8                <1>   mov al,bl
   643 000001D1 D1E0<rep 2h>        <1>   times 2 shl ax,1
   644 000001D5 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   645 000001D7 59                  <1>   pop cx
   646 000001D8 E2E6                <1>   loop .rows_loop
   647 000001DA 5F                  <1>   pop di
   648 000001DB C3                  <1>   ret
   649                              <1> 
   650                              <1> ; ───────────────────────────────────────────────────────────────────────────
   651                              <1> 
   652                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   653 000001DC B89000              <1>   mov ax,144      ; 2*72 cols
   654 000001DF F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   655 000001E1 D1E0                <1>   shl ax,1        ; verdubbel AX
   656 000001E3 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   657 000001E5 D0E3                <1>   shl bl,1        ; bl*=2
   658 000001E7 D0E3                <1>   shl bl,1        ; bl*=2
   659 000001E9 B700                <1>   mov bh,0
   660 000001EB 01DF                <1>   add di,bx       ; di+=bl
   661 000001ED C3                  <1>   ret
   662                              <1> 
   663                              <1> ; ───────────────────────────────────────────────────────────────────────────
   664                              <1> 
   665                              <1> ; calc_di_from_cursor:  ; input cursor, output di
   666                              <1> ;   mov ax,[cursor] 
   667                              <1> ;   sub ax,0x0101   ; cursor is 1 based
   668                              <1> ;   xchg ax,bx      ; bx=ax
   669                              <1> ;   mov ax,144      ; 2*72 cols
   670                              <1> ;   mul bh          ; bh*=144 resultaat in AX
   671                              <1> ;   shl ax,1        ; verdubbel AX
   672                              <1> ;   shl ax,1        ; verdubbel AX
   673                              <1> ;   mov di,ax       ; di=ax (=bh*288)
   674                              <1> ;   shl bl,1        ; bl*=2
   675                              <1> ;   shl bl,1        ; bl*=2
   676                              <1> ;   mov bh,0
   677                              <1> ;   add di,bx       ; di+=bl
   678                              <1> ;   ret
   679                              <1> 
   680                              <1> 
   681                              <1> 
   682                              <1> 
   683                              <1> ; als je cursor gebruikt is dit missch niet nodig.
   684                              <1> ; row_snap:  ; this code detects if DI is in between rows. When DI goes to the next half row it converts it to a whole row.
   685                              <1> ;   push ax
   686                              <1> ;   push bx
   687                              <1> ;   push dx
   688                              <1> ;   mov bx,288
   689                              <1> ;   mov ax,di
   690                              <1> ;   cwd ; xor dx,dx
   691                              <1> ;   div bx
   692                              <1> ;   jnp .done  ; if ax%288==0 
   693                              <1> ;   add di,bx
   694                              <1> ;   .done
   695                              <1> ;   ; add di,dx
   696                              <1> ;   pop dx
   697                              <1> ;   pop bx
   698                              <1> ;   pop ax
   699                              <1> ;   ret
   700                              <1> 
   701                              <1> 
   702                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   703                              <1> 
   704                              <1> ; calc_di_from_cursor_index:  ; index is cursor index from 0 tot 72*25
   705                              <1> ;   push ax
   706                              <1> ;   push bx
   707                              <1> ;   push dx
   708                              <1> ;   xor dx,dx
   709                              <1> ;   mov ax,[cursor.index]
   710                              <1> ;   mov bx,72
   711                              <1> ;   div bx       ; ax=rows
   712                              <1> ;   push dx      ; dx=cols
   713                              <1> ;   xor dx,dx    ; clear dx for multiplication
   714                              <1> ;   mov bx,576
   715                              <1> ;   mul bx       ; ax contains DI position for row
   716                              <1> ;   mov di,ax
   717                              <1> ;   pop ax       ; ax now contains cols
   718                              <1> ;   shl ax,1     ; *=2
   719                              <1> ;   shl ax,1     ; *=2
   720                              <1> ;   add di,ax
   721                              <1> ;   pop dx
   722                              <1> ;   pop bx
   723                              <1> ;   pop ax
   724                              <1> ;   ret
   725                              <1> 
   726                              <1> ; ───────────────────────────────────────────────────────────────────────────
   727                              <1> 
   728                              <1> 
   729                              <1> ; set_cursor:
   730                              <1> ; cursor_next_char
   731                              <1> 
   732                              <1> 
   733                              <1> 
   734                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   735                              <1> 
     2                                  ; %include "atan.asm"
     3                                  
     4                                  ship:
     5                                   .pos:
     6 000001EE 0090                     .pos.x: dw 73728/2
     7 000001F0 D06B                     .pos.y: dw 51200/2 + 2000
     8                                   .vel: 
     9 000001F2 F6FF                     .vel.x: dw -10
    10 000001F4 0000                     .vel.y: dw 0
    11 000001F6 0000                     .vel.flags: dw 0
    12                                   .acc:
    13 000001F8 0000                     .acc.x: dw 0
    14 000001FA 0000                     .acc.y: dw 0
    15                                   .forces:
    16 000001FC 0000                     .forces.x: dw 0
    17 000001FE 0000                     .forces.y: dw 0
    18 00000200 0000                     .angle: dw 0
    19 00000202 0000                     .prev_di: dw 0
    20                                  
    21 00000204 02                      color: db Color.G
    22                                  
    23                                  
    24                                  ;kan ik een generieke cursor_next maken die de waarde 
    25                                  ;van DI opvraagd en deze verhoogt
    26                                  ;en als de cursor tussen twee regels staat 
    27                                  ;deze verhoogd met 288
    28                                  
    29                                  ; en als de waarde van DI boven de max uitkomt dat
    30                                  ; er dan gescrollt wordt en DI wordt verplaatst naar
    31                                  ; het begin van de regel
    32                                  
    33                                  ; en alles heel lightweight?
    34                                  
    35                                  ; msg: db "abcdef",0
    36                                  
    37                                  setup:
    38 00000205 31FF                      xor di,di
    39                                    print "Test123"
    54 00000207 EB08                <1>  jmp %%endstr
    55 00000209 5465737431323300    <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 00000211 BB[0902]            <1>  mov bx,%%str
    58 00000214 E8F8FE              <1>  call write_string
    40                                  
    41                                    ; set_cursor 2,1
    42                                    ; mov al,'a'
    43                                    ; call write_char
    44                                    ; print "atan(426)="
    45                                    ; jmp .tmp
    46                                    ; .s db 
    47                                    ; .tmp
    48                                    ; mov bx, msg
    49                                    ; call write_string
    50                                  
    51                                    ; mov ax,12345
    52                                    ; call write_number_word
    53                                  
    54                                    ; hlt
    55                                    ; mov ax,426
    56                                    ; ; call atan
    57                                    ; call write_number_word
    58 00000217 F4                        hlt
    59                                  
    60                                    ; mov di,4*72 + 4*10
    61                                    ; call row_snap
    62                                    ; mov ax,12345
    63                                    ; call write_number_word  
    64                                  
    65                                    ; mov word [cursor],0x0208
    66                                  
    67                                    ; ; mov byte [cursor.col],8
    68                                    ; ; mov byte [cursor.row],2
    69                                  
    70                                    ; inc byte [cursor.col]
    71                                    ; push word [cursor]
    72                                    ; pop word [cursor]
    73                                  
    74                                    ; call calc_di_from_cursor
    75                                    ; set_cursor 1,1 ; 1,72
    76                                    ; mov cx,500
    77                                    ; .lp:
    78                                    ;   mov ax,cx
    79                                    ;   call write_number_word
    80                                    ;   mov al,' '
    81                                    ;   call write_char
    82                                    ;   loop .lp
    83                                  
    84                                    ; hlt
    85                                  
    86                                    ; mov word [cursor.index],36
    87                                    ; call calc_di_from_cursor_index
    88                                  
    89                                    
    90                                    ; hlt
    91                                  
    92                                    ; ; mov bh,al
    93                                    ; ; mov bl,dl
    94                                  
    95                                  
    96                                    ; ; call calc_di_from_bx
    97                                  
    98                                    
    99                                    ; ; xor di,di
   100                                    ; ; mov ax,cx
   101                                    ; ; call write_number_word
   102                                    ; mov al,'x'
   103                                    ; call write_char
   104                                  
   105                                    ; inc word [cursor.index]
   106                                  
   107                                    ; ; print "   "
   108                                  
   109                                    ; loop .lp
   110                                  
   111                                  
   112                                    
   113                                  
   114                                    ; mov cx,426
   115                                    ; mov ax,12321        ; 12321 = 111*111 (squared scale)
   116                                    ; xor dx,dx           ; dx=0 (prevent overflow) 
   117                                    ; idiv cx             ; ax/=z
   118                                    ; call write_number_word
   119                                  
   120                                    ; hlt
   121                                  
   122                                  
   123                                    ; xor bp,bp
   124                                    ; jmp draw
   125                                  
   126                                  ; ───────────────────────────────────────────────────────────────────────────
   127                                  
   128                                  ; vec_mult:   ; cx scalar, ax=x, bx=y
   129                                    
   130                                  FRICTION equ 94
   131                                  
   132                                  update_ship:
   133                                    
   134                                    ; x+=vx
   135 00000218 A1[EE01]                  mov ax,[ship.pos.x]       ; 0..73728  (65536)
   136 0000021B 0306[F201]                add ax,[ship.vel.x]
   137 0000021F A3[EE01]                  mov [ship.pos.x],ax
   138                                  
   139                                    ; y+=vy
   140 00000222 A1[F001]                  mov ax,[ship.pos.y]       ; 0..51200  (=1024*50)
   141 00000225 0306[F401]                add ax,[ship.vel.y]
   142 00000229 A3[F001]                  mov [ship.pos.y],ax
   143                                  
   144                                    ; vx*=98%
   145 0000022C A1[F201]                  mov ax, [ship.vel.x]
   146 0000022F 99                        cwd                 ; Convert word to double word (sign-extend AX into DX)
   147 00000230 B95E00                    mov cx, FRICTION
   148 00000233 F7E9                      imul cx             ; Signed multiplication
   149 00000235 B96400                    mov cx, 100
   150 00000238 F7F9                      idiv cx             ; Signed division
   151 0000023A A3[F201]                  mov [ship.vel.x], ax
   152                                  
   153                                    ; vy*=98%
   154 0000023D A1[F401]                  mov ax, [ship.vel.y]
   155 00000240 99                        cwd                 ; Convert word to double word (sign-extend AX into DX)
   156 00000241 B95E00                    mov cx, FRICTION
   157 00000244 F7E9                      imul cx             ; Signed multiplication
   158 00000246 B96400                    mov cx, 100
   159 00000249 F7F9                      idiv cx             ; Signed division
   160 0000024B A3[F401]                  mov [ship.vel.y], ax
   161                                  
   162 0000024E C3                        ret
   163                                  
   164                                  ; ───────────────────────────────────────────────────────────────────────────
   165                                  
   166                                  draw_ship:
   167                                  
   168 0000024F A1[EE01]                  mov ax,[ship.pos.x]
   169 00000252 8B1E[F001]                mov bx,[ship.pos.y]
   170 00000256 E8FC00                    call world2screen
   171 00000259 E880FF                    call calc_di_from_bx
   172                                  
   173 0000025C 393E[0202]                cmp [ship.prev_di],di
   174 00000260 742B                      je .return
   175                                  
   176                                    ; call world2screen ; ax and bx are already set by pop bx, pop ax
   177                                    ; call calc_di_from_bx
   178                                  
   179 00000262 8B3E[0202]                mov di,[ship.prev_di]
   180                                    
   181 00000266 BB0808                    mov bx,0x0808  ; rows,cols
   182                                    ; call fill_rect_black
   183                                  
   184 00000269 A1[EE01]                  mov ax,[ship.pos.x]
   185 0000026C 8B1E[F001]                mov bx,[ship.pos.y]
   186 00000270 E8E200                    call world2screen
   187 00000273 E866FF                    call calc_di_from_bx
   188 00000276 893E[0202]                mov [ship.prev_di],di
   189                                  
   190                                  
   191 0000027A BE[6206]                  mov si,img_up
   192 0000027D A1[EE01]                  mov ax,[ship.pos.x]
   193 00000280 8B1E[F001]                mov bx,[ship.pos.y]
   194 00000284 E8CE00                    call world2screen ; ax and bx are already set by pop bx, pop ax
   195 00000287 E852FF                    call calc_di_from_bx
   196 0000028A E815FF                    call draw_spr
   197                                  
   198                                  .return
   199 0000028D C3                        ret
   200                                  
   201                                  ; ───────────────────────────────────────────────────────────────────────────
   202                                  
   203                                  draw:
   204 0000028E 0E                        push cs
   205 0000028F 1F                        pop ds   ; make sure DS is set to CS for data lookups like [ship.pos.x]
   206                                  
   207 00000290 E885FF                    call update_ship
   208 00000293 E8B9FF                    call draw_ship
   209                                  
   210 00000296 E8B400                    call _wait
   211                                  
   212 00000299 45                        inc bp
   213                                  
   214                                    set_cursor 12,45
    49                              <1> 
    50 0000029A BF7019              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   215                                    print "frame: "
    54 0000029D EB08                <1>  jmp %%endstr
    55 0000029F 6672616D653A2000    <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000002A7 BB[9F02]            <1>  mov bx,%%str
    58 000002AA E862FE              <1>  call write_string
   216 000002AD 89E8                      mov ax,bp
   217 000002AF E899FE                    call write_number_word     ; draw frame counter
   218                                    print "  "
    54 000002B2 EB03                <1>  jmp %%endstr
    55 000002B4 202000              <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000002B7 BB[B402]            <1>  mov bx,%%str
    58 000002BA E852FE              <1>  call write_string
   219                                  
   220                                    set_cursor 13,45
    49                              <1> 
    50 000002BD BFB01B              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   221                                    print "vx: "
    54 000002C0 EB05                <1>  jmp %%endstr
    55 000002C2 76783A2000          <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000002C7 BB[C202]            <1>  mov bx,%%str
    58 000002CA E842FE              <1>  call write_string
   222 000002CD A1[F201]                  mov ax,[ship.vel.x]  
   223 000002D0 E89DFE                    call write_signed_number_word
   224                                    print "  "
    54 000002D3 EB03                <1>  jmp %%endstr
    55 000002D5 202000              <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000002D8 BB[D502]            <1>  mov bx,%%str
    58 000002DB E831FE              <1>  call write_string
   225                                  
   226                                    set_cursor 14,45
    49                              <1> 
    50 000002DE BFF01D              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   227                                    print "vy: "
    54 000002E1 EB05                <1>  jmp %%endstr
    55 000002E3 76793A2000          <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000002E8 BB[E302]            <1>  mov bx,%%str
    58 000002EB E821FE              <1>  call write_string
   228 000002EE A1[F401]                  mov ax,[ship.vel.y]
   229 000002F1 E87CFE                    call write_signed_number_word     ; draw vy
   230                                    print "  "
    54 000002F4 EB03                <1>  jmp %%endstr
    55 000002F6 202000              <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000002F9 BB[F602]            <1>  mov bx,%%str
    58 000002FC E810FE              <1>  call write_string
   231                                  
   232 000002FF E880FE                    call check_keys
   233 00000302 7502                      jnz on_key
   234                                    ;else
   235 00000304 EB88                      jmp draw          ; this code is only getting called when no key is pressed
   236                                  
   237                                  ; ───────────────────────────────────────────────────────────────────────────
   238                                  
   239                                  on_key:
   240                                    set_cursor 2,10
    49                              <1> 
    50 00000306 BF6402              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   241 00000309 A1[0400]                  mov ax,[key]
   242 0000030C E824FE                    call write_binary_word
   243 0000030F 83F877                    cmp ax,'w'
   244 00000312 7412                      je on_key_w
   245 00000314 83F861                    cmp ax,'a'
   246 00000317 7415                      je on_key_a
   247 00000319 83F873                    cmp ax,'s'
   248 0000031C 7418                      je on_key_s
   249 0000031E 83F864                    cmp ax,'d'
   250 00000321 741B                      je on_key_d
   251                                  .done
   252 00000323 E968FF                    jmp draw  ; no ret here because onkey is called by jnz
   253                                  
   254                                  
   255                                  STEP equ 500
   256                                  
   257                                  ; ───────────────────────────────────────────────────────────────────────────
   258                                  
   259                                  on_key_w:
   260 00000326 812E[F401]F401            sub word [ship.vel.y], STEP
   261 0000032C EBF5                      jmp on_key.done
   262                                  
   263                                  ; ───────────────────────────────────────────────────────────────────────────
   264                                  
   265                                  on_key_a:
   266 0000032E 812E[F201]F401            sub word [ship.vel.x], STEP
   267 00000334 EBED                      jmp on_key.done
   268                                  
   269                                  ; ───────────────────────────────────────────────────────────────────────────
   270                                  
   271                                  on_key_s:
   272 00000336 8106[F401]F401            add word [ship.vel.y], STEP
   273 0000033C EBE5                      jmp on_key.done
   274                                  
   275                                  ; ───────────────────────────────────────────────────────────────────────────
   276                                  
   277                                  on_key_d:
   278 0000033E 8106[F201]F401            add word [ship.vel.x], STEP
   279 00000344 EBDD                      jmp on_key.done
   280                                  
   281                                  ; ───────────────────────────────────────────────────────────────────────────
   282                                  
   283                                  print_msg:
   284                                    set_cursor 1,10
    49                              <1> 
    50 00000346 BF2400              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   285 00000349 E8C3FD                    call write_string
   286 0000034C C3                        ret
   287                                  
   288                                  ; ───────────────────────────────────────────────────────────────────────────
   289                                  
   290                                  _wait:
   291                                    DELAY EQU 250
   292 0000034D B9FA00                    mov cx,DELAY
   293 00000350 D40A                      .lp aam
   294 00000352 E2FC                      loop .lp
   295 00000354 C3                        ret
   296                                  
   297                                  ; ───────────────────────────────────────────────────────────────────────────
   298                                  
   299                                  world2screen:  ; input (ax,bx) = (world.x, world.y)   ; screen (row,col)
   300                                    ; WORLD:
   301                                    ;   0..73728  (65536) -> col
   302                                    ;   0..51200  (=1024*50) -> row
   303                                    ; SCREEN (ROW,COL):
   304                                    ;   0..49 (row)
   305                                    ;   0..71 (col)
   306 00000355 B10A                      mov cl,10
   307 00000357 D3EB                      shr bx,cl   ; //bl=row 0..49
   308 00000359 D3E8                      shr ax,cl   ; 
   309 0000035B 88C7                      mov bh,al   ; //bh=col 0..71
   310 0000035D 86DF                      xchg bh,bl
   311 0000035F C3                        ret
   312                                  
   313                                  ; ───────────────────────────────────────────────────────────────────────────
   314                                  
   315                                  ; FIXME
   316 00000360 <bin 302h>              img_NONE: incbin "data/ship-24.spr"
   317                                  
   318                                  
   319                                  img_up:
   320 00000662 <bin 302h>              img1: incbin "data/ship-1.spr" ;up
   321 00000964 <bin 302h>              img2: incbin "data/ship-2.spr"
   322 00000C66 <bin 302h>              img3: incbin "data/ship-3.spr"
   323                                  img_up_right:
   324 00000F68 <bin 302h>              img4: incbin "data/ship-4.spr" ;up-right
   325 0000126A <bin 302h>              img5: incbin "data/ship-5.spr"
   326 0000156C <bin 302h>              img6: incbin "data/ship-6.spr"
   327                                  img_right:
   328 0000186E <bin 302h>              img7: incbin "data/ship-7.spr" ;right
   329 00001B70 <bin 302h>              img8: incbin "data/ship-8.spr"
   330 00001E72 <bin 302h>              img9: incbin "data/ship-9.spr"
   331                                  img_down_right:
   332 00002174 <bin 302h>              img10: incbin "data/ship-10.spr" ;down-right
   333 00002476 <bin 302h>              img11: incbin "data/ship-11.spr"
   334 00002778 <bin 302h>              img12: incbin "data/ship-12.spr"
   335                                  img_down:
   336 00002A7A <bin 302h>              img13: incbin "data/ship-13.spr" ;down
   337 00002D7C <bin 302h>              img14: incbin "data/ship-14.spr"
   338 0000307E <bin 302h>              img15: incbin "data/ship-15.spr"
   339                                  img_down_left:
   340 00003380 <bin 302h>              img16: incbin "data/ship-16.spr" ;down-left
   341 00003682 <bin 302h>              img17: incbin "data/ship-17.spr"
   342 00003984 <bin 302h>              img18: incbin "data/ship-18.spr"
   343                                  img_left:
   344 00003C86 <bin 302h>              img19: incbin "data/ship-19.spr" ;left
   345 00003F88 <bin 302h>              img20: incbin "data/ship-20.spr"
   346 0000428A <bin 302h>              img21: incbin "data/ship-21.spr"
   347                                  img_up_left:
   348 0000458C <bin 302h>              img22: incbin "data/ship-22.spr" ;up-left
   349 0000488E <bin 302h>              img23: incbin "data/ship-23.spr"
   350 00004B90 <bin 302h>              img24: incbin "data/ship-24.spr"
   351                                  
   352                                  
   353 00004E92 00<rep 2816Eh>          times (180*1024)-($-$$) db 0
   354                                  
   355                                  
   356                                  
