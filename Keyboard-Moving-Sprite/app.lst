     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 EB4C                <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 40          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34                              <1> cursor:
    35 00000002 00                  <1> .col: db 0
    36 00000003 00                  <1> .row: db 0
    37                              <1> 
    38                              <1> key:
    39 00000004 00                  <1>   .code db 0
    40 00000005 00                  <1>   .ctrl db 0
    41                              <1> 
    42                              <1> ; cursor.index: dw 0
    43                              <1> 
    44                              <1> ; %macro set_cursor_row 1
    45                              <1> ;   mov di,%1 * BYTES_PER_ROW
    46                              <1> ; %endmacro
    47                              <1> 
    48                              <1> %macro set_cursor 2
    49                              <1>   ; mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    50                              <1>   mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    51                              <1> %endmacro
    52                              <1> 
    53                              <1> %macro print 1
    54                              <1>   jmp %%endstr 
    55                              <1>   %%str: db %1,0
    56                              <1>   %%endstr: 
    57                              <1>   mov bx,%%str
    58                              <1>   call write_string
    59                              <1> %endmacro
    60                              <1> 
    61                              <1> %macro register_interrupt 2
    62                              <1>   ;DS shoud be 0
    63                              <1>   mov word [%1*4+0],%2
    64                              <1>   mov word [%1*4+2],cs
    65                              <1> %endmacro
    66                              <1> 
    67                              <1> int0:; int0: Division by zero
    68 00000006 B000                <1>   mov al,0
    69 00000008 EB2E                <1>   jmp int_msg
    70                              <1> int1:; int1: Single step debugging
    71 0000000A B001                <1>   mov al,1
    72 0000000C EB2A                <1>   jmp int_msg
    73                              <1> int2:; int2: Non maskable interrupt
    74 0000000E B002                <1>   mov al,2
    75 00000010 EB26                <1>   jmp int_msg
    76                              <1> int3:; int3: For one-byte interrupt
    77 00000012 50                  <1>   push ax
    78 00000013 53                  <1>   push bx
    79 00000014 51                  <1>   push cx
    80 00000015 52                  <1>   push dx
    81 00000016 56                  <1>   push si
    82 00000017 57                  <1>   push di
    83 00000018 55                  <1>   push bp
    84 00000019 1E                  <1>   push ds
    85 0000001A 06                  <1>   push es
    86                              <1> 
    87 0000001B 31FF                <1>   xor di,di
    88                              <1>   print "x"
    54 0000001D EB02                <2>  jmp %%endstr
    55 0000001F 7800                <2>  %%str: db %1,0
    56                              <2>  %%endstr:
    57 00000021 BB[1F00]            <2>  mov bx,%%str
    58 00000024 E88901              <2>  call write_string
    89 00000027 E83201              <1>   call write_char
    90                              <1> 
    91 0000002A 07                  <1>   pop es
    92 0000002B 1F                  <1>   pop ds
    93 0000002C 5D                  <1>   pop bp
    94 0000002D 5F                  <1>   pop di
    95 0000002E 5E                  <1>   pop si
    96 0000002F 5A                  <1>   pop dx
    97 00000030 59                  <1>   pop cx
    98 00000031 5B                  <1>   pop bx
    99 00000032 58                  <1>   pop ax
   100                              <1> 
   101 00000033 CF                  <1>   iret
   102                              <1>   ; mov al,3
   103                              <1>   ; jmp int_msg
   104                              <1> int4:; int4: Signed overflow
   105 00000034 B004                <1>   mov al,4
   106 00000036 EB00                <1>   jmp int_msg
   107                              <1> int_msg:
   108 00000038 31FF                <1>   xor di,di
   109 0000003A 50                  <1>   push ax
   110                              <1>   print "int"
    54 0000003B EB04                <2>  jmp %%endstr
    55 0000003D 696E7400            <2>  %%str: db %1,0
    56                              <2>  %%endstr:
    57 00000041 BB[3D00]            <2>  mov bx,%%str
    58 00000044 E86901              <2>  call write_string
   111 00000047 58                  <1>   pop ax
   112 00000048 0430                <1>   add al,'0'
   113 0000004A E80F01              <1>   call write_char
   114 0000004D F4                  <1>   hlt
   115                              <1> 
   116                              <1> boot:
   117 0000004E FA                  <1>   cli
   118 0000004F FC                  <1>   cld
   119 00000050 E8F600              <1>   call clear_green    
   120                              <1> 
   121                              <1>   ; init video      
   122 00000053 B005                <1>   mov al, 5
   123 00000055 E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
   124                              <1>  
   125                              <1>   ; register interrupts
   126 00000057 B80000              <1>   mov ax,0
   127 0000005A 8ED8                <1>   mov ds,ax ; segment 0
   128                              <1>   register_interrupt 0, int0
    62                              <2> 
    63 0000005C C7060000[0600]      <2>  mov word [%1*4+0],%2
    64 00000062 8C0E0200            <2>  mov word [%1*4+2],cs
   129                              <1>   register_interrupt 1, int1
    62                              <2> 
    63 00000066 C7060400[0A00]      <2>  mov word [%1*4+0],%2
    64 0000006C 8C0E0600            <2>  mov word [%1*4+2],cs
   130                              <1>   register_interrupt 2, int2
    62                              <2> 
    63 00000070 C7060800[0E00]      <2>  mov word [%1*4+0],%2
    64 00000076 8C0E0A00            <2>  mov word [%1*4+2],cs
   131                              <1>   register_interrupt 3, int3
    62                              <2> 
    63 0000007A C7060C00[1200]      <2>  mov word [%1*4+0],%2
    64 00000080 8C0E0E00            <2>  mov word [%1*4+2],cs
   132                              <1>   register_interrupt 4, int4
    62                              <2> 
    63 00000084 C7061000[3400]      <2>  mov word [%1*4+0],%2
    64 0000008A 8C0E1200            <2>  mov word [%1*4+2],cs
   133                              <1> 
   134                              <1>   ; init other hardware
   135 0000008E B000                <1>   mov al,0
   136 00000090 E63A                <1>   out 0x3a,al           ; keyboard \force state/
   137 00000092 E63A                <1>   out 0x3a,al           ; keyboard \force state/
   138 00000094 B0FF                <1>   mov al,0xFF
   139 00000096 E63A                <1>   out 0x3a,al           ; keyboard \reset/
   140 00000098 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   141 0000009A B037                <1>   mov al,0x37
   142 0000009C E63A                <1>   out 0x3a,al           ; keyboard \set command
   143                              <1> 
   144 0000009E B8001C              <1>   mov ax,GREEN      
   145 000000A1 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   146 000000A3 B83800              <1>   mov ax,DST                
   147 000000A6 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   148 000000A8 BF0000              <1>   mov di,0                  ;
   149 000000AB B200                <1>   mov dl,0                  ; track=0
   150 000000AD B601                <1>   mov dh,1                  ; sector=1
   151 000000AF B92800              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   152 000000B2 EB0B                <1>   jmp move_head
   153                              <1> 
   154                              <1> ; ───────────────────────────────────────────────────────────────────────────
   155                              <1> 
   156                              <1> next_sector:
   157 000000B4 FEC6                <1>   inc dh                    ; sector++
   158 000000B6 80FE0A              <1>   cmp dh,10
   159 000000B9 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   160 000000BB B601                <1>   mov dh,1
   161 000000BD FEC2                <1>   inc dl                    ; else track++ ; sector=1
   162                              <1> 
   163                              <1> move_head:
   164 000000BF 88D0                <1>   mov al,dl
   165 000000C1 E60E                <1>   out 0Eh,al               ; set track number
   166 000000C3 B018                <1>   mov al,18h     
   167 000000C5 E608                <1>   out 8,al                 ; seek track, load head
   168 000000C7 B000                <1>   mov al,0
   169 000000C9 E61C                <1>   out 1Ch,al               ; set desired drive/side
   170 000000CB D40A                <1>   aam
   171                              <1> 
   172                              <1> head_moving:
   173 000000CD E408                <1>   in al,8
   174 000000CF A801                <1>   test al,1
   175 000000D1 75FA                <1>   jnz head_moving
   176                              <1> 
   177                              <1> read_sector:
   178 000000D3 88F0                <1>   mov al,dh
   179 000000D5 E60C                <1>   out 0Ch,al                ; sector number
   180 000000D7 B702                <1>   mov bh,2                  ; 00000010b
   181 000000D9 B396                <1>   mov bl,96h                ; 10010110b
   182 000000DB B400                <1>   mov ah,0
   183 000000DD B080                <1>   mov al,80h
   184 000000DF E608                <1>   out 8,al                  ; read sector
   185 000000E1 D40A<rep 4h>        <1>   times 4 aam               ; wait
   186                              <1> 
   187                              <1> check_status_1:
   188 000000E9 E408                <1>   in al,8                   ; read status
   189 000000EB D0F8                <1>   sar al,1                  ; status/=2
   190 000000ED 731F                <1>   jnb check_status_3
   191 000000EF 75F8                <1>   jnz check_status_1
   192                              <1> 
   193                              <1> wait_for_data:
   194 000000F1 E408                <1>   in al,8                   ; read status
   195 000000F3 20D8                <1>   and al,bl                 ; 96h
   196 000000F5 74FA                <1>   jz wait_for_data
   197                              <1> 
   198                              <1> store_byte_1:
   199 000000F7 E40E                <1>   in al,0Eh
   200 000000F9 AA                  <1>   stosb
   201                              <1> 
   202                              <1> check_status_2:
   203 000000FA E408                <1>   in al,8                   ; read status
   204 000000FC 48                  <1>   dec ax                    ; status--
   205 000000FD 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   206 000000FF 38F8                <1>   cmp al, bh                ; bh=2
   207 00000101 750B                <1>   jnz check_status_3        ; if (status==1) 
   208                              <1> 
   209                              <1> store_byte_2:
   210 00000103 E40E                <1>   in al,0Eh  
   211 00000105 AA                  <1>   stosb
   212                              <1> 
   213                              <1> check_status_4:
   214 00000106 E408                <1>   in al,8                   ; read status
   215 00000108 38F8                <1>   cmp al, bh                ; bh=2
   216 0000010A 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   217 0000010C EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   218                              <1> 
   219                              <1> ; ───────────────────────────────────────────────────────────────────────────
   220                              <1> 
   221                              <1> check_status_3:
   222 0000010E E408                <1>   in al, 8                  ; read status
   223 00000110 A81C                <1>   test al, 1Ch              ; 00011100
   224 00000112 7402                <1>   jz while_sectors
   225 00000114 EBBD                <1>   jmp read_sector
   226                              <1> 
   227                              <1> ; ───────────────────────────────────────────────────────────────────────────
   228                              <1> 
   229                              <1> while_sectors:
   230 00000116 E80F00              <1>   call progress_bar
   231 00000119 E299                <1>   loop next_sector
   232                              <1> 
   233                              <1> done_reading:
   234 0000011B 0E                  <1>   push cs
   235 0000011C 17                  <1>   pop ss
   236 0000011D BC0000              <1>   mov sp,0
   237 00000120 E82600              <1>   call clear_green
   238 00000123 0E                  <1>   push cs
   239 00000124 1F                  <1>   pop ds
   240 00000125 E9AC01              <1>   jmp setup
   241                              <1> 
   242                              <1> ; ───────────────────────────────────────────────────────────────────────────
   243                              <1> 
   244                              <1> progress_bar:
   245                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   246 00000128 52                  <1>   push dx
   247 00000129 53                  <1>   push bx
   248 0000012A 31D2                <1>   xor dx,dx
   249 0000012C B81E00              <1>   mov ax,BAR_WIDTH
   250 0000012F BB2800              <1>   mov bx,NUM_SECTORS    
   251 00000132 F7E1                <1>   mul cx
   252 00000134 F7F3                <1>   div bx
   253 00000136 5B                  <1>   pop bx
   254 00000137 5A                  <1>   pop dx
   255 00000138 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   256 0000013A D1E6                <1>   shl si,1                  ; *=2
   257 0000013C D1E6                <1>   shl si,1                  ; *=2  
   258 0000013E BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   259 00000141 29F5                <1>   sub bp,si
   260 00000143 3EC64600FF          <1>   mov byte [ds:bp],-1
   261 00000148 C3                  <1>   ret
   262                              <1> 
   263                              <1> ; clear_red:
   264                              <1> ;   mov ax,RED
   265                              <1> ;   call clear_channel
   266                              <1> ;   ret
   267                              <1> 
   268                              <1> clear_green:
   269 00000149 B8001C              <1>   mov ax,GREEN
   270 0000014C E80100              <1>   call clear_channel
   271 0000014F C3                  <1>   ret
   272                              <1> 
   273                              <1> ; clear_blue:
   274                              <1> ;   mov ax,BLUE
   275                              <1> ;   call clear_channel
   276                              <1> ;   ret
   277                              <1> 
   278                              <1> ; clear_screen:
   279                              <1> ;   call clear_red
   280                              <1> ;   call clear_green
   281                              <1> ;   call clear_blue
   282                              <1> ;   ret
   283                              <1> 
   284                              <1> clear_channel:
   285 00000150 8EC0                <1>   mov es,ax
   286 00000152 B9201C              <1>   mov cx,COLS*ROWS*2
   287 00000155 31FF                <1>   xor di,di
   288 00000157 31C0                <1>   xor ax,ax
   289 00000159 F3AB                <1>   rep stosw         ; clear screen
   290 0000015B C3                  <1>   ret
   291                              <1> 
   292                              <1> ; ───────────────────────────────────────────────────────────────────────────
   293                              <1> 
   294                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   295                              <1>   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   296                              <1>   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   297                              <1>   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   298                              <1> 
   299 0000015C 1E                  <1>   push ds
   300 0000015D 06                  <1>   push es
   301                              <1> 
   302 0000015E 50                  <1>   push ax
   303 0000015F 50                  <1>   push ax
   304 00000160 B8001C              <1>   mov ax,GREEN
   305 00000163 8EC0                <1>   mov es,ax
   306 00000165 B800FF              <1>   mov ax,FONT
   307 00000168 8ED8                <1>   mov ds,ax
   308 0000016A 58                  <1>   pop ax
   309 0000016B B408                <1>   mov ah,8
   310 0000016D F6E4                <1>   mul ah        ; ax=al*ah
   311 0000016F 89C6                <1>   mov si,ax
   312 00000171 A5                  <1>   movsw
   313 00000172 A5                  <1>   movsw
   314 00000173 81C71C01            <1>   add di,0x11c
   315 00000177 A5                  <1>   movsw
   316 00000178 A5                  <1>   movsw
   317 00000179 BB2001              <1>   mov bx,288
   318 0000017C 29DF                <1>   sub di,bx
   319                              <1> 
   320                              <1>   ; row snap
   321 0000017E 31D2                <1>   xor dx,dx
   322 00000180 89F8                <1>   mov ax,di
   323 00000182 F7F3                <1>   div bx
   324 00000184 83FA00              <1>   cmp dx,0
   325 00000187 7523                <1>   jne .return
   326 00000189 01DF                <1>   add di,bx
   327                              <1> 
   328                              <1>   ; wrap to top
   329 0000018B 81FF4038            <1>   cmp di,14400   ; dit later oplossen met cursor positie
   330 0000018F 721B                <1>   jb .return
   331                              <1>   ; xor di,di      ; move to left top. change later to scroll
   332                              <1> 
   333                              <1>   ; TODO: call scroll_down
   334 00000191 57                  <1>   push di
   335 00000192 51                  <1>   push cx
   336 00000193 B9001B              <1>   mov cx,4*72*24
   337 00000196 B80000              <1>   mov ax,0
   338 00000199 F3AB                <1>   rep stosw
   339 0000019B 59                  <1>   pop cx
   340 0000019C 5F                  <1>   pop di
   341                              <1> 
   342                              <1>   ; TODO: clear last line
   343 0000019D 29DF                <1>   sub di,bx
   344 0000019F 29DF                <1>   sub di,bx
   345 000001A1 57                  <1>   push di
   346 000001A2 51                  <1>   push cx
   347 000001A3 B9201C              <1>   mov cx,COLS*ROWS*2
   348 000001A6 31C0                <1>   xor ax,ax
   349 000001A8 F3AB                <1>   rep stosw         ; clear screen
   350 000001AA 59                  <1>   pop cx
   351 000001AB 5F                  <1>   pop di
   352                              <1> 
   353                              <1> 
   354                              <1> 
   355                              <1> .return
   356 000001AC 58                  <1>   pop ax
   357 000001AD 07                  <1>   pop es
   358 000001AE 1F                  <1>   pop ds
   359 000001AF C3                  <1>   ret
   360                              <1> 
   361                              <1> ; ───────────────────────────────────────────────────────────────────────────
   362                              <1> 
   363                              <1> write_string:
   364 000001B0 2E8A07              <1>   mov al,[cs:bx]
   365 000001B3 43                  <1>   inc bx
   366 000001B4 08C0                <1>   or al,al
   367 000001B6 7405                <1>   jz .return
   368 000001B8 E8A1FF              <1>   call write_char
   369 000001BB EBF3                <1>   jmp short write_string
   370                              <1> .return
   371 000001BD C3                  <1>   ret
   372                              <1> 
   373                              <1> ; ───────────────────────────────────────────────────────────────────────────
   374                              <1> 
   375                              <1> write_binary_byte:    ; input AL
   376 000001BE 50                  <1>   push ax
   377 000001BF 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   378 000001C1 B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   379                              <1> .lp:
   380 000001C4 D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   381 000001C6 B80000              <1>   mov ax, 0           ; AH leegmaken
   382 000001C9 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   383 000001CB 51                  <1>   push cx             ; CX opslaan
   384 000001CC E88DFF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   385 000001CF 59                  <1>   pop cx              ; CX herstellen
   386 000001D0 E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   387 000001D2 58                  <1>   pop ax
   388 000001D3 C3                  <1>   ret
   389                              <1> 
   390                              <1> ; ───────────────────────────────────────────────────────────────────────────
   391                              <1> 
   392                              <1> write_binary_word:    ; input AX
   393 000001D4 50                  <1>   push ax
   394 000001D5 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   395 000001D6 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   396 000001D8 B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   397                              <1> .lp:
   398 000001DB D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   399 000001DD B80000              <1>   mov ax, 0          ; AH leegmaken
   400 000001E0 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   401 000001E2 51                  <1>   push cx            ; CX opslaan
   402 000001E3 E876FF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   403 000001E6 59                  <1>   pop cx             ; CX herstellen
   404 000001E7 E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   405 000001E9 5A                  <1>   pop dx             ; DX herstellen
   406 000001EA 58                  <1>   pop ax
   407 000001EB C3                  <1>   ret
   408                              <1> 
   409                              <1> ; ───────────────────────────────────────────────────────────────────────────
   410                              <1> 
   411                              <1> write_number_word:
   412 000001EC 50                  <1>     push ax
   413 000001ED 52                  <1>     push dx
   414 000001EE 31D2                <1>     xor dx,dx
   415 000001F0 52                  <1>     push dx ;high byte is zero
   416 000001F1 31D2                <1> .clp xor dx,dx
   417 000001F3 2EF736[0F02]        <1>     cs div word [.base]
   418 000001F8 92                  <1>     xchg ax,dx
   419 000001F9 05300E              <1>     add ax,0xe30
   420 000001FC 50                  <1>     push ax
   421 000001FD 92                  <1>     xchg ax,dx
   422 000001FE 09C0                <1>     or ax,ax
   423 00000200 75EF                <1>     jnz .clp
   424 00000202 58                  <1> .dlp pop ax
   425 00000203 08E4                <1>     or ah,ah
   426 00000205 7405                <1>     jz .done
   427 00000207 E852FF              <1>     call write_char
   428 0000020A EBF6                <1>     jmp short .dlp
   429 0000020C 5A                  <1> .done pop dx
   430 0000020D 58                  <1>     pop ax
   431 0000020E C3                  <1>     ret
   432 0000020F 0A00                <1> .base dw 10
   433                              <1> 
   434                              <1> ; ───────────────────────────────────────────────────────────────────────────
   435                              <1> 
   436                              <1> write_signed_number_word:    
   437 00000211 09C0                <1>     or ax,ax
   438 00000213 790A                <1>     jns .write_return        ; if >0 write and return
   439 00000215 50                  <1>     push ax
   440 00000216 B82D00              <1>     mov ax,'-'
   441 00000219 E840FF              <1>     call write_char
   442 0000021C 58                  <1>     pop ax
   443 0000021D F7D8                <1>     neg ax                   ; destroys ax when negative
   444                              <1> .write_return:
   445 0000021F E8CAFF              <1>     call write_number_word
   446 00000222 C3                  <1>     ret
   447                              <1> 
   448                              <1> ; ───────────────────────────────────────────────────────────────────────────
   449                              <1> 
   450                              <1> check_keys:
   451 00000223 E43A                <1>   in al,0x3a        ; get keyboard status
   452 00000225 88C4                <1>   mov ah,al
   453 00000227 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   454 00000229 2EA2[0500]          <1>   mov [cs:key.ctrl],al
   455 0000022D F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   456 00000230 7410                <1>   jz .return
   457 00000232 E438                <1>   in al,0x38        ; get data byte from keyboard  
   458 00000234 2EA2[0400]          <1>   mov [cs:key.code],al
   459 00000238 B037                <1>   mov al,0x37
   460 0000023A E63A                <1>   out 0x3a,al       ; drop key?  
   461 0000023C 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   462 0000023E 2EA1[0400]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   463 00000242 C3                  <1> .return ret
   464                              <1> 
   465                              <1> 
   466                              <1> 
   467                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   468                              <1> ;   ret
   469                              <1> 
   470                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   471                              <1> 
   472                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   473                              <1> ; much faster and simpler on the grid than off the grid
   474                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   475                              <1> 
   476                              <1> 
   477                              <1> ; wide font by stretching the font horizontally using bitshift
   478                              <1> 
   479                              <1> 
   480                              <1> ; fill_white:
   481                              <1> ;   mov ax,0xffff
   482                              <1> ;   call fill_red
   483                              <1> ;   call fill_green
   484                              <1> ;   call fill_blue
   485                              <1> ;   ret
   486                              <1> 
   487                              <1> ; fill_pink:
   488                              <1> ;   mov ax,0xffff
   489                              <1> ;   call fill_red
   490                              <1> ;   mov ah,0b01010101
   491                              <1> ;   mov al,0b10101010
   492                              <1> ;   call fill_green
   493                              <1> ;   call fill_blue
   494                              <1> ;   ret
   495                              <1> 
   496                              <1> ; fill_pink2:
   497                              <1> ;   mov ax,0xffff
   498                              <1> ;   call fill_red
   499                              <1> ;   mov ah,0b11001100
   500                              <1> ;   mov al,0b00110011
   501                              <1> ;   call fill_green
   502                              <1> ;   call fill_blue
   503                              <1> ;   ret
   504                              <1> 
   505                              <1> ; fill_pink3:
   506                              <1> ;   mov ax,0xffff
   507                              <1> ;   call fill_red
   508                              <1> ;   mov ah,0b00010001
   509                              <1> ;   mov al,0b01000100
   510                              <1> ;   call fill_green
   511                              <1> ;   call fill_blue
   512                              <1> ;   ret
   513                              <1> 
   514                              <1> ; fill_pink4:
   515                              <1> ;   mov ax,0xffff
   516                              <1> ;   call fill_red
   517                              <1> ;   mov ah,0b11110111
   518                              <1> ;   mov al,0b01111111
   519                              <1> ;   call fill_green
   520                              <1> ;   call fill_blue
   521                              <1> ;   ret
   522                              <1> 
   523                              <1> ; fill_red:
   524                              <1> ;   mov bx,RED
   525                              <1> ;   call fill_channel
   526                              <1> ;   ret
   527                              <1> ; fill_green:
   528                              <1> ;   mov bx,GREEN
   529                              <1> ;   call fill_channel
   530                              <1> ;   ret
   531                              <1> ; fill_blue:
   532                              <1> ;   mov bx,BLUE
   533                              <1> ;   call fill_channel
   534                              <1> ;   ret
   535                              <1> 
   536                              <1> ; fill_channel: ;ax=pattern
   537                              <1> ;   mov es,bx
   538                              <1> ;   mov cx,COLS*ROWS*2
   539                              <1> ;   xor di,di
   540                              <1> ;   rep stosw
   541                              <1> ;   ret
   542                              <1> 
   543                              <1> ; ───────────────────────────────────────────────────────────────────────────
   544                              <1> 
   545                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   546                              <1> ;   push bx
   547                              <1> ;   push di
   548                              <1> ;   mov es,ax
   549                              <1> ;   xor cx,cx
   550                              <1> ;   mov cl,bh        ; rows (bl)
   551                              <1> ; .rows_loop:
   552                              <1> ;   push cx
   553                              <1> ;   xor cx,cx
   554                              <1> ;   mov cl,bl        ; cols (bh)
   555                              <1> ; .cols_loop:
   556                              <1> ;   mov ax,0
   557                              <1> ;   stosw
   558                              <1> ;   stosw
   559                              <1> ;   loop .cols_loop
   560                              <1> ;   add di,COLS*4    ; one row down
   561                              <1> ;   mov ah,0
   562                              <1> ;   mov al,bl
   563                              <1> ;   times 2 shl ax,1
   564                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   565                              <1> ;   pop cx
   566                              <1> ;   loop .rows_loop
   567                              <1> ;   pop di
   568                              <1> ;   pop bx
   569                              <1> ;   ret
   570                              <1> 
   571                              <1> ; ───────────────────────────────────────────────────────────────────────────
   572                              <1> 
   573                              <1> ; fill_rect_black: 
   574                              <1> ;   mov ax,RED
   575                              <1> ;   call clear_area
   576                              <1> ;   mov ax,GREEN
   577                              <1> ;   call clear_area
   578                              <1> ;   mov ax,BLUE
   579                              <1> ;   call clear_area
   580                              <1> ;   ret
   581                              <1> 
   582                              <1> ; ───────────────────────────────────────────────────────────────────────────
   583                              <1> 
   584                              <1> draw_spr:
   585 00000243 8B1C                <1>   mov bx,[si]
   586 00000245 46<rep 2h>          <1>   times 2 inc si
   587                              <1> draw_pic:
   588 00000247 B800F0              <1>   mov ax, RED
   589 0000024A E80D00              <1>   call draw_channel
   590 0000024D B8001C              <1>   mov ax, GREEN
   591 00000250 E80700              <1>   call draw_channel
   592 00000253 B800F4              <1>   mov ax, BLUE
   593 00000256 E80100              <1>   call draw_channel
   594 00000259 C3                  <1>   ret
   595                              <1> 
   596                              <1> ; ───────────────────────────────────────────────────────────────────────────
   597                              <1> 
   598                              <1> draw_channel:
   599 0000025A 57                  <1>   push di
   600 0000025B 8EC0                <1>   mov es,ax
   601 0000025D 31C9                <1>   xor cx,cx
   602 0000025F 88F9                <1>   mov cl,bh        ; rows (bl)
   603                              <1> .rows_loop:
   604 00000261 51                  <1>   push cx
   605 00000262 31C9                <1>   xor cx,cx
   606 00000264 88D9                <1>   mov cl,bl        ; cols (bh)
   607                              <1> .cols_loop:
   608 00000266 A5                  <1>   movsw
   609 00000267 A5                  <1>   movsw
   610 00000268 E2FC                <1>   loop .cols_loop
   611 0000026A 81C72001            <1>   add di,COLS*4    ; one row down
   612 0000026E B400                <1>   mov ah,0
   613 00000270 88D8                <1>   mov al,bl
   614 00000272 D1E0<rep 2h>        <1>   times 2 shl ax,1
   615 00000276 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   616 00000278 59                  <1>   pop cx
   617 00000279 E2E6                <1>   loop .rows_loop
   618 0000027B 5F                  <1>   pop di
   619 0000027C C3                  <1>   ret
   620                              <1> 
   621                              <1> ; ───────────────────────────────────────────────────────────────────────────
   622                              <1> 
   623                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   624 0000027D B89000              <1>   mov ax,144      ; 2*72 cols
   625 00000280 F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   626 00000282 D1E0                <1>   shl ax,1        ; verdubbel AX
   627 00000284 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   628 00000286 D0E3                <1>   shl bl,1        ; bl*=2
   629 00000288 D0E3                <1>   shl bl,1        ; bl*=2
   630 0000028A B700                <1>   mov bh,0
   631 0000028C 01DF                <1>   add di,bx       ; di+=bl
   632 0000028E C3                  <1>   ret
   633                              <1> 
   634                              <1> ; ───────────────────────────────────────────────────────────────────────────
   635                              <1> 
   636                              <1> calc_di_from_cursor:  ; input cursor, output di
   637 0000028F A1[0200]            <1>   mov ax,[cursor] 
   638 00000292 2D0101              <1>   sub ax,0x0101   ; cursor is 1 based
   639 00000295 93                  <1>   xchg ax,bx      ; bx=ax
   640 00000296 B89000              <1>   mov ax,144      ; 2*72 cols
   641 00000299 F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   642 0000029B D1E0                <1>   shl ax,1        ; verdubbel AX
   643 0000029D D1E0                <1>   shl ax,1        ; verdubbel AX
   644 0000029F 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   645 000002A1 D0E3                <1>   shl bl,1        ; bl*=2
   646 000002A3 D0E3                <1>   shl bl,1        ; bl*=2
   647 000002A5 B700                <1>   mov bh,0
   648 000002A7 01DF                <1>   add di,bx       ; di+=bl
   649 000002A9 C3                  <1>   ret
   650                              <1> 
   651                              <1> 
   652                              <1> 
   653                              <1> 
   654                              <1> ; als je cursor gebruikt is dit missch niet nodig.
   655                              <1> row_snap:  ; this code detects if DI is in between rows. When DI goes to the next half row it converts it to a whole row.
   656 000002AA 50                  <1>   push ax
   657 000002AB 53                  <1>   push bx
   658 000002AC 52                  <1>   push dx
   659 000002AD BB2001              <1>   mov bx,288
   660 000002B0 89F8                <1>   mov ax,di
   661 000002B2 99                  <1>   cwd ; xor dx,dx
   662 000002B3 F7F3                <1>   div bx
   663 000002B5 7B02                <1>   jnp .done  ; if ax%288==0 
   664 000002B7 01DF                <1>   add di,bx
   665                              <1>   .done
   666                              <1>   ; add di,dx
   667 000002B9 5A                  <1>   pop dx
   668 000002BA 5B                  <1>   pop bx
   669 000002BB 58                  <1>   pop ax
   670 000002BC C3                  <1>   ret
   671                              <1> 
   672                              <1> 
   673                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   674                              <1> 
   675                              <1> ; calc_di_from_cursor_index:  ; index is cursor index from 0 tot 72*25
   676                              <1> ;   push ax
   677                              <1> ;   push bx
   678                              <1> ;   push dx
   679                              <1> ;   xor dx,dx
   680                              <1> ;   mov ax,[cursor.index]
   681                              <1> ;   mov bx,72
   682                              <1> ;   div bx       ; ax=rows
   683                              <1> ;   push dx      ; dx=cols
   684                              <1> ;   xor dx,dx    ; clear dx for multiplication
   685                              <1> ;   mov bx,576
   686                              <1> ;   mul bx       ; ax contains DI position for row
   687                              <1> ;   mov di,ax
   688                              <1> ;   pop ax       ; ax now contains cols
   689                              <1> ;   shl ax,1     ; *=2
   690                              <1> ;   shl ax,1     ; *=2
   691                              <1> ;   add di,ax
   692                              <1> ;   pop dx
   693                              <1> ;   pop bx
   694                              <1> ;   pop ax
   695                              <1> ;   ret
   696                              <1> 
   697                              <1> ; ───────────────────────────────────────────────────────────────────────────
   698                              <1> 
   699                              <1> 
   700                              <1> ; set_cursor:
   701                              <1> ; cursor_next_char
   702                              <1> 
   703                              <1> 
   704                              <1> 
   705                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   706                              <1> 
     2                                  ; %include "atan.asm"
     3                                  
     4                                  ship:
     5                                   .pos:
     6 000002BD 0090                     .pos.x: dw 73728/2
     7 000002BF D06B                     .pos.y: dw 51200/2 + 2000
     8                                   .vel: 
     9 000002C1 F6FF                     .vel.x: dw -10
    10 000002C3 0000                     .vel.y: dw 0
    11 000002C5 0000                     .vel.flags: dw 0
    12                                   .acc:
    13 000002C7 0000                     .acc.x: dw 0
    14 000002C9 0000                     .acc.y: dw 0
    15                                   .forces:
    16 000002CB 0000                     .forces.x: dw 0
    17 000002CD 0000                     .forces.y: dw 0
    18 000002CF 0000                     .angle: dw 0
    19 000002D1 0000                     .prev_di: dw 0
    20                                  
    21 000002D3 02                      color: db Color.G
    22                                  
    23                                  
    24                                  ;kan ik een generieke cursor_next maken die de waarde 
    25                                  ;van DI opvraagd en deze verhoogt
    26                                  ;en als de cursor tussen twee regels staat 
    27                                  ;deze verhoogd met 288
    28                                  
    29                                  ; en als de waarde van DI boven de max uitkomt dat
    30                                  ; er dan gescrollt wordt en DI wordt verplaatst naar
    31                                  ; het begin van de regel
    32                                  
    33                                  ; en alles heel lightweight?
    34                                  
    35                                  
    36                                  setup:
    37                                    ; mov di,4*72 + 4*10
    38                                    ; call row_snap
    39                                    ; mov ax,12345
    40                                    ; call write_number_word  
    41                                  
    42                                    ; mov word [cursor],0x0208
    43                                  
    44                                    ; ; mov byte [cursor.col],8
    45                                    ; ; mov byte [cursor.row],2
    46                                  
    47                                    ; inc byte [cursor.col]
    48                                    ; push word [cursor]
    49                                    ; pop word [cursor]
    50                                  
    51                                    ; call calc_di_from_cursor
    52                                    set_cursor 1,1 ; 1,72
    49                              <1> 
    50 000002D4 BF0000              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
    53 000002D7 B9F401                    mov cx,500
    54                                    .lp:
    55 000002DA 89C8                        mov ax,cx
    56 000002DC E80DFF                      call write_number_word
    57 000002DF B020                        mov al,' '
    58 000002E1 E878FE                      call write_char
    59 000002E4 E2F4                        loop .lp
    60                                  
    61 000002E6 F4                        hlt
    62                                  
    63                                    ; mov word [cursor.index],36
    64                                    ; call calc_di_from_cursor_index
    65                                  
    66                                    
    67                                    ; hlt
    68                                  
    69                                    ; ; mov bh,al
    70                                    ; ; mov bl,dl
    71                                  
    72                                  
    73                                    ; ; call calc_di_from_bx
    74                                  
    75                                    
    76                                    ; ; xor di,di
    77                                    ; ; mov ax,cx
    78                                    ; ; call write_number_word
    79                                    ; mov al,'x'
    80                                    ; call write_char
    81                                  
    82                                    ; inc word [cursor.index]
    83                                  
    84                                    ; ; print "   "
    85                                  
    86                                    ; loop .lp
    87                                  
    88                                  
    89                                    ; set_cursor 2,5
    90                                    ; print "atan(426)="
    91                                    ; mov ax,426
    92                                    ; call atan
    93                                    ; call write_number_word
    94                                  
    95                                    ; mov cx,426
    96                                    ; mov ax,12321        ; 12321 = 111*111 (squared scale)
    97                                    ; xor dx,dx           ; dx=0 (prevent overflow) 
    98                                    ; idiv cx             ; ax/=z
    99                                    ; call write_number_word
   100                                  
   101 000002E7 F4                        hlt
   102                                  
   103                                  
   104                                    ; xor bp,bp
   105                                    ; jmp draw
   106                                  
   107                                  ; ───────────────────────────────────────────────────────────────────────────
   108                                  
   109                                  ; vec_mult:   ; cx scalar, ax=x, bx=y
   110                                    
   111                                  FRICTION equ 94
   112                                  
   113                                  update_ship:
   114                                    
   115                                    ; x+=vx
   116 000002E8 A1[BD02]                  mov ax,[ship.pos.x]       ; 0..73728  (65536)
   117 000002EB 0306[C102]                add ax,[ship.vel.x]
   118 000002EF A3[BD02]                  mov [ship.pos.x],ax
   119                                  
   120                                    ; y+=vy
   121 000002F2 A1[BF02]                  mov ax,[ship.pos.y]       ; 0..51200  (=1024*50)
   122 000002F5 0306[C302]                add ax,[ship.vel.y]
   123 000002F9 A3[BF02]                  mov [ship.pos.y],ax
   124                                  
   125                                    ; vx*=98%
   126 000002FC A1[C102]                  mov ax, [ship.vel.x]
   127 000002FF 99                        cwd                 ; Convert word to double word (sign-extend AX into DX)
   128 00000300 B95E00                    mov cx, FRICTION
   129 00000303 F7E9                      imul cx             ; Signed multiplication
   130 00000305 B96400                    mov cx, 100
   131 00000308 F7F9                      idiv cx             ; Signed division
   132 0000030A A3[C102]                  mov [ship.vel.x], ax
   133                                  
   134                                    ; vy*=98%
   135 0000030D A1[C302]                  mov ax, [ship.vel.y]
   136 00000310 99                        cwd                 ; Convert word to double word (sign-extend AX into DX)
   137 00000311 B95E00                    mov cx, FRICTION
   138 00000314 F7E9                      imul cx             ; Signed multiplication
   139 00000316 B96400                    mov cx, 100
   140 00000319 F7F9                      idiv cx             ; Signed division
   141 0000031B A3[C302]                  mov [ship.vel.y], ax
   142                                  
   143 0000031E C3                        ret
   144                                  
   145                                  ; ───────────────────────────────────────────────────────────────────────────
   146                                  
   147                                  draw_ship:
   148                                  
   149 0000031F A1[BD02]                  mov ax,[ship.pos.x]
   150 00000322 8B1E[BF02]                mov bx,[ship.pos.y]
   151 00000326 E8FC00                    call world2screen
   152 00000329 E851FF                    call calc_di_from_bx
   153                                  
   154 0000032C 393E[D102]                cmp [ship.prev_di],di
   155 00000330 742B                      je .return
   156                                  
   157                                    ; call world2screen ; ax and bx are already set by pop bx, pop ax
   158                                    ; call calc_di_from_bx
   159                                  
   160 00000332 8B3E[D102]                mov di,[ship.prev_di]
   161                                    
   162 00000336 BB0808                    mov bx,0x0808  ; rows,cols
   163                                    ; call fill_rect_black
   164                                  
   165 00000339 A1[BD02]                  mov ax,[ship.pos.x]
   166 0000033C 8B1E[BF02]                mov bx,[ship.pos.y]
   167 00000340 E8E200                    call world2screen
   168 00000343 E837FF                    call calc_di_from_bx
   169 00000346 893E[D102]                mov [ship.prev_di],di
   170                                  
   171                                  
   172 0000034A BE[3207]                  mov si,img_up
   173 0000034D A1[BD02]                  mov ax,[ship.pos.x]
   174 00000350 8B1E[BF02]                mov bx,[ship.pos.y]
   175 00000354 E8CE00                    call world2screen ; ax and bx are already set by pop bx, pop ax
   176 00000357 E823FF                    call calc_di_from_bx
   177 0000035A E8E6FE                    call draw_spr
   178                                  
   179                                  .return
   180 0000035D C3                        ret
   181                                  
   182                                  ; ───────────────────────────────────────────────────────────────────────────
   183                                  
   184                                  draw:
   185 0000035E 0E                        push cs
   186 0000035F 1F                        pop ds   ; make sure DS is set to CS for data lookups like [ship.pos.x]
   187                                  
   188 00000360 E885FF                    call update_ship
   189 00000363 E8B9FF                    call draw_ship
   190                                  
   191 00000366 E8B400                    call _wait
   192                                  
   193 00000369 45                        inc bp
   194                                  
   195                                    set_cursor 12,45
    49                              <1> 
    50 0000036A BF7019              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   196                                    print "frame: "
    54 0000036D EB08                <1>  jmp %%endstr
    55 0000036F 6672616D653A2000    <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 00000377 BB[6F03]            <1>  mov bx,%%str
    58 0000037A E833FE              <1>  call write_string
   197 0000037D 89E8                      mov ax,bp
   198 0000037F E86AFE                    call write_number_word     ; draw frame counter
   199                                    print "  "
    54 00000382 EB03                <1>  jmp %%endstr
    55 00000384 202000              <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 00000387 BB[8403]            <1>  mov bx,%%str
    58 0000038A E823FE              <1>  call write_string
   200                                  
   201                                    set_cursor 13,45
    49                              <1> 
    50 0000038D BFB01B              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   202                                    print "vx: "
    54 00000390 EB05                <1>  jmp %%endstr
    55 00000392 76783A2000          <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 00000397 BB[9203]            <1>  mov bx,%%str
    58 0000039A E813FE              <1>  call write_string
   203 0000039D A1[C102]                  mov ax,[ship.vel.x]  
   204 000003A0 E86EFE                    call write_signed_number_word
   205                                    print "  "
    54 000003A3 EB03                <1>  jmp %%endstr
    55 000003A5 202000              <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000003A8 BB[A503]            <1>  mov bx,%%str
    58 000003AB E802FE              <1>  call write_string
   206                                  
   207                                    set_cursor 14,45
    49                              <1> 
    50 000003AE BFF01D              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   208                                    print "vy: "
    54 000003B1 EB05                <1>  jmp %%endstr
    55 000003B3 76793A2000          <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000003B8 BB[B303]            <1>  mov bx,%%str
    58 000003BB E8F2FD              <1>  call write_string
   209 000003BE A1[C302]                  mov ax,[ship.vel.y]
   210 000003C1 E84DFE                    call write_signed_number_word     ; draw vy
   211                                    print "  "
    54 000003C4 EB03                <1>  jmp %%endstr
    55 000003C6 202000              <1>  %%str: db %1,0
    56                              <1>  %%endstr:
    57 000003C9 BB[C603]            <1>  mov bx,%%str
    58 000003CC E8E1FD              <1>  call write_string
   212                                  
   213 000003CF E851FE                    call check_keys
   214 000003D2 7502                      jnz on_key
   215                                    ;else
   216 000003D4 EB88                      jmp draw          ; this code is only getting called when no key is pressed
   217                                  
   218                                  ; ───────────────────────────────────────────────────────────────────────────
   219                                  
   220                                  on_key:
   221                                    set_cursor 2,10
    49                              <1> 
    50 000003D6 BF6402              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   222 000003D9 A1[0400]                  mov ax,[key]
   223 000003DC E8F5FD                    call write_binary_word
   224 000003DF 83F877                    cmp ax,'w'
   225 000003E2 7412                      je on_key_w
   226 000003E4 83F861                    cmp ax,'a'
   227 000003E7 7415                      je on_key_a
   228 000003E9 83F873                    cmp ax,'s'
   229 000003EC 7418                      je on_key_s
   230 000003EE 83F864                    cmp ax,'d'
   231 000003F1 741B                      je on_key_d
   232                                  .done
   233 000003F3 E968FF                    jmp draw  ; no ret here because onkey is called by jnz
   234                                  
   235                                  
   236                                  STEP equ 500
   237                                  
   238                                  ; ───────────────────────────────────────────────────────────────────────────
   239                                  
   240                                  on_key_w:
   241 000003F6 812E[C302]F401            sub word [ship.vel.y], STEP
   242 000003FC EBF5                      jmp on_key.done
   243                                  
   244                                  ; ───────────────────────────────────────────────────────────────────────────
   245                                  
   246                                  on_key_a:
   247 000003FE 812E[C102]F401            sub word [ship.vel.x], STEP
   248 00000404 EBED                      jmp on_key.done
   249                                  
   250                                  ; ───────────────────────────────────────────────────────────────────────────
   251                                  
   252                                  on_key_s:
   253 00000406 8106[C302]F401            add word [ship.vel.y], STEP
   254 0000040C EBE5                      jmp on_key.done
   255                                  
   256                                  ; ───────────────────────────────────────────────────────────────────────────
   257                                  
   258                                  on_key_d:
   259 0000040E 8106[C102]F401            add word [ship.vel.x], STEP
   260 00000414 EBDD                      jmp on_key.done
   261                                  
   262                                  ; ───────────────────────────────────────────────────────────────────────────
   263                                  
   264                                  print_msg:
   265                                    set_cursor 1,10
    49                              <1> 
    50 00000416 BF2400              <1>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   266 00000419 E894FD                    call write_string
   267 0000041C C3                        ret
   268                                  
   269                                  ; ───────────────────────────────────────────────────────────────────────────
   270                                  
   271                                  _wait:
   272                                    DELAY EQU 250
   273 0000041D B9FA00                    mov cx,DELAY
   274 00000420 D40A                      .lp aam
   275 00000422 E2FC                      loop .lp
   276 00000424 C3                        ret
   277                                  
   278                                  ; ───────────────────────────────────────────────────────────────────────────
   279                                  
   280                                  world2screen:  ; input (ax,bx) = (world.x, world.y)   ; screen (row,col)
   281                                    ; WORLD:
   282                                    ;   0..73728  (65536) -> col
   283                                    ;   0..51200  (=1024*50) -> row
   284                                    ; SCREEN (ROW,COL):
   285                                    ;   0..49 (row)
   286                                    ;   0..71 (col)
   287 00000425 B10A                      mov cl,10
   288 00000427 D3EB                      shr bx,cl   ; //bl=row 0..49
   289 00000429 D3E8                      shr ax,cl   ; 
   290 0000042B 88C7                      mov bh,al   ; //bh=col 0..71
   291 0000042D 86DF                      xchg bh,bl
   292 0000042F C3                        ret
   293                                  
   294                                  ; ───────────────────────────────────────────────────────────────────────────
   295                                  
   296                                  ; FIXME
   297 00000430 <bin 302h>              img_NONE: incbin "data/ship-24.spr"
   298                                  
   299                                  
   300                                  img_up:
   301 00000732 <bin 302h>              img1: incbin "data/ship-1.spr" ;up
   302 00000A34 <bin 302h>              img2: incbin "data/ship-2.spr"
   303 00000D36 <bin 302h>              img3: incbin "data/ship-3.spr"
   304                                  img_up_right:
   305 00001038 <bin 302h>              img4: incbin "data/ship-4.spr" ;up-right
   306 0000133A <bin 302h>              img5: incbin "data/ship-5.spr"
   307 0000163C <bin 302h>              img6: incbin "data/ship-6.spr"
   308                                  img_right:
   309 0000193E <bin 302h>              img7: incbin "data/ship-7.spr" ;right
   310 00001C40 <bin 302h>              img8: incbin "data/ship-8.spr"
   311 00001F42 <bin 302h>              img9: incbin "data/ship-9.spr"
   312                                  img_down_right:
   313 00002244 <bin 302h>              img10: incbin "data/ship-10.spr" ;down-right
   314 00002546 <bin 302h>              img11: incbin "data/ship-11.spr"
   315 00002848 <bin 302h>              img12: incbin "data/ship-12.spr"
   316                                  img_down:
   317 00002B4A <bin 302h>              img13: incbin "data/ship-13.spr" ;down
   318 00002E4C <bin 302h>              img14: incbin "data/ship-14.spr"
   319 0000314E <bin 302h>              img15: incbin "data/ship-15.spr"
   320                                  img_down_left:
   321 00003450 <bin 302h>              img16: incbin "data/ship-16.spr" ;down-left
   322 00003752 <bin 302h>              img17: incbin "data/ship-17.spr"
   323 00003A54 <bin 302h>              img18: incbin "data/ship-18.spr"
   324                                  img_left:
   325 00003D56 <bin 302h>              img19: incbin "data/ship-19.spr" ;left
   326 00004058 <bin 302h>              img20: incbin "data/ship-20.spr"
   327 0000435A <bin 302h>              img21: incbin "data/ship-21.spr"
   328                                  img_up_left:
   329 0000465C <bin 302h>              img22: incbin "data/ship-22.spr" ;up-left
   330 0000495E <bin 302h>              img23: incbin "data/ship-23.spr"
   331 00004C60 <bin 302h>              img24: incbin "data/ship-24.spr"
   332                                  
   333                                  
   334 00004F62 00<rep 2809Eh>          times (180*1024)-($-$$) db 0
   335                                  
   336                                  
   337                                  
