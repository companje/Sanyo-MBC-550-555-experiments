     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4 00000000 E9C700              <1> jmp boot
     5                              <1> 
     6                              <1> NUM_SECTORS equ 10          ; number of sectors to read
     7                              <1> BAR_WIDTH equ 30
     8                              <1> COLS  equ 72
     9                              <1> ROWS  equ 50
    10                              <1> LINES equ 200
    11                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    12                              <1> RED   equ 0xf000
    13                              <1> GREEN equ 0x1c00
    14                              <1> BLUE  equ 0xf400
    15                              <1> DST   equ 0x38
    16                              <1> XD    equ 4
    17                              <1> YD    equ COLS*XD
    18                              <1> FONT equ 0xFF00
    19                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    20                              <1> Color.R equ 0b100
    21                              <1> Color.G equ 0b010
    22                              <1> Color.B equ 0b001
    23                              <1> Color.W equ 0b111
    24                              <1> Color.C equ 0b011
    25                              <1> Color.M equ 0b101
    26                              <1> Color.Y equ 0b110
    27                              <1> Color.K equ 0b000
    28                              <1> CTRL equ 0b0000100000000000
    29                              <1> KEY_LEFT  equ 0b00011100
    30                              <1> KEY_RIGHT equ 0b00011101
    31                              <1> KEY_UP    equ 0b00011110
    32                              <1> KEY_DOWN  equ 0b00011111
    33                              <1> 
    34                              <1> cursor:
    35 00000003 00                  <1> .col: db 0
    36 00000004 00                  <1> .row: db 0
    37                              <1> 
    38                              <1> key:
    39 00000005 00                  <1>   .code db 0
    40 00000006 00                  <1>   .ctrl db 0
    41                              <1> 
    42                              <1> %macro set_cursor 2
    43                              <1>   ; mov di,%1 * BYTES_PER_ROW + %2 * 4  ; zero based
    44                              <1>   mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4   ; one based
    45                              <1> %endmacro
    46                              <1> 
    47                              <1> %macro print 1
    48                              <1>   push ax
    49                              <1>   push bx
    50                              <1>   push cx
    51                              <1>   push dx
    52                              <1>   jmp %%endstr 
    53                              <1>   %%str: db %1,0
    54                              <1>   %%endstr: 
    55                              <1>   mov bx,%%str
    56                              <1>   call write_string
    57                              <1>   pop dx
    58                              <1>   pop cx
    59                              <1>   pop bx
    60                              <1>   pop ax
    61                              <1> %endmacro
    62                              <1> 
    63                              <1> %macro println 1
    64                              <1>   print %1
    65                              <1>   call new_line
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro print_ax 0
    69                              <1>   call write_signed_number_word
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro print_ax_unsigned 0
    73                              <1>   call write_number_word
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro print_ax_hex 0
    77                              <1>   call write_ax_hex
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro print_ax_bin 0
    81                              <1>   call write_binary_word
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %macro print_char 1
    85                              <1>   push ax
    86                              <1>   mov al,%1
    87                              <1>   call write_char
    88                              <1>   pop ax
    89                              <1> %endmacro
    90                              <1> 
    91                              <1> %macro print_2chars 1
    92                              <1>   push ax
    93                              <1>   mov ax,%1
    94                              <1>   call write_2chars
    95                              <1>   pop ax
    96                              <1> %endmacro
    97                              <1> 
    98                              <1> ; ------------
    99                              <1> ; println
   100                              <1> 
   101                              <1> %macro println_ax 0
   102                              <1>   print_ax
   103                              <1>   call write_5spaces_newline
   104                              <1> %endmacro
   105                              <1> 
   106                              <1> %macro println_ax_unsigned 0
   107                              <1>   print_ax_unsigned
   108                              <1>   call write_5spaces_newline
   109                              <1> %endmacro
   110                              <1> 
   111                              <1> %macro println_ax_hex 0
   112                              <1>   print_ax_hex
   113                              <1>   call write_5spaces_newline
   114                              <1> %endmacro
   115                              <1> 
   116                              <1> %macro println_ax_bin 0
   117                              <1>   print_ax_bin
   118                              <1>   call write_5spaces_newline
   119                              <1> %endmacro
   120                              <1> 
   121                              <1> write_5spaces_newline:
   122 00000007 50                  <1>   push ax
   123 00000008 B82020              <1>   mov ax,"  "
   124 0000000B E80B00              <1>   call write_2chars
   125 0000000E E80800              <1>   call write_2chars
   126 00000011 E8B701              <1>   call write_char
   127 00000014 E8E602              <1>   call new_line
   128 00000017 58                  <1>   pop ax
   129 00000018 C3                  <1>   ret
   130                              <1> 
   131                              <1> write_2chars:
   132 00000019 E8AF01              <1>   call write_char
   133 0000001C 86C4                <1>   xchg ah,al
   134 0000001E E8AA01              <1>   call write_char
   135 00000021 C3                  <1>   ret
   136                              <1> 
   137                              <1> %macro register_interrupt 1
   138                              <1>   mov ax,%1
   139                              <1>   stosw
   140                              <1>   mov ax,cs
   141                              <1>   stosw
   142                              <1> %endmacro
   143                              <1> 
   144                              <1> ; int0: hlt
   145                              <1> ; int1: hlt
   146                              <1> ; int2: hlt
   147                              <1> ; int3: hlt
   148                              <1> ; int4: hlt
   149                              <1> 
   150                              <1> int0:; int0: Division by zero
   151 00000022 FC                  <1>   cld
   152 00000023 B800F4              <1>   mov ax,BLUE
   153 00000026 8EC0                <1>   mov es,ax
   154 00000028 31FF                <1>   xor di,di
   155 0000002A B9201C              <1>   mov cx,7200
   156 0000002D B8FFFF              <1>   mov ax,-1
   157 00000030 F3AB                <1>   rep stosw
   158                              <1>   set_cursor 1,1
    43                              <2> 
    44 00000032 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   159                              <1>   print "Division by zero"
    48 00000035 50                  <2>  push ax
    49 00000036 53                  <2>  push bx
    50 00000037 51                  <2>  push cx
    51 00000038 52                  <2>  push dx
    52 00000039 EB11                <2>  jmp %%endstr
    53 0000003B 4469766973696F6E20- <2>  %%str: db %1,0
    53 00000044 6279207A65726F00    <2>
    54                              <2>  %%endstr:
    55 0000004C BB[3B00]            <2>  mov bx,%%str
    56 0000004F E8B401              <2>  call write_string
    57 00000052 5A                  <2>  pop dx
    58 00000053 59                  <2>  pop cx
    59 00000054 5B                  <2>  pop bx
    60 00000055 58                  <2>  pop ax
   160                              <1>   set_cursor 3,1
    43                              <2> 
    44 00000056 BF8004              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   161 00000059 58                  <1>   pop ax
   162                              <1>   print "IP="
    48 0000005A 50                  <2>  push ax
    49 0000005B 53                  <2>  push bx
    50 0000005C 51                  <2>  push cx
    51 0000005D 52                  <2>  push dx
    52 0000005E EB04                <2>  jmp %%endstr
    53 00000060 49503D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000064 BB[6000]            <2>  mov bx,%%str
    56 00000067 E89C01              <2>  call write_string
    57 0000006A 5A                  <2>  pop dx
    58 0000006B 59                  <2>  pop cx
    59 0000006C 5B                  <2>  pop bx
    60 0000006D 58                  <2>  pop ax
   163                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 0000006E E8A902              <3>  call write_ax_hex
   113 00000071 E893FF              <2>  call write_5spaces_newline
   164 00000074 E88602              <1>   call new_line
   165                              <1>   print "CS="
    48 00000077 50                  <2>  push ax
    49 00000078 53                  <2>  push bx
    50 00000079 51                  <2>  push cx
    51 0000007A 52                  <2>  push dx
    52 0000007B EB04                <2>  jmp %%endstr
    53 0000007D 43533D00            <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 00000081 BB[7D00]            <2>  mov bx,%%str
    56 00000084 E87F01              <2>  call write_string
    57 00000087 5A                  <2>  pop dx
    58 00000088 59                  <2>  pop cx
    59 00000089 5B                  <2>  pop bx
    60 0000008A 58                  <2>  pop ax
   166 0000008B 58                  <1>   pop ax
   167                              <1>   println_ax_hex
   112                              <2>  print_ax_hex
    77 0000008C E88B02              <3>  call write_ax_hex
   113 0000008F E875FF              <2>  call write_5spaces_newline
   168 00000092 E86802              <1>   call new_line
   169                              <1>   print "FLAGS="
    48 00000095 50                  <2>  push ax
    49 00000096 53                  <2>  push bx
    50 00000097 51                  <2>  push cx
    51 00000098 52                  <2>  push dx
    52 00000099 EB07                <2>  jmp %%endstr
    53 0000009B 464C4147533D00      <2>  %%str: db %1,0
    54                              <2>  %%endstr:
    55 000000A2 BB[9B00]            <2>  mov bx,%%str
    56 000000A5 E85E01              <2>  call write_string
    57 000000A8 5A                  <2>  pop dx
    58 000000A9 59                  <2>  pop cx
    59 000000AA 5B                  <2>  pop bx
    60 000000AB 58                  <2>  pop ax
   170 000000AC 58                  <1>   pop ax
   171 000000AD E87E01              <1>   call write_binary_word
   172 000000B0 F4                  <1>   hlt
   173                              <1> 
   174                              <1> int1:; int1: Single step debugging
   175 000000B1 B001                <1>   mov al,1
   176 000000B3 EB0C                <1>   jmp int_msg
   177                              <1> int2:; int2: Non maskable interrupt
   178 000000B5 B002                <1>   mov al,2
   179 000000B7 EB08                <1>   jmp int_msg
   180                              <1> int3:; int3: For one-byte interrupt
   181 000000B9 B003                <1>   mov al,3
   182 000000BB EB04                <1>   jmp int_msg
   183                              <1>   ; push ax
   184                              <1>   ; push bx
   185                              <1>   ; push cx
   186                              <1>   ; push dx
   187                              <1>   ; push si
   188                              <1>   ; push di
   189                              <1>   ; push bp
   190                              <1>   ; push ds
   191                              <1>   ; push es
   192                              <1> 
   193                              <1>   ; ; mov di,10*4
   194                              <1>   ; ; set_cursor 5,5
   195                              <1>   ; xor di,di
   196                              <1>   ; print "int3:"
   197                              <1>   ; ; mov ax,cx
   198                              <1>   ; ; call write_number_word
   199                              <1> 
   200                              <1>   ; pop es
   201                              <1>   ; pop ds
   202                              <1>   ; pop bp
   203                              <1>   ; pop di
   204                              <1>   ; pop si
   205                              <1>   ; pop dx
   206                              <1>   ; pop cx
   207                              <1>   ; pop bx
   208                              <1>   ; pop ax
   209                              <1>   ; iret
   210                              <1> 
   211                              <1> int4:; int4: Signed overflow
   212 000000BD B004                <1>   mov al,4
   213 000000BF EB00                <1>   jmp int_msg
   214                              <1> int_msg:
   215 000000C1 BFF401              <1>   mov di,500
   216                              <1>   ; xor di,di
   217                              <1>   ; mov ax,di
   218                              <1>   ; mov cx,8*72  
   219                              <1>   ; rep stosw
   220                              <1>   ; xor di,di
   221                              <1>   ; push ax
   222                              <1>   ; print "int: "
   223                              <1>   ; pop ax
   224 000000C4 0430                <1>   add al,'0'
   225 000000C6 E80201              <1>   call write_char
   226                              <1>   ; print "      "
   227                              <1>   
   228 000000C9 F4                  <1>   hlt
   229                              <1> 
   230                              <1> boot:
   231 000000CA FA                  <1>   cli
   232 000000CB FC                  <1>   cld
   233 000000CC E8E900              <1>   call clear_green    
   234                              <1> 
   235                              <1>   ; init video      
   236 000000CF B005                <1>   mov al, 5
   237 000000D1 E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
   238                              <1>  
   239                              <1>   ; register interrupts
   240 000000D3 31FF                <1>   xor di,di ; offset 0
   241 000000D5 8EC7                <1>   mov es,di ; segment 0
   242                              <1>   register_interrupt int0
   138 000000D7 B8[2200]            <2>  mov ax,%1
   139 000000DA AB                  <2>  stosw
   140 000000DB 8CC8                <2>  mov ax,cs
   141 000000DD AB                  <2>  stosw
   243                              <1>   register_interrupt int1
   138 000000DE B8[B100]            <2>  mov ax,%1
   139 000000E1 AB                  <2>  stosw
   140 000000E2 8CC8                <2>  mov ax,cs
   141 000000E4 AB                  <2>  stosw
   244                              <1>   register_interrupt int2
   138 000000E5 B8[B500]            <2>  mov ax,%1
   139 000000E8 AB                  <2>  stosw
   140 000000E9 8CC8                <2>  mov ax,cs
   141 000000EB AB                  <2>  stosw
   245                              <1>   register_interrupt int3
   138 000000EC B8[B900]            <2>  mov ax,%1
   139 000000EF AB                  <2>  stosw
   140 000000F0 8CC8                <2>  mov ax,cs
   141 000000F2 AB                  <2>  stosw
   246                              <1>   register_interrupt int4
   138 000000F3 B8[BD00]            <2>  mov ax,%1
   139 000000F6 AB                  <2>  stosw
   140 000000F7 8CC8                <2>  mov ax,cs
   141 000000F9 AB                  <2>  stosw
   247                              <1> 
   248                              <1> 
   249                              <1>   ; init other hardware
   250 000000FA B000                <1>   mov al,0
   251 000000FC E63A                <1>   out 0x3a,al           ; keyboard \force state/
   252 000000FE E63A                <1>   out 0x3a,al           ; keyboard \force state/
   253 00000100 B0FF                <1>   mov al,0xFF
   254 00000102 E63A                <1>   out 0x3a,al           ; keyboard \reset/
   255 00000104 E63A                <1>   out 0x3a,al           ; keyboard \mode/
   256 00000106 B037                <1>   mov al,0x37
   257 00000108 E63A                <1>   out 0x3a,al           ; keyboard \set command
   258                              <1> 
   259 0000010A B8001C              <1>   mov ax,GREEN      
   260 0000010D 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
   261 0000010F B83800              <1>   mov ax,DST                
   262 00000112 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
   263 00000114 BF0000              <1>   mov di,0                  ;
   264 00000117 B200                <1>   mov dl,0                  ; track=0
   265 00000119 B601                <1>   mov dh,1                  ; sector=1
   266 0000011B B90A00              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
   267 0000011E EB0B                <1>   jmp move_head
   268                              <1> 
   269                              <1> ; ───────────────────────────────────────────────────────────────────────────
   270                              <1> 
   271                              <1> next_sector:
   272 00000120 FEC6                <1>   inc dh                    ; sector++
   273 00000122 80FE0A              <1>   cmp dh,10
   274 00000125 7218                <1>   jb read_sector            ; if (dh<9) read_sector
   275 00000127 B601                <1>   mov dh,1
   276 00000129 FEC2                <1>   inc dl                    ; else track++ ; sector=1
   277                              <1> 
   278                              <1> move_head:
   279 0000012B 88D0                <1>   mov al,dl
   280 0000012D E60E                <1>   out 0Eh,al               ; set track number
   281 0000012F B018                <1>   mov al,18h     
   282 00000131 E608                <1>   out 8,al                 ; seek track, load head
   283 00000133 B000                <1>   mov al,0
   284 00000135 E61C                <1>   out 1Ch,al               ; set desired drive/side
   285 00000137 D40A                <1>   aam
   286                              <1> 
   287                              <1> head_moving:
   288 00000139 E408                <1>   in al,8
   289 0000013B A801                <1>   test al,1
   290 0000013D 75FA                <1>   jnz head_moving
   291                              <1> 
   292                              <1> read_sector:
   293 0000013F 88F0                <1>   mov al,dh
   294 00000141 E60C                <1>   out 0Ch,al                ; sector number
   295 00000143 B702                <1>   mov bh,2                  ; 00000010b
   296 00000145 B396                <1>   mov bl,96h                ; 10010110b
   297 00000147 B400                <1>   mov ah,0
   298 00000149 B080                <1>   mov al,80h
   299 0000014B E608                <1>   out 8,al                  ; read sector
   300 0000014D D40A<rep 4h>        <1>   times 4 aam               ; wait
   301                              <1> 
   302                              <1> check_status_1:
   303 00000155 E408                <1>   in al,8                   ; read status
   304 00000157 D0F8                <1>   sar al,1                  ; status/=2
   305 00000159 731F                <1>   jnb check_status_3
   306 0000015B 75F8                <1>   jnz check_status_1
   307                              <1> 
   308                              <1> wait_for_data:
   309 0000015D E408                <1>   in al,8                   ; read status
   310 0000015F 20D8                <1>   and al,bl                 ; 96h
   311 00000161 74FA                <1>   jz wait_for_data
   312                              <1> 
   313                              <1> store_byte_1:
   314 00000163 E40E                <1>   in al,0Eh
   315 00000165 AA                  <1>   stosb
   316                              <1> 
   317                              <1> check_status_2:
   318 00000166 E408                <1>   in al,8                   ; read status
   319 00000168 48                  <1>   dec ax                    ; status--
   320 00000169 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   321 0000016B 38F8                <1>   cmp al, bh                ; bh=2
   322 0000016D 750B                <1>   jnz check_status_3        ; if (status==1) 
   323                              <1> 
   324                              <1> store_byte_2:
   325 0000016F E40E                <1>   in al,0Eh  
   326 00000171 AA                  <1>   stosb
   327                              <1> 
   328                              <1> check_status_4:
   329 00000172 E408                <1>   in al,8                   ; read status
   330 00000174 38F8                <1>   cmp al, bh                ; bh=2
   331 00000176 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   332 00000178 EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   333                              <1> 
   334                              <1> ; ───────────────────────────────────────────────────────────────────────────
   335                              <1> 
   336                              <1> check_status_3:
   337 0000017A E408                <1>   in al, 8                  ; read status
   338 0000017C A81C                <1>   test al, 1Ch              ; 00011100
   339 0000017E 7402                <1>   jz while_sectors
   340 00000180 EBBD                <1>   jmp read_sector
   341                              <1> 
   342                              <1> ; ───────────────────────────────────────────────────────────────────────────
   343                              <1> 
   344                              <1> while_sectors:
   345 00000182 E81200              <1>   call progress_bar
   346 00000185 E299                <1>   loop next_sector
   347                              <1> 
   348                              <1> done_reading:
   349 00000187 0E                  <1>   push cs
   350 00000188 17                  <1>   pop ss
   351 00000189 BC0000              <1>   mov sp,0
   352 0000018C E82900              <1>   call clear_green
   353 0000018F 0E                  <1>   push cs
   354 00000190 1F                  <1>   pop ds
   355                              <1>   set_cursor 1,1 ; nodig?
    43                              <2> 
    44 00000191 BF0000              <2>  mov di,(%1-1) * BYTES_PER_ROW + (%2-1) * 4
   356 00000194 E92202              <1>   jmp setup
   357                              <1> 
   358                              <1> ; ───────────────────────────────────────────────────────────────────────────
   359                              <1> 
   360                              <1> progress_bar:
   361                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   362 00000197 52                  <1>   push dx
   363 00000198 53                  <1>   push bx
   364 00000199 31D2                <1>   xor dx,dx
   365 0000019B B81E00              <1>   mov ax,BAR_WIDTH
   366 0000019E BB0A00              <1>   mov bx,NUM_SECTORS    
   367 000001A1 F7E1                <1>   mul cx
   368 000001A3 F7F3                <1>   div bx
   369 000001A5 5B                  <1>   pop bx
   370 000001A6 5A                  <1>   pop dx
   371 000001A7 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   372 000001A9 D1E6                <1>   shl si,1                  ; *=2
   373 000001AB D1E6                <1>   shl si,1                  ; *=2  
   374 000001AD BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   375 000001B0 29F5                <1>   sub bp,si
   376 000001B2 3EC64600FF          <1>   mov byte [ds:bp],-1
   377 000001B7 C3                  <1>   ret
   378                              <1> 
   379                              <1> ; clear_red:
   380                              <1> ;   mov ax,RED
   381                              <1> ;   call clear_channel
   382                              <1> ;   ret
   383                              <1> 
   384                              <1> clear_green:
   385 000001B8 B8001C              <1>   mov ax,GREEN
   386 000001BB E80100              <1>   call clear_channel
   387 000001BE C3                  <1>   ret
   388                              <1> 
   389                              <1> ; clear_blue:
   390                              <1> ;   mov ax,BLUE
   391                              <1> ;   call clear_channel
   392                              <1> ;   ret
   393                              <1> 
   394                              <1> ; clear_screen:
   395                              <1> ;   call clear_red
   396                              <1> ;   call clear_green
   397                              <1> ;   call clear_blue
   398                              <1> ;   ret
   399                              <1> 
   400                              <1> clear_channel:
   401 000001BF 8EC0                <1>   mov es,ax
   402 000001C1 B9201C              <1>   mov cx,COLS*ROWS*2
   403 000001C4 31FF                <1>   xor di,di
   404 000001C6 31C0                <1>   xor ax,ax
   405 000001C8 F3AB                <1>   rep stosw         ; clear screen
   406 000001CA C3                  <1>   ret
   407                              <1> 
   408                              <1> ; ───────────────────────────────────────────────────────────────────────────
   409                              <1> 
   410                              <1> ; write_char:   ; ds=FONT, es=GREEN, al=charcode
   411                              <1> ;   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   412                              <1> ;   ; je zou de huidige kleur op een adres willen bewaren. nu doet ie alleen maar groen.
   413                              <1> ;   ; deze functie zou ook korter/lichter kunnen/moeten. wellicht twee functies maken. een slimme en een domme snelle..
   414                              <1> 
   415                              <1> ;   push ds
   416                              <1> ;   push es
   417                              <1> ;   push ax
   418                              <1> ;   push bx
   419                              <1> ;   push cx
   420                              <1> 
   421                              <1> ;   push ax
   422                              <1> ;   mov ax,GREEN
   423                              <1> ;   mov es,ax
   424                              <1> ;   mov ax,FONT
   425                              <1> ;   mov ds,ax
   426                              <1> ;   pop ax
   427                              <1> 
   428                              <1> ;   ; mov ax,65*8
   429                              <1> ;   ; mov al,'x'
   430                              <1> ;   mov ah,8
   431                              <1> ;   mul ah        ; ax=al*ah
   432                              <1> 
   433                              <1> ;   mov si,ax
   434                              <1> ;   movsw
   435                              <1> ;   movsw
   436                              <1> ;   add di,0x11c
   437                              <1> ;   movsw
   438                              <1> ;   movsw
   439                              <1> ;   mov bx,288
   440                              <1> ;   sub di,bx
   441                              <1>   
   442                              <1> ;   ; pop ax
   443                              <1> ;   ; pop es
   444                              <1> ;   ; pop ds
   445                              <1> ;   ; ret
   446                              <1> 
   447                              <1> 
   448                              <1> ;   ; row snap
   449                              <1> ;   xor dx,dx
   450                              <1> ;   mov ax,di
   451                              <1> ;   div bx
   452                              <1> ;   cmp dx,0
   453                              <1> ;   jne .return
   454                              <1> ;   add di,bx
   455                              <1> 
   456                              <1> 
   457                              <1> ;   ; wrap to top
   458                              <1> ;   cmp di,14400   ; dit later oplossen met cursor positie
   459                              <1> ;   jb .return
   460                              <1> ;   ; xor di,di      ; move to left top. change later to scroll
   461                              <1> 
   462                              <1> ;   ; TODO: call scroll_down
   463                              <1> ;   ; std
   464                              <1> ;   ; push di
   465                              <1> ;   ; push cx
   466                              <1> ;   ; mov cx,4*72*24
   467                              <1> ;   ; mov ax,0
   468                              <1> ;   ; rep stosw
   469                              <1> ;   ; pop cx
   470                              <1> ;   ; pop di
   471                              <1> ;   ; cld
   472                              <1> 
   473                              <1> ;   ; DONE: clear last line
   474                              <1> ;   sub di,bx
   475                              <1> ;   sub di,bx
   476                              <1> ;   push di
   477                              <1> ;   push cx
   478                              <1> ;   mov cx,COLS*ROWS*2
   479                              <1> ;   xor ax,ax
   480                              <1> ;   rep stosw         ; clear screen
   481                              <1> ;   pop cx
   482                              <1> ;   pop di
   483                              <1> 
   484                              <1> ; .return
   485                              <1> ;   push bx
   486                              <1> ;   push cx
   487                              <1> ;   pop ax
   488                              <1> ;   pop es
   489                              <1> ;   pop ds
   490                              <1> ;   ret
   491                              <1> 
   492                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   493                              <1> 
   494                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   495 000001CB 52                  <1>   push dx
   496 000001CC 1E                  <1>   push ds
   497 000001CD 06                  <1>   push es
   498 000001CE 50                  <1>   push ax
   499 000001CF 53                  <1>   push bx
   500 000001D0 31D2                <1>   xor dx,dx
   501 000001D2 50                  <1>   push ax  ; voor character pop
   502 000001D3 B8001C              <1>   mov ax,GREEN
   503 000001D6 8EC0                <1>   mov es,ax
   504 000001D8 B800FF              <1>   mov ax,FONT
   505 000001DB 8ED8                <1>   mov ds,ax
   506 000001DD 58                  <1>   pop ax
   507 000001DE B408                <1>   mov ah,8
   508 000001E0 F6E4                <1>   mul ah        ; al*=ah
   509 000001E2 89C6                <1>   mov si,ax  
   510                              <1> 
   511 000001E4 A5                  <1>   movsw
   512 000001E5 A5                  <1>   movsw
   513 000001E6 81C71C01            <1>   add di,0x11c
   514 000001EA A5                  <1>   movsw
   515 000001EB A5                  <1>   movsw
   516 000001EC 81EF2001            <1>   sub di,0x120
   517                              <1> 
   518                              <1> 
   519                              <1>   ; cmp di,14400   ; dit later oplossen met cursor positie
   520                              <1>   ; jb .return
   521                              <1>   ; xor di,di      ; move to left top. change later to scroll
   522                              <1> 
   523                              <1>   ; row snap
   524 000001F0 BB2001              <1>   mov bx,288   ; /////////// dit gaf problemen waarsch omdat bx niet gepushed werd
   525 000001F3 31D2                <1>   xor dx,dx
   526 000001F5 89F8                <1>   mov ax,di
   527 000001F7 F7F3                <1>   div bx       ; ///dit ook als BX 0 is
   528 000001F9 83FA00              <1>   cmp dx,0
   529 000001FC 7502                <1>   jne .return
   530 000001FE 01DF                <1>   add di,bx
   531                              <1> 
   532                              <1> .return
   533 00000200 5B                  <1>   pop bx
   534 00000201 58                  <1>   pop ax
   535 00000202 07                  <1>   pop es
   536 00000203 1F                  <1>   pop ds
   537 00000204 5A                  <1>   pop dx
   538 00000205 C3                  <1>   ret
   539                              <1> 
   540                              <1> write_string:
   541 00000206 2E8A07              <1>   mov al,[cs:bx]
   542 00000209 43                  <1>   inc bx
   543 0000020A 08C0                <1>   or al,al
   544 0000020C 7405                <1>   jz .return
   545 0000020E E8BAFF              <1>   call write_char
   546 00000211 EBF3                <1>   jmp short write_string
   547                              <1> .return
   548 00000213 C3                  <1>   ret
   549                              <1> 
   550                              <1> ; ───────────────────────────────────────────────────────────────────────────
   551                              <1> 
   552                              <1> write_binary_byte:    ; input AL
   553 00000214 53                  <1>   push bx
   554 00000215 51                  <1>   push cx
   555 00000216 50                  <1>   push ax
   556 00000217 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   557 00000219 B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   558                              <1> .lp:
   559 0000021C D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   560 0000021E B80000              <1>   mov ax, 0           ; AH leegmaken
   561 00000221 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   562 00000223 51                  <1>   push cx             ; CX opslaan
   563 00000224 E8A4FF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   564 00000227 59                  <1>   pop cx              ; CX herstellen
   565 00000228 E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   566 0000022A 58                  <1>   pop ax
   567 0000022B 59                  <1>   pop cx
   568 0000022C 5B                  <1>   pop bx
   569 0000022D C3                  <1>   ret
   570                              <1> 
   571                              <1> ; ───────────────────────────────────────────────────────────────────────────
   572                              <1> 
   573                              <1> write_binary_word:    ; input AX
   574 0000022E 51                  <1>   push cx
   575 0000022F 50                  <1>   push ax
   576 00000230 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   577 00000231 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   578 00000233 B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   579                              <1> .lp:
   580 00000236 D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   581 00000238 B80000              <1>   mov ax, 0          ; AH leegmaken
   582 0000023B 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   583 0000023D 51                  <1>   push cx            ; CX opslaan
   584 0000023E E88AFF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   585 00000241 59                  <1>   pop cx             ; CX herstellen
   586 00000242 E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   587 00000244 5A                  <1>   pop dx             ; DX herstellen
   588 00000245 58                  <1>   pop ax
   589 00000246 59                  <1>   pop cx
   590 00000247 C3                  <1>   ret
   591                              <1> 
   592                              <1> 
   593                              <1> ; ───────────────────────────────────────────────────────────────────────────
   594                              <1> 
   595                              <1> write_number_word:
   596 00000248 50                  <1>     push ax
   597 00000249 52                  <1>     push dx
   598 0000024A 31D2                <1>     xor dx,dx
   599 0000024C 52                  <1>     push dx ;high byte is zero
   600 0000024D 31D2                <1> .clp xor dx,dx
   601 0000024F 2EF736[6B02]        <1>     cs div word [.base]
   602 00000254 92                  <1>     xchg ax,dx
   603 00000255 05300E              <1>     add ax,0xe30
   604 00000258 50                  <1>     push ax
   605 00000259 92                  <1>     xchg ax,dx
   606 0000025A 09C0                <1>     or ax,ax
   607 0000025C 75EF                <1>     jnz .clp
   608 0000025E 58                  <1> .dlp pop ax
   609 0000025F 08E4                <1>     or ah,ah
   610 00000261 7405                <1>     jz .done
   611 00000263 E865FF              <1>     call write_char
   612 00000266 EBF6                <1>     jmp short .dlp
   613 00000268 5A                  <1> .done pop dx
   614 00000269 58                  <1>     pop ax
   615 0000026A C3                  <1>     ret
   616 0000026B 0A00                <1> .base dw 10
   617                              <1> 
   618                              <1> ; ───────────────────────────────────────────────────────────────────────────
   619                              <1> 
   620                              <1> 
   621                              <1> ; ───────────────────────────────────────────────────────────────────────────
   622                              <1> 
   623                              <1> write_signed_number_word:  
   624 0000026D 50                  <1>     push ax
   625 0000026E 09C0                <1>     or ax,ax
   626 00000270 790A                <1>     jns .write_return        ; if >0 write and return
   627 00000272 50                  <1>     push ax
   628 00000273 B82D00              <1>     mov ax,'-'
   629 00000276 E852FF              <1>     call write_char
   630 00000279 58                  <1>     pop ax
   631 0000027A F7D8                <1>     neg ax                   ; destroys ax when negative
   632                              <1> .write_return:
   633 0000027C E8C9FF              <1>     call write_number_word
   634 0000027F 58                  <1>     pop ax
   635 00000280 C3                  <1>     ret
   636                              <1> 
   637                              <1> ; ───────────────────────────────────────────────────────────────────────────
   638                              <1> 
   639                              <1> check_keys:
   640 00000281 E43A                <1>   in al,0x3a        ; get keyboard status
   641 00000283 88C4                <1>   mov ah,al
   642 00000285 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   643 00000287 2EA2[0600]          <1>   mov [cs:key.ctrl],al
   644 0000028B F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   645 0000028E 7410                <1>   jz .return
   646 00000290 E438                <1>   in al,0x38        ; get data byte from keyboard  
   647 00000292 2EA2[0500]          <1>   mov [cs:key.code],al
   648 00000296 B037                <1>   mov al,0x37
   649 00000298 E63A                <1>   out 0x3a,al       ; drop key?  
   650 0000029A 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   651 0000029C 2EA1[0500]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   652 000002A0 C3                  <1> .return ret
   653                              <1> 
   654                              <1> 
   655                              <1> 
   656                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   657                              <1> ;   ret
   658                              <1> 
   659                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   660                              <1> 
   661                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   662                              <1> ; much faster and simpler on the grid than off the grid
   663                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   664                              <1> 
   665                              <1> 
   666                              <1> ; wide font by stretching the font horizontally using bitshift
   667                              <1> 
   668                              <1> 
   669                              <1> 
   670                              <1> ; ───────────────────────────────────────────────────────────────────────────
   671                              <1> 
   672                              <1> ; clear_area: ; ax=channel, bx=area, di=start pos
   673                              <1> ;   push bx
   674                              <1> ;   push di
   675                              <1> ;   mov es,ax
   676                              <1> ;   xor cx,cx
   677                              <1> ;   mov cl,bh        ; rows (bl)
   678                              <1> ; .rows_loop:
   679                              <1> ;   push cx
   680                              <1> ;   xor cx,cx
   681                              <1> ;   mov cl,bl        ; cols (bh)
   682                              <1> ; .cols_loop:
   683                              <1> ;   mov ax,0
   684                              <1> ;   stosw
   685                              <1> ;   stosw
   686                              <1> ;   loop .cols_loop
   687                              <1> ;   add di,COLS*4    ; one row down
   688                              <1> ;   mov ah,0
   689                              <1> ;   mov al,bl
   690                              <1> ;   times 2 shl ax,1
   691                              <1> ;   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   692                              <1> ;   pop cx
   693                              <1> ;   loop .rows_loop
   694                              <1> ;   pop di
   695                              <1> ;   pop bx
   696                              <1> ;   ret
   697                              <1> 
   698                              <1> ; ───────────────────────────────────────────────────────────────────────────
   699                              <1> 
   700                              <1> ; fill_rect_black: 
   701                              <1> ;   mov ax,RED
   702                              <1> ;   call clear_area
   703                              <1> ;   mov ax,GREEN
   704                              <1> ;   call clear_area
   705                              <1> ;   mov ax,BLUE
   706                              <1> ;   call clear_area
   707                              <1> ;   ret
   708                              <1> 
   709                              <1> ; ───────────────────────────────────────────────────────────────────────────
   710                              <1> 
   711                              <1> draw_spr:
   712 000002A1 53                  <1>   push bx
   713 000002A2 8B1C                <1>   mov bx,[si]
   714 000002A4 46                  <1>   inc si
   715 000002A5 46                  <1>   inc si
   716 000002A6 E80200              <1>   call draw_pic
   717 000002A9 5B                  <1>   pop bx
   718 000002AA C3                  <1>   ret
   719                              <1> 
   720                              <1> draw_pic:
   721 000002AB 50                  <1>   push ax
   722 000002AC B800F0              <1>   mov ax, RED
   723 000002AF E80E00              <1>   call draw_channel
   724 000002B2 B8001C              <1>   mov ax, GREEN
   725 000002B5 E80800              <1>   call draw_channel
   726 000002B8 B800F4              <1>   mov ax, BLUE
   727 000002BB E80200              <1>   call draw_channel
   728 000002BE 58                  <1>   pop ax
   729 000002BF C3                  <1>   ret
   730                              <1> 
   731                              <1> ; ───────────────────────────────────────────────────────────────────────────
   732                              <1> 
   733                              <1> draw_channel:
   734 000002C0 57                  <1>   push di
   735 000002C1 8EC0                <1>   mov es,ax
   736 000002C3 31C9                <1>   xor cx,cx
   737 000002C5 88F9                <1>   mov cl,bh        ; rows (bl)
   738                              <1> .rows_loop:
   739 000002C7 51                  <1>   push cx
   740 000002C8 31C9                <1>   xor cx,cx
   741 000002CA 88D9                <1>   mov cl,bl        ; cols (bh)
   742                              <1> .cols_loop:
   743 000002CC A5                  <1>   movsw
   744 000002CD A5                  <1>   movsw
   745 000002CE E2FC                <1>   loop .cols_loop
   746 000002D0 81C72001            <1>   add di,COLS*4    ; one row down
   747 000002D4 B400                <1>   mov ah,0
   748 000002D6 88D8                <1>   mov al,bl
   749 000002D8 D1E0<rep 2h>        <1>   times 2 shl ax,1
   750 000002DC 29C7                <1>   sub di,ax       ; di-=4*bh   ; bh cols to the left on the new row
   751 000002DE 59                  <1>   pop cx
   752 000002DF E2E6                <1>   loop .rows_loop
   753 000002E1 5F                  <1>   pop di
   754 000002E2 C3                  <1>   ret
   755                              <1> 
   756                              <1> ; ───────────────────────────────────────────────────────────────────────────
   757                              <1> 
   758                              <1> calc_di_from_bx:  ; input bl,bh [0,0,71,49]
   759 000002E3 B89000              <1>   mov ax,144      ; 2*72 cols
   760 000002E6 F6E7                <1>   mul bh          ; bh*=144 resultaat in AX
   761 000002E8 D1E0                <1>   shl ax,1        ; verdubbel AX
   762 000002EA 89C7                <1>   mov di,ax       ; di=ax (=bh*288)
   763 000002EC D0E3                <1>   shl bl,1        ; bl*=2
   764 000002EE D0E3                <1>   shl bl,1        ; bl*=2
   765 000002F0 B700                <1>   mov bh,0
   766 000002F2 01DF                <1>   add di,bx       ; di+=bl
   767 000002F4 83FF00              <1>   cmp di,0
   768 000002F7 7C01                <1>   jl .clamp_top
   769 000002F9 C3                  <1>   ret
   770                              <1> .clamp_top
   771 000002FA 31FF                <1>   xor di,di
   772 000002FC C3                  <1>   ret
   773                              <1> 
   774                              <1> 
   775                              <1> ; ───────────────────────────────────────────────────────────────────────────
   776                              <1> 
   777                              <1> new_line:         ; find the value of DI at start of the next line
   778 000002FD 50                  <1>   push ax
   779 000002FE 53                  <1>   push bx
   780 000002FF 52                  <1>   push dx
   781 00000300 BB2001              <1>   mov bx,288
   782 00000303 31D2                <1>   xor dx,dx
   783 00000305 89F8                <1>   mov ax,di
   784 00000307 F7F3                <1>   div bx
   785 00000309 31D2                <1>   xor dx,dx       ; cwd?
   786 0000030B BB2001              <1>   mov bx,288      ; can reuse x from above?
   787 0000030E 40                  <1>   inc ax
   788 0000030F F7E3                <1>   mul bx
   789 00000311 052001              <1>   add ax,288      ; use bx?
   790 00000314 89C7                <1>   mov di,ax
   791 00000316 5A                  <1>   pop dx
   792 00000317 5B                  <1>   pop bx
   793 00000318 58                  <1>   pop ax
   794 00000319 C3                  <1>   ret
   795                              <1> 
   796                              <1> ; ───────────────────────────────────────────────────────────────────────────
   797                              <1> 
   798                              <1> write_ax_hex:
   799 0000031A 50                  <1>   push ax
   800 0000031B 52                  <1>   push dx
   801 0000031C 31D2                <1>   xor dx,dx
   802 0000031E 52                  <1>   push dx ;high byte is zero
   803 0000031F 31D2                <1> .clp xor dx,dx
   804 00000321 2EF736[4303]        <1>   cs div word [.base]
   805 00000326 92                  <1>   xchg ax,dx
   806 00000327 3C0A                <1>   cmp al,10
   807 00000329 7202                <1>   jb .l1     ; 0-9
   808 0000032B 0407                <1>   add al,7   ; A-F
   809 0000032D 05300E              <1> .l1 add ax,0xe30
   810 00000330 50                  <1>   push ax
   811 00000331 92                  <1>   xchg ax,dx
   812 00000332 09C0                <1>   or ax,ax
   813 00000334 75E9                <1>   jnz .clp
   814 00000336 58                  <1> .dlp pop ax
   815 00000337 08E4                <1>   or ah,ah
   816 00000339 7405                <1>   jz .done
   817 0000033B E88DFE              <1>   call write_char
   818 0000033E EBF6                <1>   jmp short .dlp
   819 00000340 5A                  <1> .done pop dx
   820 00000341 58                  <1>   pop ax
   821 00000342 C3                  <1>   ret
   822 00000343 1000                <1> .base dw 16
   823                              <1> 
   824                              <1> ; calc_di_from_cursor:  ; input cursor, output di
   825                              <1> ;   mov ax,[cursor] 
   826                              <1> ;   sub ax,0x0101   ; cursor is 1 based
   827                              <1> ;   xchg ax,bx      ; bx=ax
   828                              <1> ;   mov ax,144      ; 2*72 cols
   829                              <1> ;   mul bh          ; bh*=144 resultaat in AX
   830                              <1> ;   shl ax,1        ; verdubbel AX
   831                              <1> ;   shl ax,1        ; verdubbel AX
   832                              <1> ;   mov di,ax       ; di=ax (=bh*288)
   833                              <1> ;   shl bl,1        ; bl*=2
   834                              <1> ;   shl bl,1        ; bl*=2
   835                              <1> ;   mov bh,0
   836                              <1> ;   add di,bx       ; di+=bl
   837                              <1> ;   ret
   838                              <1> 
   839                              <1> 
   840                              <1> 
   841                              <1> 
   842                              <1> ; als je cursor gebruikt is dit missch niet nodig.
   843                              <1> ; row_snap:  ; this code detects if DI is in between rows. When DI goes to the next half row it converts it to a whole row.
   844                              <1> ;   push ax
   845                              <1> ;   push bx
   846                              <1> ;   push dx
   847                              <1> ;   mov bx,288
   848                              <1> ;   mov ax,di
   849                              <1> ;   cwd ; xor dx,dx
   850                              <1> ;   div bx
   851                              <1> ;   jnp .done  ; if ax%288==0 
   852                              <1> ;   add di,bx
   853                              <1> ;   .done
   854                              <1> ;   ; add di,dx
   855                              <1> ;   pop dx
   856                              <1> ;   pop bx
   857                              <1> ;   pop ax
   858                              <1> ;   ret
   859                              <1> 
   860                              <1> 
   861                              <1> ; ; ───────────────────────────────────────────────────────────────────────────
   862                              <1> 
   863                              <1> ; calc_di_from_cursor_index:  ; index is cursor index from 0 tot 72*25
   864                              <1> ;   push ax
   865                              <1> ;   push bx
   866                              <1> ;   push dx
   867                              <1> ;   xor dx,dx
   868                              <1> ;   mov ax,[cursor.index]
   869                              <1> ;   mov bx,72
   870                              <1> ;   div bx       ; ax=rows
   871                              <1> ;   push dx      ; dx=cols
   872                              <1> ;   xor dx,dx    ; clear dx for multiplication
   873                              <1> ;   mov bx,576
   874                              <1> ;   mul bx       ; ax contains DI position for row
   875                              <1> ;   mov di,ax
   876                              <1> ;   pop ax       ; ax now contains cols
   877                              <1> ;   shl ax,1     ; *=2
   878                              <1> ;   shl ax,1     ; *=2
   879                              <1> ;   add di,ax
   880                              <1> ;   pop dx
   881                              <1> ;   pop bx
   882                              <1> ;   pop ax
   883                              <1> ;   ret
   884                              <1> 
   885                              <1> ; ───────────────────────────────────────────────────────────────────────────
   886                              <1> 
   887                              <1> 
   888                              <1> ; set_cursor:
   889                              <1> ; cursor_next_char
   890                              <1> 
   891                              <1> 
   892                              <1> 
   893                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   894                              <1> 
     2                                  
     3                                  %include "fill.asm"
     1                              <1> 
     2                              <1> fill_white:
     3 00000345 B8FFFF              <1>   mov ax,0xffff
     4 00000348 E84B00              <1>   call fill_red
     5 0000034B E84F00              <1>   call fill_green
     6 0000034E E85300              <1>   call fill_blue
     7 00000351 C3                  <1>   ret
     8                              <1> 
     9                              <1> fill_pink:
    10 00000352 B8FFFF              <1>   mov ax,0xffff
    11 00000355 E83E00              <1>   call fill_red
    12 00000358 B455                <1>   mov ah,0b01010101
    13 0000035A B0AA                <1>   mov al,0b10101010
    14 0000035C E83E00              <1>   call fill_green
    15 0000035F E84200              <1>   call fill_blue
    16 00000362 C3                  <1>   ret
    17                              <1> 
    18                              <1> fill_pink2:
    19 00000363 B8FFFF              <1>   mov ax,0xffff
    20 00000366 E82D00              <1>   call fill_red
    21 00000369 B4CC                <1>   mov ah,0b11001100
    22 0000036B B033                <1>   mov al,0b00110011
    23 0000036D E82D00              <1>   call fill_green
    24 00000370 E83100              <1>   call fill_blue
    25 00000373 C3                  <1>   ret
    26                              <1> 
    27                              <1> fill_pink3:
    28 00000374 B8FFFF              <1>   mov ax,0xffff
    29 00000377 E81C00              <1>   call fill_red
    30 0000037A B411                <1>   mov ah,0b00010001
    31 0000037C B044                <1>   mov al,0b01000100
    32 0000037E E81C00              <1>   call fill_green
    33 00000381 E82000              <1>   call fill_blue
    34 00000384 C3                  <1>   ret
    35                              <1> 
    36                              <1> fill_pink4:
    37 00000385 B8FFFF              <1>   mov ax,0xffff
    38 00000388 E80B00              <1>   call fill_red
    39 0000038B B4F7                <1>   mov ah,0b11110111
    40 0000038D B07F                <1>   mov al,0b01111111
    41 0000038F E80B00              <1>   call fill_green
    42 00000392 E80F00              <1>   call fill_blue
    43 00000395 C3                  <1>   ret
    44                              <1> 
    45                              <1> fill_red:
    46 00000396 BB00F0              <1>   mov bx,RED
    47 00000399 E80F00              <1>   call fill_channel
    48 0000039C C3                  <1>   ret
    49                              <1> fill_green:
    50 0000039D BB001C              <1>   mov bx,GREEN
    51 000003A0 E80800              <1>   call fill_channel
    52 000003A3 C3                  <1>   ret
    53                              <1> fill_blue:
    54 000003A4 BB00F4              <1>   mov bx,BLUE
    55 000003A7 E80100              <1>   call fill_channel
    56 000003AA C3                  <1>   ret
    57                              <1> 
    58                              <1> fill_channel: ;ax=pattern
    59 000003AB 8EC3                <1>   mov es,bx
    60 000003AD B9201C              <1>   mov cx,COLS*ROWS*2
    61 000003B0 31FF                <1>   xor di,di
    62 000003B2 F3AB                <1>   rep stosw
    63 000003B4 C3                  <1>   ret
     4                                  
     5                                  ; no lookup yet.. just setpix
     6                                  
     7                                  ; channel: dw RED,GREEN,BLUE
     8                                  
     9                                  
    10                                  ; turtle:
    11                                  
    12 000003B5 02                      color: db Color.G
    13 000003B6 0A00                    x: dw 10
    14 000003B8 0A                      y: db 10
    15                                  
    16                                  
    17                                  ; style:
    18                                  ;   .strokeColor
    19                                  ;   .fillColor
    20                                  
    21                                  
    22                                  setup:
    23                                    ; call fill_blue
    24                                  
    25                                    ;blue BG
    26 000003B9 B800F4                    mov ax,BLUE
    27 000003BC 8EC0                      mov es,ax
    28 000003BE 31FF                      xor di,di
    29 000003C0 B8FFFF                    mov ax,-1
    30 000003C3 B9201C                    mov cx,7200
    31 000003C6 F3AB                      rep stosw
    32                                  
    33                                    ;yellow pixel
    34 000003C8 C606[B503]06              mov byte [color], Color.Y
    35 000003CD BB6400                    mov bx, 100   ; x
    36 000003D0 BA1400                    mov dx, 20      ; y
    37 000003D3 E84000                    call setpix
    38                                  
    39                                  
    40                                    ; call calc_di_dl_from_x_y
    41                                    ; call calc_bit_for_pixel ; DI=byte for pixel, DL=bit for pixel in byte
    42                                  
    43 000003D6 F4                        hlt
    44                                    
    45                                  
    46                                  ; ───────────────────────────────────────────────────────────────────────────
    47                                  
    48                                  calc_bit_for_pixel:
    49                                    ;input BX,DX = x,y
    50                                    ;output DI = (y\4)*(4*COLS) + (y%4) + (x\8)*4
    51                                    ;output DL = 2^(7-(x % 8))
    52                                  
    53 000003D7 89D0                      mov ax,dx        ; y
    54 000003D9 31D2                      xor dx,dx        ; dx=0
    55 000003DB B104                      mov cl,4         
    56 000003DD F7F1                      div cx           ; ax=y/4, dx=y%4
    57 000003DF 89D7                      mov di,dx        ; vram offset (dx=y%4)
    58 000003E1 B92001                    mov cx,4*COLS    
    59 000003E4 F7E1                      mul cx           ; ax*=(4*COLS)
    60 000003E6 01C7                      add di,ax        ; di+=ax
    61 000003E8 89D8                      mov ax,bx        ; x
    62 000003EA 31D2                      xor dx,dx        ; dx=0
    63 000003EC B90800                    mov cx,8         
    64 000003EF F7F1                      div cx           ; 8 bits per col
    65 000003F1 B90200                    mov cx,2 
    66 000003F4 D3E0                      shl ax,cl        ; ax*=4       
    67 000003F6 01C7                      add di,ax        ; di+=(x/8)*4
    68                                  
    69 000003F8 B080                      mov al,128       ; highest bit
    70 000003FA 88D1                      mov cl,dl        ; dl contains x%8
    71 000003FC D2E8                      shr al,cl        ; shift right number of bits to the correct pixel in char
    72 000003FE 88C2                      mov dl,al
    73 00000400 C3                        ret
    74                                  
    75                                  ; ───────────────────────────────────────────────────────────────────────────
    76                                  
    77                                  update_pix_in_channel:
    78 00000401 8EC0                      mov es,ax           ; color segment
    79 00000403 88D0                      mov al,dl           ; DL contains active bit pattern
    80 00000405 8436[B503]                test [color], dh    ; deze checkt of de gewenste kleur bevat en of deze pixel in dit kanaal dus aan of uit moet staan.
    81 00000409 7507                      jnz .on
    82 0000040B F6D0                      not al
    83 0000040D 262005                    and [es:di],al  ; off
    84 00000410 EB03                      jmp .done
    85                                  .on
    86 00000412 260805                    or [es:di],al   ; turn on pixel
    87                                  .done
    88 00000415 C3                        ret
    89                                  
    90                                  setpix: 
    91                                  
    92 00000416 E8BEFF                    call calc_bit_for_pixel ; DI=byte for pixel, DL=bit for pixel in byte
    93                                  
    94 00000419 B800F0                    mov ax,RED
    95 0000041C B604                      mov dh,Color.R
    96                                  
    97 0000041E E8E0FF                    call update_pix_in_channel  ; dl is not affected
    98                                  
    99 00000421 B8001C                    mov ax,GREEN
   100 00000424 B602                      mov dh,Color.G
   101 00000426 E8D8FF                    call update_pix_in_channel ; dl is not affected
   102                                  
   103 00000429 B800F4                    mov ax,BLUE
   104 0000042C B601                      mov dh,Color.B
   105 0000042E E8D0FF                    call update_pix_in_channel ; dl is not affected
   106                                  
   107 00000431 C3                        ret 
   108                                  
   109                                  
   110 00000432 00<rep 2CBCEh>          times (180*1024)-($-$$) db 0
   111                                  
   112                                  
   113                                  
