     1                                  %include "sanyo.asm"
     1                              <1> org 0
     2                              <1> cpu 8086
     3                              <1> 
     4                              <1> NUM_SECTORS equ 30          ; number of sectors to read
     5                              <1> BAR_WIDTH equ 30
     6                              <1> COLS  equ 72
     7                              <1> ROWS  equ 50
     8                              <1> LINES equ 200
     9                              <1> CENTER equ COLS*LINES/2+COLS*4/2
    10                              <1> RED   equ 0xf000
    11                              <1> GREEN equ 0x1c00
    12                              <1> BLUE  equ 0xf400
    13                              <1> DST   equ 0x38              ; absolute addres: 32592
    14                              <1> XD    equ 4
    15                              <1> YD    equ COLS*XD
    16                              <1> FONT equ 0xFF00
    17                              <1> BYTES_PER_ROW equ 8*COLS  ; 25 lines
    18                              <1> Color.R equ 0b100
    19                              <1> Color.G equ 0b010
    20                              <1> Color.B equ 0b001
    21                              <1> Color.W equ 0b111
    22                              <1> Color.C equ 0b011
    23                              <1> Color.M equ 0b101
    24                              <1> Color.Y equ 0b110
    25                              <1> Color.K equ 0b000
    26                              <1> ; KEY_PRESSED equ 2
    27                              <1> ; KEY_PRESSED equ 0b0000001000000000
    28                              <1> KEY_CTRL equ 0b0000100000000000
    29                              <1> KEY_A equ 'a'
    30                              <1> KEY_SHIFT_A equ 'A'
    31                              <1> 
    32                              <1> ; KEY_CTRL_A equ KEY_CTRL | KEY_A
    33                              <1> ; KEY_CTRL_SHIFT_A equ KEY_CTRL | KEY_SHIFT_A
    34                              <1> 
    35                              <1> ; A
    36                              <1> ; SHIFT_A
    37                              <1> ; GRAPH_A
    38                              <1> ; CTRL_A
    39                              <1> ; CTRL_SHIFT_A
    40                              <1> ; CTRL_GRAPH_A
    41                              <1> 
    42 00000000 EB04                <1> jmp boot
    43                              <1> 
    44 00000002 00                  <1> cursor.x: db 0
    45 00000003 00                  <1> cursor.y: db 0
    46                              <1> key:
    47 00000004 00                  <1>   .code db 0
    48 00000005 00                  <1>   .ctrl db 0
    49                              <1> 
    50                              <1> %macro set_cursor_row 1
    51                              <1>   mov di,%1 * BYTES_PER_ROW
    52                              <1> %endmacro
    53                              <1> 
    54                              <1> ; %macro if_key 1
    55                              <1> ;   cmp WORD [cs:key], %1
    56                              <1> ; %endmacro
    57                              <1> 
    58                              <1> boot:
    59 00000006 FA                  <1>   cli
    60 00000007 FC                  <1>   cld
    61                              <1> 
    62 00000008 E8C600              <1>   call clear_green          
    63 0000000B B005                <1>   mov al, 5
    64 0000000D E610                <1>   out 10h, al           ; select address 0x1c000 as green video page
    65                              <1> 
    66 0000000F B000                <1>   mov al,0
    67 00000011 E63A                <1>   out 0x3a,al           ; keyboard \force state/
    68 00000013 E63A                <1>   out 0x3a,al           ; keyboard \force state/
    69 00000015 B0FF                <1>   mov al,0xFF
    70 00000017 E63A                <1>   out 0x3a,al           ; keyboard \reset/
    71 00000019 E63A                <1>   out 0x3a,al           ; keyboard \mode/
    72 0000001B B037                <1>   mov al,0x37
    73 0000001D E63A                <1>   out 0x3a,al           ; keyboard \set command
    74                              <1> 
    75 0000001F B8001C              <1>   mov ax,GREEN      
    76 00000022 8ED8                <1>   mov ds,ax                 ; GREEN video segment used for progress bar
    77 00000024 B83800              <1>   mov ax,DST                
    78 00000027 8EC0                <1>   mov es,ax                 ; DST segment used for storing data read from disk
    79 00000029 BF0000              <1>   mov di,0                  ;
    80 0000002C B200                <1>   mov dl,0                  ; track=0
    81 0000002E B601                <1>   mov dh,1                  ; sector=1
    82 00000030 B91E00              <1>   mov cx,NUM_SECTORS        ; read 48h (72) sectors (36864 bytes)
    83 00000033 EB0B                <1>   jmp move_head
    84                              <1> 
    85                              <1> ; ───────────────────────────────────────────────────────────────────────────
    86                              <1> 
    87                              <1> next_sector:
    88 00000035 FEC6                <1>   inc dh                    ; sector++
    89 00000037 80FE0A              <1>   cmp dh,10
    90 0000003A 7218                <1>   jb read_sector            ; if (dh<9) read_sector
    91 0000003C B601                <1>   mov dh,1
    92 0000003E FEC2                <1>   inc dl                    ; else track++ ; sector=1
    93                              <1> 
    94                              <1> move_head:
    95 00000040 88D0                <1>   mov al,dl
    96 00000042 E60E                <1>   out 0Eh,al               ; set track number
    97 00000044 B018                <1>   mov al,18h     
    98 00000046 E608                <1>   out 8,al                 ; seek track, load head
    99 00000048 B000                <1>   mov al,0
   100 0000004A E61C                <1>   out 1Ch,al               ; set desired drive/side
   101 0000004C D40A                <1>   aam
   102                              <1> 
   103                              <1> head_moving:
   104 0000004E E408                <1>   in al,8
   105 00000050 A801                <1>   test al,1
   106 00000052 75FA                <1>   jnz head_moving
   107                              <1> 
   108                              <1> read_sector:
   109 00000054 88F0                <1>   mov al,dh
   110 00000056 E60C                <1>   out 0Ch,al                ; sector number
   111 00000058 B702                <1>   mov bh,2                  ; 00000010b
   112 0000005A B396                <1>   mov bl,96h                ; 10010110b
   113 0000005C B400                <1>   mov ah,0
   114 0000005E B080                <1>   mov al,80h
   115 00000060 E608                <1>   out 8,al                  ; read sector
   116 00000062 D40A<rep 4h>        <1>   times 4 aam               ; wait
   117                              <1> 
   118                              <1> check_status_1:
   119 0000006A E408                <1>   in al,8                   ; read status
   120 0000006C D0F8                <1>   sar al,1                  ; status/=2
   121 0000006E 731F                <1>   jnb check_status_3
   122 00000070 75F8                <1>   jnz check_status_1
   123                              <1> 
   124                              <1> wait_for_data:
   125 00000072 E408                <1>   in al,8                   ; read status
   126 00000074 20D8                <1>   and al,bl                 ; 96h
   127 00000076 74FA                <1>   jz wait_for_data
   128                              <1> 
   129                              <1> store_byte_1:
   130 00000078 E40E                <1>   in al,0Eh
   131 0000007A AA                  <1>   stosb
   132                              <1> 
   133                              <1> check_status_2:
   134 0000007B E408                <1>   in al,8                   ; read status
   135 0000007D 48                  <1>   dec ax                    ; status--
   136 0000007E 74FB                <1>   jz check_status_2         ; if (status==0) repeat
   137 00000080 38F8                <1>   cmp al, bh                ; bh=2
   138 00000082 750B                <1>   jnz check_status_3        ; if (status==1) 
   139                              <1> 
   140                              <1> store_byte_2:
   141 00000084 E40E                <1>   in al,0Eh  
   142 00000086 AA                  <1>   stosb
   143                              <1> 
   144                              <1> check_status_4:
   145 00000087 E408                <1>   in al,8                   ; read status
   146 00000089 38F8                <1>   cmp al, bh                ; bh=2
   147 0000008B 74F7                <1>   jz store_byte_2           ; if (status==2) repeat
   148 0000008D EBEC                <1>   jmp check_status_2        ; else: was jmp SI
   149                              <1> 
   150                              <1> ; ───────────────────────────────────────────────────────────────────────────
   151                              <1> 
   152                              <1> check_status_3:
   153 0000008F E408                <1>   in al, 8                  ; read status
   154 00000091 A81C                <1>   test al, 1Ch              ; 00011100
   155 00000093 7402                <1>   jz while_sectors
   156 00000095 EBBD                <1>   jmp read_sector
   157                              <1> 
   158                              <1> ; ───────────────────────────────────────────────────────────────────────────
   159                              <1> 
   160                              <1> while_sectors:
   161 00000097 E80F00              <1>   call progress_bar
   162 0000009A E299                <1>   loop next_sector
   163                              <1> 
   164                              <1> done_reading:
   165 0000009C 0E                  <1>   push cs
   166 0000009D 17                  <1>   pop ss
   167 0000009E BC0000              <1>   mov sp,0
   168 000000A1 E82D00              <1>   call clear_green
   169 000000A4 0E                  <1>   push cs
   170 000000A5 1F                  <1>   pop ds
   171 000000A6 E9A701              <1>   jmp setup
   172                              <1> 
   173                              <1> ; ───────────────────────────────────────────────────────────────────────────
   174                              <1> 
   175                              <1> progress_bar:
   176                              <1>   ;dit kan veel korter als NUM_SECTORS een vaste waarde heeft.
   177 000000A9 52                  <1>   push dx
   178 000000AA 53                  <1>   push bx
   179 000000AB 31D2                <1>   xor dx,dx
   180 000000AD B81E00              <1>   mov ax,BAR_WIDTH
   181 000000B0 BB1E00              <1>   mov bx,NUM_SECTORS    
   182 000000B3 F7E1                <1>   mul cx
   183 000000B5 F7F3                <1>   div bx
   184 000000B7 5B                  <1>   pop bx
   185 000000B8 5A                  <1>   pop dx
   186 000000B9 89C6                <1>   mov si,ax                 ; ax is nu 0..BAR_WIDTH
   187 000000BB D1E6                <1>   shl si,1                  ; *=2
   188 000000BD D1E6                <1>   shl si,1                  ; *=2  
   189 000000BF BDEC1C              <1>   mov bp,CENTER+BAR_WIDTH*2
   190 000000C2 29F5                <1>   sub bp,si
   191 000000C4 3EC64600FF          <1>   mov byte [ds:bp],-1
   192 000000C9 C3                  <1>   ret
   193                              <1> 
   194                              <1> clear_red:
   195 000000CA B800F0              <1>   mov ax,RED
   196 000000CD E81900              <1>   call clear_channel
   197 000000D0 C3                  <1>   ret
   198                              <1> 
   199                              <1> clear_green:
   200 000000D1 B8001C              <1>   mov ax,GREEN
   201 000000D4 E81200              <1>   call clear_channel
   202 000000D7 C3                  <1>   ret
   203                              <1> 
   204                              <1> clear_blue:
   205 000000D8 B800F4              <1>   mov ax,BLUE
   206 000000DB E80B00              <1>   call clear_channel
   207 000000DE C3                  <1>   ret
   208                              <1> 
   209                              <1> clear_screen:
   210 000000DF E8E8FF              <1>   call clear_red
   211 000000E2 E8ECFF              <1>   call clear_green
   212 000000E5 E8F0FF              <1>   call clear_blue
   213 000000E8 C3                  <1>   ret
   214                              <1> 
   215                              <1> clear_channel:
   216 000000E9 8EC0                <1>   mov es,ax
   217 000000EB B9201C              <1>   mov cx,COLS*ROWS*2
   218 000000EE 31FF                <1>   xor di,di
   219 000000F0 31C0                <1>   xor ax,ax
   220 000000F2 F3AB                <1>   rep stosw         ; clear screen
   221 000000F4 C3                  <1>   ret
   222                              <1> 
   223                              <1> ; set_cursor:
   224                              <1> ; cursor_next_char
   225                              <1> 
   226                              <1> write_char:   ; ds=FONT, es=GREEN, al=charcode
   227                              <1>   ; zou ik hier ds moeten pushen? omdat je er vanuit wilt gaan dat DS en CS altijd gelijk zijn
   228 000000F5 50                  <1>   push ax
   229 000000F6 50                  <1>   push ax
   230 000000F7 B8001C              <1>   mov ax,GREEN
   231 000000FA 8EC0                <1>   mov es,ax
   232 000000FC B800FF              <1>   mov ax,FONT
   233 000000FF 8ED8                <1>   mov ds,ax
   234 00000101 58                  <1>   pop ax
   235 00000102 B408                <1>   mov ah,8
   236 00000104 F6E4                <1>   mul ah        ; al*=ah
   237 00000106 89C6                <1>   mov si,ax
   238 00000108 A5                  <1>   movsw
   239 00000109 A5                  <1>   movsw
   240 0000010A 81C71C01            <1>   add di,0x11c
   241 0000010E A5                  <1>   movsw
   242 0000010F A5                  <1>   movsw
   243 00000110 81EF2001            <1>   sub di,0x120
   244 00000114 81FF4038            <1>   cmp di,14400   ; dit later oplossen met cursor positie
   245 00000118 7202                <1>   jb .return
   246 0000011A 31FF                <1>   xor di,di      ; move to left top. change later to scroll
   247                              <1> .return
   248 0000011C 58                  <1>   pop ax
   249 0000011D C3                  <1>   ret
   250                              <1> 
   251                              <1> write_string:
   252 0000011E 2E8A07              <1>   mov al,[cs:bx]
   253 00000121 43                  <1>   inc bx
   254 00000122 08C0                <1>   or al,al
   255 00000124 7405                <1>   jz .return
   256 00000126 E8CCFF              <1>   call write_char
   257 00000129 EBF3                <1>   jmp short write_string
   258                              <1> .return
   259 0000012B C3                  <1>   ret
   260                              <1> 
   261                              <1> write_binary_byte:    ; input AL
   262 0000012C 50                  <1>   push ax
   263 0000012D 88C3                <1>   mov bl, al          ; Kopieer AL naar BL (we werken op BL)
   264 0000012F B90800              <1>   mov cx, 8           ; We gaan 8 bits schrijven
   265                              <1> .lp:
   266 00000132 D0C3                <1>   rol bl, 1           ; Rotate BL naar links (hoogste bit komt in Carry Flag)
   267 00000134 B80000              <1>   mov ax, 0           ; AH leegmaken
   268 00000137 1430                <1>   adc al, 48          ; Als Carry Flag 1 is, wordt '1', anders '0'  
   269 00000139 51                  <1>   push cx             ; CX opslaan
   270 0000013A E8B8FF              <1>   call write_char      ; Schrijf het karakter naar het scherm
   271 0000013D 59                  <1>   pop cx              ; CX herstellen
   272 0000013E E2F2                <1>   loop .lp            ; Loop voor alle 8 bits
   273 00000140 58                  <1>   pop ax
   274 00000141 C3                  <1>   ret
   275                              <1> 
   276                              <1> write_binary_word:    ; input AX
   277 00000142 50                  <1>   push ax
   278 00000143 52                  <1>   push dx            ; DX opslaan (we gebruiken het later)
   279 00000144 89C2                <1>   mov dx, ax         ; Kopieer AX naar DX (we werken op DX)
   280 00000146 B91000              <1>   mov cx, 16         ; We gaan 16 bits schrijven
   281                              <1> .lp:
   282 00000149 D1C2                <1>   rol dx, 1          ; Rotate DX naar links (hoogste bit komt in Carry Flag)
   283 0000014B B80000              <1>   mov ax, 0          ; AH leegmaken
   284 0000014E 1430                <1>   adc al, 48         ; Als Carry Flag 1 is, wordt '1', anders '0'  
   285 00000150 51                  <1>   push cx            ; CX opslaan
   286 00000151 E8A1FF              <1>   call write_char    ; Schrijf het karakter naar het scherm
   287 00000154 59                  <1>   pop cx             ; CX herstellen
   288 00000155 E2F2                <1>   loop .lp           ; Loop voor alle 16 bits
   289 00000157 5A                  <1>   pop dx             ; DX herstellen
   290 00000158 58                  <1>   pop ax
   291 00000159 C3                  <1>   ret
   292                              <1> 
   293                              <1> write_number_word:
   294 0000015A 50                  <1>     push ax
   295 0000015B 52                  <1>     push dx
   296 0000015C 31D2                <1>     xor dx,dx
   297 0000015E 52                  <1>     push dx ;high byte is zero
   298 0000015F 31D2                <1> .clp xor dx,dx
   299 00000161 2EF736[7D01]        <1>     cs div word [.base]
   300 00000166 92                  <1>     xchg ax,dx
   301 00000167 05300E              <1>     add ax,0xe30
   302 0000016A 50                  <1>     push ax
   303 0000016B 92                  <1>     xchg ax,dx
   304 0000016C 09C0                <1>     or ax,ax
   305 0000016E 75EF                <1>     jnz .clp
   306 00000170 58                  <1> .dlp pop ax
   307 00000171 08E4                <1>     or ah,ah
   308 00000173 7405                <1>     jz .done
   309 00000175 E87DFF              <1>     call write_char
   310 00000178 EBF6                <1>     jmp short .dlp
   311 0000017A 5A                  <1> .done pop dx
   312 0000017B 58                  <1>     pop ax
   313 0000017C C3                  <1>     ret
   314 0000017D 0A00                <1> .base dw 10
   315                              <1> 
   316                              <1> 
   317                              <1> check_keys:
   318 0000017F E43A                <1>   in al,0x3a        ; get keyboard status
   319 00000181 88C4                <1>   mov ah,al
   320 00000183 2408                <1>   and al,0b00001000 ; keep only 1 for 'ctrl'
   321 00000185 2EA2[0500]          <1>   mov [cs:key.ctrl],al
   322 00000189 F6C402              <1>   test ah,2         ; keypressed flag is in ah, not in al anymore
   323 0000018C 7410                <1>   jz .return
   324 0000018E E438                <1>   in al,0x38        ; get data byte from keyboard  
   325 00000190 2EA2[0400]          <1>   mov [cs:key.code],al
   326 00000194 B037                <1>   mov al,0x37
   327 00000196 E63A                <1>   out 0x3a,al       ; drop key?  
   328 00000198 0C01                <1>   or al,1           ; set zero flag to false to indicate a keypress
   329 0000019A 2EA1[0400]          <1>   mov ax,[cs:key]   ; ctrl status in ah, keycode in al, ZF low means a key was pressed
   330 0000019E C3                  <1> .return ret
   331                              <1> 
   332                              <1> 
   333                              <1> 
   334                              <1> ;fillscreen:  ; al=lower 3 bits = Color RGBWCMYK - 4th bit = method???? - support for mask?? - or dither pattern??
   335                              <1> ;   ret
   336                              <1> 
   337                              <1> ;fillarea (minx,miny,maxx,maxy) color, pattern
   338                              <1> 
   339                              <1> ;rect (x,y,width,height) stroke color, strokeweight, fill
   340                              <1> ; much faster and simpler on the grid than off the grid
   341                              <1> ; zou je de randen buiten het grid vooraf of naderhand kunnen doen. en het deel op het grid met de snelle methode
   342                              <1> 
   343                              <1> 
   344                              <1> ; wide font by stretching the font horizontally using bitshift
   345                              <1> 
   346                              <1> 
   347                              <1> fill_white:
   348 0000019F B8FFFF              <1>   mov ax,0xffff
   349 000001A2 E84B00              <1>   call fill_red
   350 000001A5 E84F00              <1>   call fill_green
   351 000001A8 E85300              <1>   call fill_blue
   352 000001AB C3                  <1>   ret
   353                              <1> 
   354                              <1> fill_pink:
   355 000001AC B8FFFF              <1>   mov ax,0xffff
   356 000001AF E83E00              <1>   call fill_red
   357 000001B2 B455                <1>   mov ah,0b01010101
   358 000001B4 B0AA                <1>   mov al,0b10101010
   359 000001B6 E83E00              <1>   call fill_green
   360 000001B9 E84200              <1>   call fill_blue
   361 000001BC C3                  <1>   ret
   362                              <1> 
   363                              <1> fill_pink2:
   364 000001BD B8FFFF              <1>   mov ax,0xffff
   365 000001C0 E82D00              <1>   call fill_red
   366 000001C3 B4CC                <1>   mov ah,0b11001100
   367 000001C5 B033                <1>   mov al,0b00110011
   368 000001C7 E82D00              <1>   call fill_green
   369 000001CA E83100              <1>   call fill_blue
   370 000001CD C3                  <1>   ret
   371                              <1> 
   372                              <1> fill_pink3:
   373 000001CE B8FFFF              <1>   mov ax,0xffff
   374 000001D1 E81C00              <1>   call fill_red
   375 000001D4 B411                <1>   mov ah,0b00010001
   376 000001D6 B044                <1>   mov al,0b01000100
   377 000001D8 E81C00              <1>   call fill_green
   378 000001DB E82000              <1>   call fill_blue
   379 000001DE C3                  <1>   ret
   380                              <1> 
   381                              <1> fill_pink4:
   382 000001DF B8FFFF              <1>   mov ax,0xffff
   383 000001E2 E80B00              <1>   call fill_red
   384 000001E5 B4F7                <1>   mov ah,0b11110111
   385 000001E7 B07F                <1>   mov al,0b01111111
   386 000001E9 E80B00              <1>   call fill_green
   387 000001EC E80F00              <1>   call fill_blue
   388 000001EF C3                  <1>   ret
   389                              <1> 
   390                              <1> fill_red:
   391 000001F0 BB00F0              <1>   mov bx,RED
   392 000001F3 E80F00              <1>   call fill_channel
   393 000001F6 C3                  <1>   ret
   394                              <1> fill_green:
   395 000001F7 BB001C              <1>   mov bx,GREEN
   396 000001FA E80800              <1>   call fill_channel
   397 000001FD C3                  <1>   ret
   398                              <1> fill_blue:
   399 000001FE BB00F4              <1>   mov bx,BLUE
   400 00000201 E80100              <1>   call fill_channel
   401 00000204 C3                  <1>   ret
   402                              <1> 
   403                              <1> fill_channel: ;ax=pattern
   404 00000205 8EC3                <1>   mov es,bx
   405 00000207 B9201C              <1>   mov cx,COLS*ROWS*2
   406 0000020A 31FF                <1>   xor di,di
   407 0000020C F3AB                <1>   rep stosw
   408 0000020E C3                  <1>   ret
   409                              <1> 
   410                              <1> 
   411                              <1> ; ───────────────────────────────────────────────────────────────────────────
   412                              <1> 
   413                              <1> 
   414                              <1> 
   415                              <1> ; times (512)-($-$$) db 0             ; doesn't fit in the bootsector anymore
   416                              <1> 
     2                                  
     3 0000020F 226122202020202020-     msg_a:            db '"a"         ',0
     3 00000218 20202000           
     4 0000021C 53686966742B412020-     msg_shift_a:      db 'Shift+A     ',0
     4 00000225 20202000           
     5 00000229 4374726C2B41202020-     msg_ctrl_a:       db 'Ctrl+A      ',0
     5 00000232 20202000           
     6 00000236 4374726C2B53686966-     msg_ctrl_shift_a: db 'Ctrl+Shift+A',0
     6 0000023F 742B4100           
     7 00000243 4F74686572206B6579-     msg_other_key:    db 'Other key   ',0
     7 0000024C 20202000           
     8                                  
     9                                  
    10                                  setup:
    11 00000250 31ED                      xor bp,bp
    12 00000252 E88AFF                    call fill_pink4
    13 00000255 EB00                      jmp draw
    14                                  
    15                                  draw:
    16 00000257 45                        inc bp
    17 00000258 89E8                      mov ax,bp
    18                                    set_cursor_row 6
    51 0000025A BF800D              <1>  mov di,%1 * BYTES_PER_ROW
    19 0000025D E8FAFE                    call write_number_word
    20                                  
    21                                    
    22 00000260 E81CFF                    call check_keys
    23 00000263 7502                      jnz .onkey
    24                                    ;else
    25 00000265 EBF0                      jmp draw            ; else continue draw loop
    26                                  
    27                                  .onkey:
    28                                    set_cursor_row 0
    51 00000267 BF0000              <1>  mov di,%1 * BYTES_PER_ROW
    29 0000026A 2EA1[0400]                mov ax,[cs:key]
    30 0000026E E8D1FE                    call write_binary_word
    31                                  
    32 00000271 3D6108                    cmp ax,KEY_CTRL+'a'
    33 00000274 7414                        je .on_key_ctrl_a
    34 00000276 3D4108                    cmp ax,KEY_CTRL|'A'
    35 00000279 7414                        je .on_key_ctrl_shift_a
    36 0000027B 83F861                    cmp ax,'a'
    37 0000027E 7414                        je .on_key_a
    38 00000280 83F841                    cmp ax,'A'
    39 00000283 7414                        je .on_key_shift_a
    40                                    ;else
    41 00000285 BB[4302]                    mov bx, msg_other_key             ; msg_other_key
    42 00000288 EB14                        jmp .print_msg
    43                                  
    44                                  .on_key_ctrl_a:
    45 0000028A BB[2902]                  mov bx, msg_ctrl_a                  ; msg_ctrl_a
    46 0000028D EB0F                      jmp .print_msg
    47                                  
    48                                  .on_key_ctrl_shift_a:
    49 0000028F BB[3602]                  mov bx, msg_ctrl_shift_a            ; msg_ctrl_shift_a
    50 00000292 EB0A                      jmp .print_msg
    51                                  
    52                                  .on_key_a:
    53 00000294 BB[0F02]                  mov bx, msg_a                       ; msg_a
    54 00000297 EB05                      jmp .print_msg
    55                                  
    56                                  .on_key_shift_a:
    57 00000299 BB[1C02]                  mov bx, msg_shift_a                       ; msg_a
    58 0000029C EB00                      jmp .print_msg
    59                                  
    60                                  .print_msg:
    61                                    set_cursor_row 1
    51 0000029E BF4002              <1>  mov di,%1 * BYTES_PER_ROW
    62 000002A1 E87AFE                    call write_string
    63                                  
    64 000002A4 EBB1                      jmp draw
    65                                  
    66                                  
    67                                  
    68                                  
    69 000002A6 00<rep 2CD5Ah>          times (180*1024)-($-$$) db 0
    70                                  
